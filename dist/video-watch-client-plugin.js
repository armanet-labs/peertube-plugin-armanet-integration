var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __accessCheck = (obj2, member, msg) => {
  if (!member.has(obj2))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj2, member, getter) => {
  __accessCheck(obj2, member, "read from private field");
  return getter ? getter.call(obj2) : member.get(obj2);
};
var __privateAdd = (obj2, member, value) => {
  if (member.has(obj2))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value);
};
var __privateSet = (obj2, member, value, setter) => {
  __accessCheck(obj2, member, "write to private field");
  setter ? setter.call(obj2, value) : member.set(obj2, value);
  return value;
};

// node_modules/@dailymotion/vast-client/dist/vast-client.min.js
var require_vast_client_min = __commonJS({
  "node_modules/@dailymotion/vast-client/dist/vast-client.min.js"(exports, module) {
    !function(e, t) {
      typeof exports == "object" && typeof module != "undefined" ? t(exports) : typeof define == "function" && define.amd ? define(["exports"], t) : t((e = typeof globalThis != "undefined" ? globalThis : e || self).VAST = {});
    }(exports, function(e) {
      "use strict";
      function t(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function r(e2) {
        for (var r2 = 1; r2 < arguments.length; r2++) {
          var i2 = arguments[r2] != null ? arguments[r2] : {};
          r2 % 2 ? t(Object(i2), true).forEach(function(t2) {
            s(e2, t2, i2[t2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : t(Object(i2)).forEach(function(t2) {
            Object.defineProperty(e2, t2, Object.getOwnPropertyDescriptor(i2, t2));
          });
        }
        return e2;
      }
      function i(e2) {
        return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, i(e2);
      }
      function n(e2, t2) {
        if (!(e2 instanceof t2))
          throw new TypeError("Cannot call a class as a function");
      }
      function a(e2, t2) {
        for (var r2 = 0; r2 < t2.length; r2++) {
          var i2 = t2[r2];
          i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, i2.key, i2);
        }
      }
      function o(e2, t2, r2) {
        return t2 && a(e2.prototype, t2), r2 && a(e2, r2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
      }
      function s(e2, t2, r2) {
        return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
      }
      function l(e2, t2) {
        if (typeof t2 != "function" && t2 !== null)
          throw new TypeError("Super expression must either be null or a function");
        e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t2 && c(e2, t2);
      }
      function u(e2) {
        return u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
          return e3.__proto__ || Object.getPrototypeOf(e3);
        }, u(e2);
      }
      function c(e2, t2) {
        return c = Object.setPrototypeOf || function(e3, t3) {
          return e3.__proto__ = t3, e3;
        }, c(e2, t2);
      }
      function d(e2, t2) {
        if (t2 && (typeof t2 == "object" || typeof t2 == "function"))
          return t2;
        if (t2 !== void 0)
          throw new TypeError("Derived constructors may only return object or undefined");
        return function(e3) {
          if (e3 === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e3;
        }(e2);
      }
      function p(e2) {
        var t2 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (e3) {
            return false;
          }
        }();
        return function() {
          var r2, i2 = u(e2);
          if (t2) {
            var n2 = u(this).constructor;
            r2 = Reflect.construct(i2, arguments, n2);
          } else
            r2 = i2.apply(this, arguments);
          return d(this, r2);
        };
      }
      function h(e2) {
        return function(e3) {
          if (Array.isArray(e3))
            return v(e3);
        }(e2) || function(e3) {
          if (typeof Symbol != "undefined" && e3[Symbol.iterator] != null || e3["@@iterator"] != null)
            return Array.from(e3);
        }(e2) || function(e3, t2) {
          if (!e3)
            return;
          if (typeof e3 == "string")
            return v(e3, t2);
          var r2 = Object.prototype.toString.call(e3).slice(8, -1);
          r2 === "Object" && e3.constructor && (r2 = e3.constructor.name);
          if (r2 === "Map" || r2 === "Set")
            return Array.from(e3);
          if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
            return v(e3, t2);
        }(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function v(e2, t2) {
        (t2 == null || t2 > e2.length) && (t2 = e2.length);
        for (var r2 = 0, i2 = new Array(t2); r2 < t2; r2++)
          i2[r2] = e2[r2];
        return i2;
      }
      function f() {
        var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return { id: e2.id || null, adId: e2.adId || null, sequence: e2.sequence || null, apiFramework: e2.apiFramework || null, universalAdIds: [], creativeExtensions: [] };
      }
      var m = ["ADCATEGORIES", "ADCOUNT", "ADPLAYHEAD", "ADSERVINGID", "ADTYPE", "APIFRAMEWORKS", "APPBUNDLE", "ASSETURI", "BLOCKEDADCATEGORIES", "BREAKMAXADLENGTH", "BREAKMAXADS", "BREAKMAXDURATION", "BREAKMINADLENGTH", "BREAKMINDURATION", "BREAKPOSITION", "CLICKPOS", "CLICKTYPE", "CLIENTUA", "CONTENTID", "CONTENTPLAYHEAD", "CONTENTURI", "DEVICEIP", "DEVICEUA", "DOMAIN", "EXTENSIONS", "GDPRCONSENT", "IFA", "IFATYPE", "INVENTORYSTATE", "LATLONG", "LIMITADTRACKING", "MEDIAMIME", "MEDIAPLAYHEAD", "OMIDPARTNER", "PAGEURL", "PLACEMENTTYPE", "PLAYERCAPABILITIES", "PLAYERSIZE", "PLAYERSTATE", "PODSEQUENCE", "REGULATIONS", "SERVERSIDE", "SERVERUA", "TRANSACTIONID", "UNIVERSALADID", "VASTVERSIONS", "VERIFICATIONVENDORS"];
      function g(e2) {
        var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i2 = [], n2 = A(e2);
        for (var a2 in !t2.ERRORCODE || r2.isCustomCode || /^[0-9]{3}$/.test(t2.ERRORCODE) || (t2.ERRORCODE = 900), t2.CACHEBUSTING = E(Math.round(1e8 * Math.random())), t2.TIMESTAMP = new Date().toISOString(), t2.RANDOM = t2.random = t2.CACHEBUSTING, t2)
          t2[a2] = b(t2[a2]);
        for (var o2 in n2) {
          var s2 = n2[o2];
          typeof s2 == "string" && i2.push(y(s2, t2));
        }
        return i2;
      }
      function y(e2, t2) {
        var r2 = (e2 = T(e2, t2)).match(/[^[\]]+(?=])/g);
        if (!r2)
          return e2;
        var i2 = r2.filter(function(e3) {
          return m.indexOf(e3) > -1;
        });
        return i2.length === 0 ? e2 : T(e2, i2 = i2.reduce(function(e3, t3) {
          return e3[t3] = -1, e3;
        }, {}));
      }
      function T(e2, t2) {
        var r2 = e2;
        for (var i2 in t2) {
          var n2 = t2[i2];
          r2 = r2.replace(new RegExp("(?:\\[|%%)(".concat(i2, ")(?:\\]|%%)"), "g"), n2);
        }
        return r2;
      }
      function A(e2) {
        return Array.isArray(e2) ? e2.map(function(e3) {
          return e3 && e3.hasOwnProperty("url") ? e3.url : e3;
        }) : e2;
      }
      function k(e2, t2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          if (R(t2[r2], e2))
            return true;
        return false;
      }
      function R(e2, t2) {
        if (e2 && t2) {
          var r2 = Object.getOwnPropertyNames(e2), i2 = Object.getOwnPropertyNames(t2);
          return r2.length === i2.length && (e2.id === t2.id && e2.url === t2.url);
        }
        return false;
      }
      function b(e2) {
        return encodeURIComponent(e2).replace(/[!'()*]/g, function(e3) {
          return "%".concat(e3.charCodeAt(0).toString(16));
        });
      }
      function E(e2) {
        var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
        return e2.toString().padStart(t2, "0");
      }
      var N = { track: function(e2, t2, r2) {
        g(e2, t2, r2).forEach(function(e3) {
          typeof window != "undefined" && window !== null && (new Image().src = e3);
        });
      }, resolveURLTemplates: g, extractURLsFromTemplates: A, containsTemplateObject: k, isTemplateObjectEqual: R, encodeURIComponentRFC3986: b, replaceUrlMacros: y, isNumeric: function(e2) {
        return !isNaN(parseFloat(e2)) && isFinite(e2);
      }, flatten: function e2(t2) {
        return t2.reduce(function(t3, r2) {
          return t3.concat(Array.isArray(r2) ? e2(r2) : r2);
        }, []);
      }, joinArrayOfUniqueTemplateObjs: function() {
        var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r2 = Array.isArray(e2) ? e2 : [], i2 = Array.isArray(t2) ? t2 : [], n2 = r2.concat(i2);
        return n2.reduce(function(e3, t3) {
          return k(t3, e3) || e3.push(t3), e3;
        }, []);
      }, isValidTimeValue: function(e2) {
        return Number.isFinite(e2) && e2 >= -2;
      }, addLeadingZeros: E };
      function L(e2) {
        return ["true", "TRUE", "True", "1"].indexOf(e2) !== -1;
      }
      var w = { childByName: function(e2, t2) {
        var r2 = e2.childNodes;
        for (var i2 in r2) {
          var n2 = r2[i2];
          if (n2.nodeName === t2)
            return n2;
        }
      }, childrenByName: function(e2, t2) {
        var r2 = [], i2 = e2.childNodes;
        for (var n2 in i2) {
          var a2 = i2[n2];
          a2.nodeName === t2 && r2.push(a2);
        }
        return r2;
      }, resolveVastAdTagURI: function(e2, t2) {
        if (!t2)
          return e2;
        if (e2.indexOf("//") === 0) {
          var r2 = location.protocol;
          return "".concat(r2).concat(e2);
        }
        if (e2.indexOf("://") === -1) {
          var i2 = t2.slice(0, t2.lastIndexOf("/"));
          return "".concat(i2, "/").concat(e2);
        }
        return e2;
      }, parseBoolean: L, parseNodeText: function(e2) {
        return e2 && (e2.textContent || e2.text || "").trim();
      }, copyNodeAttribute: function(e2, t2, r2) {
        var i2 = t2.getAttribute(e2);
        i2 && r2.setAttribute(e2, i2);
      }, parseAttributes: function(e2) {
        for (var t2 = e2.attributes, r2 = {}, i2 = 0; i2 < t2.length; i2++)
          r2[t2[i2].nodeName] = t2[i2].nodeValue;
        return r2;
      }, parseDuration: function(e2) {
        if (e2 == null)
          return -1;
        if (N.isNumeric(e2))
          return parseInt(e2);
        var t2 = e2.split(":");
        if (t2.length !== 3)
          return -1;
        var r2 = t2[2].split("."), i2 = parseInt(r2[0]);
        r2.length === 2 && (i2 += parseFloat("0.".concat(r2[1])));
        var n2 = parseInt(60 * t2[1]), a2 = parseInt(60 * t2[0] * 60);
        return isNaN(a2) || isNaN(n2) || isNaN(i2) || n2 > 3600 || i2 > 60 ? -1 : a2 + n2 + i2;
      }, splitVAST: function(e2) {
        var t2 = [], r2 = null;
        return e2.forEach(function(i2, n2) {
          if (i2.sequence && (i2.sequence = parseInt(i2.sequence, 10)), i2.sequence > 1) {
            var a2 = e2[n2 - 1];
            if (a2 && a2.sequence === i2.sequence - 1)
              return void (r2 && r2.push(i2));
            delete i2.sequence;
          }
          r2 = [i2], t2.push(r2);
        }), t2;
      }, assignAttributes: function(e2, t2) {
        if (e2)
          for (var r2 in e2) {
            var i2 = e2[r2];
            if (i2.nodeName && i2.nodeValue && t2.hasOwnProperty(i2.nodeName)) {
              var n2 = i2.nodeValue;
              typeof t2[i2.nodeName] == "boolean" && (n2 = L(n2)), t2[i2.nodeName] = n2;
            }
          }
      }, mergeWrapperAdData: function(e2, t2) {
        e2.errorURLTemplates = t2.errorURLTemplates.concat(e2.errorURLTemplates), e2.impressionURLTemplates = t2.impressionURLTemplates.concat(e2.impressionURLTemplates), e2.extensions = t2.extensions.concat(e2.extensions), t2.viewableImpression.length > 0 && (e2.viewableImpression = [].concat(h(e2.viewableImpression), h(t2.viewableImpression))), e2.followAdditionalWrappers = t2.followAdditionalWrappers, e2.allowMultipleAds = t2.allowMultipleAds, e2.fallbackOnNoAd = t2.fallbackOnNoAd;
        var r2 = (t2.creatives || []).filter(function(e3) {
          return e3 && e3.type === "companion";
        }), i2 = r2.reduce(function(e3, t3) {
          return (t3.variations || []).forEach(function(t4) {
            (t4.companionClickTrackingURLTemplates || []).forEach(function(t5) {
              N.containsTemplateObject(t5, e3) || e3.push(t5);
            });
          }), e3;
        }, []);
        e2.creatives = r2.concat(e2.creatives);
        var n2 = t2.videoClickTrackingURLTemplates && t2.videoClickTrackingURLTemplates.length, a2 = t2.videoCustomClickURLTemplates && t2.videoCustomClickURLTemplates.length;
        e2.creatives.forEach(function(e3) {
          if (t2.trackingEvents && t2.trackingEvents[e3.type])
            for (var r3 in t2.trackingEvents[e3.type]) {
              var o2 = t2.trackingEvents[e3.type][r3];
              Array.isArray(e3.trackingEvents[r3]) || (e3.trackingEvents[r3] = []), e3.trackingEvents[r3] = e3.trackingEvents[r3].concat(o2);
            }
          e3.type === "linear" && (n2 && (e3.videoClickTrackingURLTemplates = e3.videoClickTrackingURLTemplates.concat(t2.videoClickTrackingURLTemplates)), a2 && (e3.videoCustomClickURLTemplates = e3.videoCustomClickURLTemplates.concat(t2.videoCustomClickURLTemplates)), !t2.videoClickThroughURLTemplate || e3.videoClickThroughURLTemplate !== null && e3.videoClickThroughURLTemplate !== void 0 || (e3.videoClickThroughURLTemplate = t2.videoClickThroughURLTemplate)), e3.type === "companion" && i2.length && (e3.variations || []).forEach(function(e4) {
            e4.companionClickTrackingURLTemplates = N.joinArrayOfUniqueTemplateObjs(e4.companionClickTrackingURLTemplates, i2);
          });
        }), t2.adVerifications && (e2.adVerifications = e2.adVerifications.concat(t2.adVerifications)), t2.blockedAdCategories && (e2.blockedAdCategories = e2.blockedAdCategories.concat(t2.blockedAdCategories));
      } };
      function U(e2, t2) {
        var r2 = function() {
          var e3 = f(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}), t3 = e3.id, r3 = e3.adId, i2 = e3.sequence, n2 = e3.apiFramework;
          return { id: t3, adId: r3, sequence: i2, apiFramework: n2, type: "companion", required: null, variations: [] };
        }(t2);
        return r2.required = e2.getAttribute("required") || null, r2.variations = w.childrenByName(e2, "Companion").map(function(e3) {
          var t3 = function() {
            var e4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return { id: e4.id || null, adType: "companionAd", width: e4.width || 0, height: e4.height || 0, assetWidth: e4.assetWidth || null, assetHeight: e4.assetHeight || null, expandedWidth: e4.expandedWidth || null, expandedHeight: e4.expandedHeight || null, apiFramework: e4.apiFramework || null, adSlotID: e4.adSlotID || null, pxratio: e4.pxratio || "1", renderingMode: e4.renderingMode || "default", staticResources: [], htmlResources: [], iframeResources: [], adParameters: null, xmlEncoded: null, altText: null, companionClickThroughURLTemplate: null, companionClickTrackingURLTemplates: [], trackingEvents: {} };
          }(w.parseAttributes(e3));
          t3.htmlResources = w.childrenByName(e3, "HTMLResource").reduce(function(e4, t4) {
            var r4 = w.parseNodeText(t4);
            return r4 ? e4.concat(r4) : e4;
          }, []), t3.iframeResources = w.childrenByName(e3, "IFrameResource").reduce(function(e4, t4) {
            var r4 = w.parseNodeText(t4);
            return r4 ? e4.concat(r4) : e4;
          }, []), t3.staticResources = w.childrenByName(e3, "StaticResource").reduce(function(e4, t4) {
            var r4 = w.parseNodeText(t4);
            return r4 ? e4.concat({ url: r4, creativeType: t4.getAttribute("creativeType") || null }) : e4;
          }, []), t3.altText = w.parseNodeText(w.childByName(e3, "AltText")) || null;
          var r3 = w.childByName(e3, "TrackingEvents");
          r3 && w.childrenByName(r3, "Tracking").forEach(function(e4) {
            var r4 = e4.getAttribute("event"), i3 = w.parseNodeText(e4);
            r4 && i3 && (Array.isArray(t3.trackingEvents[r4]) || (t3.trackingEvents[r4] = []), t3.trackingEvents[r4].push(i3));
          }), t3.companionClickTrackingURLTemplates = w.childrenByName(e3, "CompanionClickTracking").map(function(e4) {
            return { id: e4.getAttribute("id") || null, url: w.parseNodeText(e4) };
          }), t3.companionClickThroughURLTemplate = w.parseNodeText(w.childByName(e3, "CompanionClickThrough")) || null;
          var i2 = w.childByName(e3, "AdParameters");
          return i2 && (t3.adParameters = w.parseNodeText(i2), t3.xmlEncoded = i2.getAttribute("xmlEncoded") || null), t3;
        }), r2;
      }
      function C(e2) {
        return e2.type === "linear";
      }
      function I(e2, t2) {
        var r2, i2 = function() {
          var e3 = f(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}), t3 = e3.id, r3 = e3.adId, i3 = e3.sequence, n3 = e3.apiFramework;
          return { id: t3, adId: r3, sequence: i3, apiFramework: n3, type: "linear", duration: 0, skipDelay: null, mediaFiles: [], mezzanine: null, interactiveCreativeFile: null, closedCaptionFiles: [], videoClickThroughURLTemplate: null, videoClickTrackingURLTemplates: [], videoCustomClickURLTemplates: [], adParameters: null, icons: [], trackingEvents: {} };
        }(t2);
        i2.duration = w.parseDuration(w.parseNodeText(w.childByName(e2, "Duration")));
        var n2 = e2.getAttribute("skipoffset");
        if (n2 == null)
          i2.skipDelay = null;
        else if (n2.charAt(n2.length - 1) === "%" && i2.duration !== -1) {
          var a2 = parseInt(n2, 10);
          i2.skipDelay = i2.duration * (a2 / 100);
        } else
          i2.skipDelay = w.parseDuration(n2);
        var o2 = w.childByName(e2, "VideoClicks");
        if (o2) {
          var s2 = w.childByName(o2, "ClickThrough");
          i2.videoClickThroughURLTemplate = s2 ? { id: s2.getAttribute("id") || null, url: w.parseNodeText(s2) } : null, w.childrenByName(o2, "ClickTracking").forEach(function(e3) {
            i2.videoClickTrackingURLTemplates.push({ id: e3.getAttribute("id") || null, url: w.parseNodeText(e3) });
          }), w.childrenByName(o2, "CustomClick").forEach(function(e3) {
            i2.videoCustomClickURLTemplates.push({ id: e3.getAttribute("id") || null, url: w.parseNodeText(e3) });
          });
        }
        var l2 = w.childByName(e2, "AdParameters");
        l2 && (i2.adParameters = w.parseNodeText(l2)), w.childrenByName(e2, "TrackingEvents").forEach(function(e3) {
          w.childrenByName(e3, "Tracking").forEach(function(e4) {
            var t3 = e4.getAttribute("event"), n3 = w.parseNodeText(e4);
            if (t3 && n3) {
              if (t3 === "progress") {
                if (!(r2 = e4.getAttribute("offset")))
                  return;
                t3 = r2.charAt(r2.length - 1) === "%" ? "progress-".concat(r2) : "progress-".concat(Math.round(w.parseDuration(r2)));
              }
              Array.isArray(i2.trackingEvents[t3]) || (i2.trackingEvents[t3] = []), i2.trackingEvents[t3].push(n3);
            }
          });
        }), w.childrenByName(e2, "MediaFiles").forEach(function(e3) {
          w.childrenByName(e3, "MediaFile").forEach(function(e4) {
            i2.mediaFiles.push(function(e5) {
              var t4 = { id: null, fileURL: null, fileSize: 0, deliveryType: "progressive", mimeType: null, mediaType: null, codec: null, bitrate: 0, minBitrate: 0, maxBitrate: 0, width: 0, height: 0, apiFramework: null, scalable: null, maintainAspectRatio: null };
              t4.id = e5.getAttribute("id"), t4.fileURL = w.parseNodeText(e5), t4.deliveryType = e5.getAttribute("delivery"), t4.codec = e5.getAttribute("codec"), t4.mimeType = e5.getAttribute("type"), t4.mediaType = e5.getAttribute("mediaType") || "2D", t4.apiFramework = e5.getAttribute("apiFramework"), t4.fileSize = parseInt(e5.getAttribute("fileSize") || 0), t4.bitrate = parseInt(e5.getAttribute("bitrate") || 0), t4.minBitrate = parseInt(e5.getAttribute("minBitrate") || 0), t4.maxBitrate = parseInt(e5.getAttribute("maxBitrate") || 0), t4.width = parseInt(e5.getAttribute("width") || 0), t4.height = parseInt(e5.getAttribute("height") || 0);
              var r4 = e5.getAttribute("scalable");
              r4 && typeof r4 == "string" && (t4.scalable = w.parseBoolean(r4));
              var i3 = e5.getAttribute("maintainAspectRatio");
              i3 && typeof i3 == "string" && (t4.maintainAspectRatio = w.parseBoolean(i3));
              return t4;
            }(e4));
          });
          var t3 = w.childByName(e3, "InteractiveCreativeFile");
          t3 && (i2.interactiveCreativeFile = function(e4) {
            var t4 = function() {
              var e5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return { type: e5.type || null, apiFramework: e5.apiFramework || null, variableDuration: w.parseBoolean(e5.variableDuration), fileURL: null };
            }(w.parseAttributes(e4));
            return t4.fileURL = w.parseNodeText(e4), t4;
          }(t3));
          var r3 = w.childByName(e3, "ClosedCaptionFiles");
          r3 && w.childrenByName(r3, "ClosedCaptionFile").forEach(function(e4) {
            var t4 = function() {
              var e5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return { type: e5.type || null, language: e5.language || null, fileURL: null };
            }(w.parseAttributes(e4));
            t4.fileURL = w.parseNodeText(e4), i2.closedCaptionFiles.push(t4);
          });
          var n3, a3, o3, s3 = w.childByName(e3, "Mezzanine"), l3 = (n3 = s3, a3 = {}, o3 = false, ["delivery", "type", "width", "height"].forEach(function(e4) {
            n3 && n3.getAttribute(e4) ? a3[e4] = n3.getAttribute(e4) : o3 = true;
          }), o3 ? null : a3);
          if (l3) {
            var u3 = { id: null, fileURL: null, delivery: null, codec: null, type: null, width: 0, height: 0, fileSize: 0, mediaType: "2D" };
            u3.id = s3.getAttribute("id"), u3.fileURL = w.parseNodeText(s3), u3.delivery = l3.delivery, u3.codec = s3.getAttribute("codec"), u3.type = l3.type, u3.width = parseInt(l3.width, 10), u3.height = parseInt(l3.height, 10), u3.fileSize = parseInt(s3.getAttribute("fileSize"), 10), u3.mediaType = s3.getAttribute("mediaType") || "2D", i2.mezzanine = u3;
          }
        });
        var u2 = w.childByName(e2, "Icons");
        return u2 && w.childrenByName(u2, "Icon").forEach(function(e3) {
          i2.icons.push(function(e4) {
            var t3 = { program: null, height: 0, width: 0, xPosition: 0, yPosition: 0, apiFramework: null, offset: null, duration: 0, type: null, staticResource: null, htmlResource: null, iframeResource: null, pxratio: "1", iconClickThroughURLTemplate: null, iconClickTrackingURLTemplates: [], iconViewTrackingURLTemplate: null };
            t3.program = e4.getAttribute("program"), t3.height = parseInt(e4.getAttribute("height") || 0), t3.width = parseInt(e4.getAttribute("width") || 0), t3.xPosition = function(e5) {
              if (["left", "right"].indexOf(e5) !== -1)
                return e5;
              return parseInt(e5 || 0);
            }(e4.getAttribute("xPosition")), t3.yPosition = function(e5) {
              if (["top", "bottom"].indexOf(e5) !== -1)
                return e5;
              return parseInt(e5 || 0);
            }(e4.getAttribute("yPosition")), t3.apiFramework = e4.getAttribute("apiFramework"), t3.pxratio = e4.getAttribute("pxratio") || "1", t3.offset = w.parseDuration(e4.getAttribute("offset")), t3.duration = w.parseDuration(e4.getAttribute("duration")), w.childrenByName(e4, "HTMLResource").forEach(function(e5) {
              t3.type = e5.getAttribute("creativeType") || "text/html", t3.htmlResource = w.parseNodeText(e5);
            }), w.childrenByName(e4, "IFrameResource").forEach(function(e5) {
              t3.type = e5.getAttribute("creativeType") || 0, t3.iframeResource = w.parseNodeText(e5);
            }), w.childrenByName(e4, "StaticResource").forEach(function(e5) {
              t3.type = e5.getAttribute("creativeType") || 0, t3.staticResource = w.parseNodeText(e5);
            });
            var r3 = w.childByName(e4, "IconClicks");
            r3 && (t3.iconClickThroughURLTemplate = w.parseNodeText(w.childByName(r3, "IconClickThrough")), w.childrenByName(r3, "IconClickTracking").forEach(function(e5) {
              t3.iconClickTrackingURLTemplates.push({ id: e5.getAttribute("id") || null, url: w.parseNodeText(e5) });
            }));
            return t3.iconViewTrackingURLTemplate = w.parseNodeText(w.childByName(e4, "IconViewTracking")), t3;
          }(e3));
        }), i2;
      }
      function x(e2, t2) {
        var r2 = function() {
          var e3 = f(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}), t3 = e3.id, r3 = e3.adId, i2 = e3.sequence, n2 = e3.apiFramework;
          return { id: t3, adId: r3, sequence: i2, apiFramework: n2, type: "nonlinear", variations: [], trackingEvents: {} };
        }(t2);
        return w.childrenByName(e2, "TrackingEvents").forEach(function(e3) {
          var t3, i2;
          w.childrenByName(e3, "Tracking").forEach(function(e4) {
            t3 = e4.getAttribute("event"), i2 = w.parseNodeText(e4), t3 && i2 && (Array.isArray(r2.trackingEvents[t3]) || (r2.trackingEvents[t3] = []), r2.trackingEvents[t3].push(i2));
          });
        }), w.childrenByName(e2, "NonLinear").forEach(function(e3) {
          var t3 = { id: null, width: 0, height: 0, expandedWidth: 0, expandedHeight: 0, scalable: true, maintainAspectRatio: true, minSuggestedDuration: 0, apiFramework: "static", adType: "nonLinearAd", type: null, staticResource: null, htmlResource: null, iframeResource: null, nonlinearClickThroughURLTemplate: null, nonlinearClickTrackingURLTemplates: [], adParameters: null };
          t3.id = e3.getAttribute("id") || null, t3.width = e3.getAttribute("width"), t3.height = e3.getAttribute("height"), t3.expandedWidth = e3.getAttribute("expandedWidth"), t3.expandedHeight = e3.getAttribute("expandedHeight"), t3.scalable = w.parseBoolean(e3.getAttribute("scalable")), t3.maintainAspectRatio = w.parseBoolean(e3.getAttribute("maintainAspectRatio")), t3.minSuggestedDuration = w.parseDuration(e3.getAttribute("minSuggestedDuration")), t3.apiFramework = e3.getAttribute("apiFramework"), w.childrenByName(e3, "HTMLResource").forEach(function(e4) {
            t3.type = e4.getAttribute("creativeType") || "text/html", t3.htmlResource = w.parseNodeText(e4);
          }), w.childrenByName(e3, "IFrameResource").forEach(function(e4) {
            t3.type = e4.getAttribute("creativeType") || 0, t3.iframeResource = w.parseNodeText(e4);
          }), w.childrenByName(e3, "StaticResource").forEach(function(e4) {
            t3.type = e4.getAttribute("creativeType") || 0, t3.staticResource = w.parseNodeText(e4);
          });
          var i2 = w.childByName(e3, "AdParameters");
          i2 && (t3.adParameters = w.parseNodeText(i2)), t3.nonlinearClickThroughURLTemplate = w.parseNodeText(w.childByName(e3, "NonLinearClickThrough")), w.childrenByName(e3, "NonLinearClickTracking").forEach(function(e4) {
            t3.nonlinearClickTrackingURLTemplates.push({ id: e4.getAttribute("id") || null, url: w.parseNodeText(e4) });
          }), r2.variations.push(t3);
        }), r2;
      }
      function S(e2) {
        var t2 = [];
        return e2.forEach(function(e3) {
          var r2 = O(e3);
          r2 && t2.push(r2);
        }), t2;
      }
      function O(e2) {
        if (e2.nodeName === "#comment")
          return null;
        var t2, r2 = { name: null, value: null, attributes: {}, children: [] }, i2 = e2.attributes, n2 = e2.childNodes;
        if (r2.name = e2.nodeName, e2.attributes) {
          for (var a2 in i2)
            if (i2.hasOwnProperty(a2)) {
              var o2 = i2[a2];
              o2.nodeName && o2.nodeValue && (r2.attributes[o2.nodeName] = o2.nodeValue);
            }
        }
        for (var s2 in n2)
          if (n2.hasOwnProperty(s2)) {
            var l2 = O(n2[s2]);
            l2 && r2.children.push(l2);
          }
        if (r2.children.length === 0 || r2.children.length === 1 && ["#cdata-section", "#text"].indexOf(r2.children[0].name) >= 0) {
          var u2 = w.parseNodeText(e2);
          u2 !== "" && (r2.value = u2), r2.children = [];
        }
        return (t2 = r2).value === null && Object.keys(t2.attributes).length === 0 && t2.children.length === 0 ? null : r2;
      }
      function D(e2) {
        var t2 = [];
        return e2.forEach(function(e3) {
          var r2, i2 = { id: e3.getAttribute("id") || null, adId: V(e3), sequence: e3.getAttribute("sequence") || null, apiFramework: e3.getAttribute("apiFramework") || null }, n2 = [];
          w.childrenByName(e3, "UniversalAdId").forEach(function(e4) {
            var t3 = { idRegistry: e4.getAttribute("idRegistry") || "unknown", value: w.parseNodeText(e4) };
            n2.push(t3);
          });
          var a2 = w.childByName(e3, "CreativeExtensions");
          for (var o2 in a2 && (r2 = S(w.childrenByName(a2, "CreativeExtension"))), e3.childNodes) {
            var s2 = e3.childNodes[o2], l2 = void 0;
            switch (s2.nodeName) {
              case "Linear":
                l2 = I(s2, i2);
                break;
              case "NonLinearAds":
                l2 = x(s2, i2);
                break;
              case "CompanionAds":
                l2 = U(s2, i2);
            }
            l2 && (n2 && (l2.universalAdIds = n2), r2 && (l2.creativeExtensions = r2), t2.push(l2));
          }
        }), t2;
      }
      function V(e2) {
        return e2.getAttribute("AdID") || e2.getAttribute("adID") || e2.getAttribute("adId") || null;
      }
      var P = { Wrapper: { subElements: ["VASTAdTagURI", "Impression"] }, BlockedAdCategories: { attributes: ["authority"] }, InLine: { subElements: ["AdSystem", "AdTitle", "Impression", "AdServingId", "Creatives"] }, Category: { attributes: ["authority"] }, Pricing: { attributes: ["model", "currency"] }, Verification: { oneOfinLineResources: ["JavaScriptResource", "ExecutableResource"], attributes: ["vendor"] }, UniversalAdId: { attributes: ["idRegistry"] }, JavaScriptResource: { attributes: ["apiFramework", "browserOptional"] }, ExecutableResource: { attributes: ["apiFramework", "type"] }, Tracking: { attributes: ["event"] }, Creatives: { subElements: ["Creative"] }, Creative: { subElements: ["UniversalAdId"] }, Linear: { subElements: ["MediaFiles", "Duration"] }, MediaFiles: { subElements: ["MediaFile"] }, MediaFile: { attributes: ["delivery", "type", "width", "height"] }, Mezzanine: { attributes: ["delivery", "type", "width", "height"] }, NonLinear: { oneOfinLineResources: ["StaticResource", "IFrameResource", "HTMLResource"], attributes: ["width", "height"] }, Companion: { oneOfinLineResources: ["StaticResource", "IFrameResource", "HTMLResource"], attributes: ["width", "height"] }, StaticResource: { attributes: ["creativeType"] }, Icons: { subElements: ["Icon"] }, Icon: { oneOfinLineResources: ["StaticResource", "IFrameResource", "HTMLResource"] } };
      function B(e2, t2) {
        if (P[e2.nodeName] && P[e2.nodeName].attributes) {
          var r2 = P[e2.nodeName].attributes.filter(function(t3) {
            return !e2.getAttribute(t3);
          });
          r2.length > 0 && j({ name: e2.nodeName, parentName: e2.parentNode.nodeName, attributes: r2 }, t2);
        }
      }
      function F(e2, t2, r2) {
        var i2 = P[e2.nodeName], n2 = !r2 && e2.nodeName !== "Wrapper";
        if (i2 && !n2) {
          if (i2.subElements) {
            var a2 = i2.subElements.filter(function(t3) {
              return !w.childByName(e2, t3);
            });
            a2.length > 0 && j({ name: e2.nodeName, parentName: e2.parentNode.nodeName, subElements: a2 }, t2);
          }
          if (r2 && i2.oneOfinLineResources)
            i2.oneOfinLineResources.some(function(t3) {
              return w.childByName(e2, t3);
            }) || j({ name: e2.nodeName, parentName: e2.parentNode.nodeName, oneOfResources: i2.oneOfinLineResources }, t2);
        }
      }
      function M(e2) {
        return e2.children && e2.children.length !== 0;
      }
      function j(e2, t2) {
        var r2 = e2.name, i2 = e2.parentName, n2 = e2.attributes, a2 = e2.subElements, o2 = e2.oneOfResources, s2 = "Element '".concat(r2, "'");
        t2("VAST-warning", { message: s2 += n2 ? " missing required attribute(s) '".concat(n2.join(", "), "' ") : a2 ? " missing required sub element(s) '".concat(a2.join(", "), "' ") : o2 ? " must provide one of the following '".concat(o2.join(", "), "' ") : " is empty", parentElement: i2, specVersion: 4.1 });
      }
      var W = { verifyRequiredValues: function e2(t2, r2, i2) {
        if (t2 && t2.nodeName)
          if (t2.nodeName === "InLine" && (i2 = true), B(t2, r2), M(t2)) {
            F(t2, r2, i2);
            for (var n2 = 0; n2 < t2.children.length; n2++)
              e2(t2.children[n2], r2, i2);
          } else
            w.parseNodeText(t2).length === 0 && j({ name: t2.nodeName, parentName: t2.parentNode.nodeName }, r2);
      }, hasSubElements: M, emitMissingValueWarning: j, verifyRequiredAttributes: B, verifyRequiredSubElements: F };
      function q(e2, t2) {
        var r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i2 = r2.allowMultipleAds, n2 = r2.followAdditionalWrappers, a2 = e2.childNodes;
        for (var o2 in a2) {
          var s2 = a2[o2];
          if (["Wrapper", "InLine"].indexOf(s2.nodeName) !== -1 && (s2.nodeName !== "Wrapper" || n2 !== false)) {
            if (w.copyNodeAttribute("id", e2, s2), w.copyNodeAttribute("sequence", e2, s2), w.copyNodeAttribute("adType", e2, s2), s2.nodeName === "Wrapper")
              return { ad: G(s2, t2), type: "WRAPPER" };
            if (s2.nodeName === "InLine")
              return { ad: H(s2, t2, { allowMultipleAds: i2 }), type: "INLINE" };
          }
        }
      }
      function H(e2, t2) {
        var r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i2 = r2.allowMultipleAds;
        return i2 === false && e2.getAttribute("sequence") ? null : _(e2, t2);
      }
      function _(e2, t2) {
        var r2 = [];
        t2 && W.verifyRequiredValues(e2, t2);
        var i2 = e2.childNodes, n2 = function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return { id: e3.id || null, sequence: e3.sequence || null, adType: e3.adType || null, adServingId: null, categories: [], expires: null, viewableImpression: [], system: null, title: null, description: null, advertiser: null, pricing: null, survey: null, errorURLTemplates: [], impressionURLTemplates: [], creatives: [], extensions: [], adVerifications: [], blockedAdCategories: [], followAdditionalWrappers: true, allowMultipleAds: false, fallbackOnNoAd: null };
        }(w.parseAttributes(e2));
        for (var a2 in i2) {
          var o2 = i2[a2];
          switch (o2.nodeName) {
            case "Error":
              n2.errorURLTemplates.push(w.parseNodeText(o2));
              break;
            case "Impression":
              n2.impressionURLTemplates.push({ id: o2.getAttribute("id") || null, url: w.parseNodeText(o2) });
              break;
            case "Creatives":
              n2.creatives = D(w.childrenByName(o2, "Creative"));
              break;
            case "Extensions":
              var s2 = w.childrenByName(o2, "Extension");
              n2.extensions = S(s2), n2.adVerifications.length || (r2 = Y(s2));
              break;
            case "AdVerifications":
              n2.adVerifications = z(w.childrenByName(o2, "Verification"));
              break;
            case "AdSystem":
              n2.system = { value: w.parseNodeText(o2), version: o2.getAttribute("version") || null };
              break;
            case "AdTitle":
              n2.title = w.parseNodeText(o2);
              break;
            case "AdServingId":
              n2.adServingId = w.parseNodeText(o2);
              break;
            case "Category":
              n2.categories.push({ authority: o2.getAttribute("authority") || null, value: w.parseNodeText(o2) });
              break;
            case "Expires":
              n2.expires = parseInt(w.parseNodeText(o2), 10);
              break;
            case "ViewableImpression":
              n2.viewableImpression.push(X(o2));
              break;
            case "Description":
              n2.description = w.parseNodeText(o2);
              break;
            case "Advertiser":
              n2.advertiser = { id: o2.getAttribute("id") || null, value: w.parseNodeText(o2) };
              break;
            case "Pricing":
              n2.pricing = { value: w.parseNodeText(o2), model: o2.getAttribute("model") || null, currency: o2.getAttribute("currency") || null };
              break;
            case "Survey":
              n2.survey = w.parseNodeText(o2);
              break;
            case "BlockedAdCategories":
              n2.blockedAdCategories.push({ authority: o2.getAttribute("authority") || null, value: w.parseNodeText(o2) });
          }
        }
        return r2.length && (n2.adVerifications = n2.adVerifications.concat(r2)), n2;
      }
      function G(e2, t2) {
        var r2 = _(e2, t2), i2 = e2.getAttribute("followAdditionalWrappers"), n2 = e2.getAttribute("allowMultipleAds"), a2 = e2.getAttribute("fallbackOnNoAd");
        r2.followAdditionalWrappers = !i2 || w.parseBoolean(i2), r2.allowMultipleAds = !!n2 && w.parseBoolean(n2), r2.fallbackOnNoAd = a2 ? w.parseBoolean(a2) : null;
        var o2 = w.childByName(e2, "VASTAdTagURI");
        if (o2 ? r2.nextWrapperURL = w.parseNodeText(o2) : (o2 = w.childByName(e2, "VASTAdTagURL")) && (r2.nextWrapperURL = w.parseNodeText(w.childByName(o2, "URL"))), r2.creatives.forEach(function(e3) {
          if (["linear", "nonlinear"].indexOf(e3.type) !== -1) {
            if (e3.trackingEvents) {
              r2.trackingEvents || (r2.trackingEvents = {}), r2.trackingEvents[e3.type] || (r2.trackingEvents[e3.type] = {});
              var t3 = function(t4) {
                var i4 = e3.trackingEvents[t4];
                Array.isArray(r2.trackingEvents[e3.type][t4]) || (r2.trackingEvents[e3.type][t4] = []), i4.forEach(function(i5) {
                  r2.trackingEvents[e3.type][t4].push(i5);
                });
              };
              for (var i3 in e3.trackingEvents)
                t3(i3);
            }
            e3.videoClickTrackingURLTemplates && (Array.isArray(r2.videoClickTrackingURLTemplates) || (r2.videoClickTrackingURLTemplates = []), e3.videoClickTrackingURLTemplates.forEach(function(e4) {
              r2.videoClickTrackingURLTemplates.push(e4);
            })), e3.videoClickThroughURLTemplate && (r2.videoClickThroughURLTemplate = e3.videoClickThroughURLTemplate), e3.videoCustomClickURLTemplates && (Array.isArray(r2.videoCustomClickURLTemplates) || (r2.videoCustomClickURLTemplates = []), e3.videoCustomClickURLTemplates.forEach(function(e4) {
              r2.videoCustomClickURLTemplates.push(e4);
            }));
          }
        }), r2.nextWrapperURL)
          return r2;
      }
      function z(e2) {
        var t2 = [];
        return e2.forEach(function(e3) {
          var r2 = { resource: null, vendor: null, browserOptional: false, apiFramework: null, type: null, parameters: null, trackingEvents: {} }, i2 = e3.childNodes;
          for (var n2 in w.assignAttributes(e3.attributes, r2), i2) {
            var a2 = i2[n2];
            switch (a2.nodeName) {
              case "JavaScriptResource":
              case "ExecutableResource":
                r2.resource = w.parseNodeText(a2), w.assignAttributes(a2.attributes, r2);
                break;
              case "VerificationParameters":
                r2.parameters = w.parseNodeText(a2);
            }
          }
          var o2 = w.childByName(e3, "TrackingEvents");
          o2 && w.childrenByName(o2, "Tracking").forEach(function(e4) {
            var t3 = e4.getAttribute("event"), i3 = w.parseNodeText(e4);
            t3 && i3 && (Array.isArray(r2.trackingEvents[t3]) || (r2.trackingEvents[t3] = []), r2.trackingEvents[t3].push(i3));
          }), t2.push(r2);
        }), t2;
      }
      function Y(e2) {
        var t2 = null, r2 = [];
        return e2.some(function(e3) {
          return t2 = w.childByName(e3, "AdVerifications");
        }), t2 && (r2 = z(w.childrenByName(t2, "Verification"))), r2;
      }
      function X(e2) {
        var t2 = {};
        t2.id = e2.getAttribute("id") || null;
        var r2 = e2.childNodes;
        for (var i2 in r2) {
          var n2 = r2[i2], a2 = n2.nodeName, o2 = w.parseNodeText(n2);
          if ((a2 === "Viewable" || a2 === "NotViewable" || a2 === "ViewUndetermined") && o2) {
            var s2 = a2.toLowerCase();
            Array.isArray(t2[s2]) || (t2[s2] = []), t2[s2].push(o2);
          }
        }
        return t2;
      }
      var K = function() {
        function e2() {
          n(this, e2), this._handlers = [];
        }
        return o(e2, [{ key: "on", value: function(e3, t2) {
          if (typeof t2 != "function")
            throw new TypeError("The handler argument must be of type Function. Received type ".concat(i(t2)));
          if (!e3)
            throw new TypeError("The event argument must be of type String. Received type ".concat(i(e3)));
          return this._handlers.push({ event: e3, handler: t2 }), this;
        } }, { key: "once", value: function(e3, t2) {
          return this.on(e3, function(e4, t3, r2) {
            var i2 = { fired: false, wrapFn: void 0 };
            function n2() {
              i2.fired || (e4.off(t3, i2.wrapFn), i2.fired = true, r2.bind(e4).apply(void 0, arguments));
            }
            return i2.wrapFn = n2, n2;
          }(this, e3, t2));
        } }, { key: "off", value: function(e3, t2) {
          return this._handlers = this._handlers.filter(function(r2) {
            return r2.event !== e3 || r2.handler !== t2;
          }), this;
        } }, { key: "emit", value: function(e3) {
          for (var t2 = arguments.length, r2 = new Array(t2 > 1 ? t2 - 1 : 0), i2 = 1; i2 < t2; i2++)
            r2[i2 - 1] = arguments[i2];
          var n2 = false;
          return this._handlers.forEach(function(t3) {
            t3.event === "*" && (n2 = true, t3.handler.apply(t3, [e3].concat(r2))), t3.event === e3 && (n2 = true, t3.handler.apply(t3, r2));
          }), n2;
        } }, { key: "removeAllListeners", value: function(e3) {
          return e3 ? (this._handlers = this._handlers.filter(function(t2) {
            return t2.event !== e3;
          }), this) : (this._handlers = [], this);
        } }, { key: "listenerCount", value: function(e3) {
          return this._handlers.filter(function(t2) {
            return t2.event === e3;
          }).length;
        } }, { key: "listeners", value: function(e3) {
          return this._handlers.reduce(function(t2, r2) {
            return r2.event === e3 && t2.push(r2.handler), t2;
          }, []);
        } }, { key: "eventNames", value: function() {
          return this._handlers.map(function(e3) {
            return e3.event;
          });
        } }]), e2;
      }();
      var Q = { get: function(e2, t2, r2) {
        r2(new Error("Please bundle the library for node to use the node urlHandler"));
      } }, Z = 12e4;
      function J() {
        try {
          var e2 = new window.XMLHttpRequest();
          return "withCredentials" in e2 ? e2 : null;
        } catch (e3) {
          return null;
        }
      }
      function $(e2, t2, r2) {
        var i2 = r2 ? 408 : e2.status, n2 = r2 ? "XHRURLHandler: Request timed out after ".concat(e2.timeout, " ms (").concat(i2, ")") : "XHRURLHandler: ".concat(e2.statusText, " (").concat(i2, ")");
        t2(new Error(n2), null, { statusCode: i2 });
      }
      var ee = { get: function(e2, t2, r2) {
        if (window.location.protocol === "https:" && e2.indexOf("http://") === 0)
          return r2(new Error("XHRURLHandler: Cannot go from HTTPS to HTTP."));
        try {
          var i2 = J();
          i2.open("GET", e2), i2.timeout = t2.timeout || Z, i2.withCredentials = t2.withCredentials || false, i2.overrideMimeType && i2.overrideMimeType("text/xml"), i2.onload = function() {
            return function(e3, t3) {
              e3.status === 200 ? t3(null, e3.responseXML, { byteLength: e3.response.length, statusCode: e3.status }) : $(e3, t3, false);
            }(i2, r2);
          }, i2.onerror = function() {
            return $(i2, r2, false);
          }, i2.onabort = function() {
            return $(i2, r2, false);
          }, i2.ontimeout = function() {
            return $(i2, r2, true);
          }, i2.send();
        } catch (e3) {
          r2(new Error("XHRURLHandler: Unexpected error"));
        }
      }, supported: function() {
        return !!J();
      } };
      var te = { get: function(e2, t2, r2) {
        return r2 || (typeof t2 == "function" && (r2 = t2), t2 = {}), typeof window == "undefined" || window === null ? Q.get(e2, t2, r2) : ee.supported() ? ee.get(e2, t2, r2) : r2(new Error("Current context is not supported by any of the default URLHandlers. Please provide a custom URLHandler"));
      } };
      var re = 0, ie = 0, ne = function(e2, t2) {
        !e2 || !t2 || e2 <= 0 || t2 <= 0 || (ie = (ie * re + 8 * e2 / t2) / ++re);
      }, ae = { ERRORCODE: 900, extensions: [] }, oe = function(e2) {
        l(r2, e2);
        var t2 = p(r2);
        function r2() {
          var e3;
          return n(this, r2), (e3 = t2.call(this)).remainingAds = [], e3.parentURLs = [], e3.errorURLTemplates = [], e3.rootErrorURLTemplates = [], e3.maxWrapperDepth = null, e3.URLTemplateFilters = [], e3.fetchingOptions = {}, e3.parsingOptions = {}, e3;
        }
        return o(r2, [{ key: "addURLTemplateFilter", value: function(e3) {
          typeof e3 == "function" && this.URLTemplateFilters.push(e3);
        } }, { key: "removeURLTemplateFilter", value: function() {
          this.URLTemplateFilters.pop();
        } }, { key: "countURLTemplateFilters", value: function() {
          return this.URLTemplateFilters.length;
        } }, { key: "clearURLTemplateFilters", value: function() {
          this.URLTemplateFilters = [];
        } }, { key: "trackVastError", value: function(e3, t3) {
          for (var r3 = arguments.length, i2 = new Array(r3 > 2 ? r3 - 2 : 0), n2 = 2; n2 < r3; n2++)
            i2[n2 - 2] = arguments[n2];
          this.emit("VAST-error", Object.assign.apply(Object, [{}, ae, t3].concat(i2))), N.track(e3, t3);
        } }, { key: "getErrorURLTemplates", value: function() {
          return this.rootErrorURLTemplates.concat(this.errorURLTemplates);
        } }, { key: "getEstimatedBitrate", value: function() {
          return ie;
        } }, { key: "fetchVAST", value: function(e3) {
          var t3 = this, r3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          return new Promise(function(a2, o2) {
            t3.URLTemplateFilters.forEach(function(t4) {
              e3 = t4(e3);
            }), t3.parentURLs.push(e3);
            var s2 = Date.now();
            t3.emit("VAST-resolving", { url: e3, previousUrl: i2, wrapperDepth: r3, maxWrapperDepth: t3.maxWrapperDepth, timeout: t3.fetchingOptions.timeout, wrapperAd: n2 }), t3.urlHandler.get(e3, t3.fetchingOptions, function(n3, l2) {
              var u2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, c2 = Math.round(Date.now() - s2), d2 = Object.assign({ url: e3, previousUrl: i2, wrapperDepth: r3, error: n3, duration: c2 }, u2);
              t3.emit("VAST-resolved", d2), ne(u2.byteLength, c2), n3 ? o2(n3) : a2(l2);
            });
          });
        } }, { key: "initParsingStatus", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.errorURLTemplates = [], this.fetchingOptions = { timeout: e3.timeout || Z, withCredentials: e3.withCredentials }, this.maxWrapperDepth = e3.wrapperLimit || 10, this.parentURLs = [], this.parsingOptions = { allowMultipleAds: e3.allowMultipleAds }, this.remainingAds = [], this.rootErrorURLTemplates = [], this.rootURL = "", this.urlHandler = e3.urlHandler || e3.urlhandler || te, this.vastVersion = null, ne(e3.byteLength, e3.requestDuration);
        } }, { key: "getRemainingAds", value: function(e3) {
          var t3 = this;
          if (this.remainingAds.length === 0)
            return Promise.reject(new Error("No more ads are available for the given VAST"));
          var r3 = e3 ? N.flatten(this.remainingAds) : this.remainingAds.shift();
          return this.errorURLTemplates = [], this.parentURLs = [], this.resolveAds(r3, { wrapperDepth: 0, url: this.rootURL }).then(function(e4) {
            return t3.buildVASTResponse(e4);
          });
        } }, { key: "getAndParseVAST", value: function(e3) {
          var t3 = this, r3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this.initParsingStatus(r3), this.URLTemplateFilters.forEach(function(t4) {
            e3 = t4(e3);
          }), this.rootURL = e3, this.fetchVAST(e3).then(function(i2) {
            return r3.previousUrl = e3, r3.isRootVAST = true, r3.url = e3, t3.parse(i2, r3).then(function(e4) {
              return t3.buildVASTResponse(e4);
            });
          });
        } }, { key: "parseVAST", value: function(e3) {
          var t3 = this, r3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this.initParsingStatus(r3), r3.isRootVAST = true, this.parse(e3, r3).then(function(e4) {
            return t3.buildVASTResponse(e4);
          });
        } }, { key: "buildVASTResponse", value: function(e3) {
          var t3, r3 = { ads: (t3 = { ads: e3, errorURLTemplates: this.getErrorURLTemplates(), version: this.vastVersion }).ads || [], errorURLTemplates: t3.errorURLTemplates || [], version: t3.version || null };
          return this.completeWrapperResolving(r3), r3;
        } }, { key: "parseVastXml", value: function(e3, t3) {
          var r3 = t3.isRootVAST, i2 = r3 !== void 0 && r3, n2 = t3.url, a2 = n2 === void 0 ? null : n2, o2 = t3.wrapperDepth, s2 = o2 === void 0 ? 0 : o2, l2 = t3.allowMultipleAds, u2 = t3.followAdditionalWrappers;
          if (!e3 || !e3.documentElement || e3.documentElement.nodeName !== "VAST")
            throw this.emit("VAST-ad-parsed", { type: "ERROR", url: a2, wrapperDepth: s2 }), new Error("Invalid VAST XMLDocument");
          var c2 = [], d2 = e3.documentElement.childNodes, p2 = e3.documentElement.getAttribute("version");
          for (var h2 in i2 && p2 && (this.vastVersion = p2), d2) {
            var v2 = d2[h2];
            if (v2.nodeName === "Error") {
              var f2 = w.parseNodeText(v2);
              i2 ? this.rootErrorURLTemplates.push(f2) : this.errorURLTemplates.push(f2);
            } else if (v2.nodeName === "Ad") {
              if (this.vastVersion && parseFloat(this.vastVersion) < 3)
                l2 = true;
              else if (l2 === false && c2.length > 1)
                break;
              var m2 = q(v2, this.emit.bind(this), { allowMultipleAds: l2, followAdditionalWrappers: u2 });
              m2.ad ? (c2.push(m2.ad), this.emit("VAST-ad-parsed", { type: m2.type, url: a2, wrapperDepth: s2, adIndex: c2.length - 1, vastVersion: p2 })) : this.trackVastError(this.getErrorURLTemplates(), { ERRORCODE: 101 });
            }
          }
          return c2;
        } }, { key: "parse", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r3 = t3.url, i2 = r3 === void 0 ? null : r3, n2 = t3.resolveAll, a2 = n2 === void 0 || n2, o2 = t3.wrapperSequence, s2 = o2 === void 0 ? null : o2, l2 = t3.previousUrl, u2 = l2 === void 0 ? null : l2, c2 = t3.wrapperDepth, d2 = c2 === void 0 ? 0 : c2, p2 = t3.isRootVAST, h2 = p2 !== void 0 && p2, v2 = t3.followAdditionalWrappers, f2 = t3.allowMultipleAds, m2 = [];
          this.vastVersion && parseFloat(this.vastVersion) < 3 && h2 && (f2 = true);
          try {
            m2 = this.parseVastXml(e3, { isRootVAST: h2, url: i2, wrapperDepth: d2, allowMultipleAds: f2, followAdditionalWrappers: v2 });
          } catch (e4) {
            return Promise.reject(e4);
          }
          return m2.length === 1 && s2 != null && (m2[0].sequence = s2), a2 === false && (this.remainingAds = w.splitVAST(m2), m2 = this.remainingAds.shift()), this.resolveAds(m2, { wrapperDepth: d2, previousUrl: u2, url: i2 });
        } }, { key: "resolveAds", value: function() {
          var e3 = this, t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], r3 = arguments.length > 1 ? arguments[1] : void 0, i2 = r3.wrapperDepth, n2 = r3.previousUrl, a2 = r3.url, o2 = [];
          return n2 = a2, t3.forEach(function(t4) {
            var r4 = e3.resolveWrappers(t4, i2, n2);
            o2.push(r4);
          }), Promise.all(o2).then(function(t4) {
            var r4 = N.flatten(t4);
            if (!r4 && e3.remainingAds.length > 0) {
              var o3 = e3.remainingAds.shift();
              return e3.resolveAds(o3, { wrapperDepth: i2, previousUrl: n2, url: a2 });
            }
            return r4;
          });
        } }, { key: "resolveWrappers", value: function(e3, t3, r3) {
          var i2 = this;
          return new Promise(function(n2) {
            var a2;
            if (t3++, !e3.nextWrapperURL)
              return delete e3.nextWrapperURL, n2(e3);
            if (t3 >= i2.maxWrapperDepth || i2.parentURLs.indexOf(e3.nextWrapperURL) !== -1)
              return e3.errorCode = 302, delete e3.nextWrapperURL, n2(e3);
            e3.nextWrapperURL = w.resolveVastAdTagURI(e3.nextWrapperURL, r3), i2.URLTemplateFilters.forEach(function(t4) {
              e3.nextWrapperURL = t4(e3.nextWrapperURL);
            });
            var o2 = (a2 = i2.parsingOptions.allowMultipleAds) !== null && a2 !== void 0 ? a2 : e3.allowMultipleAds, s2 = e3.sequence;
            i2.fetchVAST(e3.nextWrapperURL, t3, r3, e3).then(function(a3) {
              return i2.parse(a3, { url: e3.nextWrapperURL, previousUrl: r3, wrapperSequence: s2, wrapperDepth: t3, followAdditionalWrappers: e3.followAdditionalWrappers, allowMultipleAds: o2 }).then(function(t4) {
                if (delete e3.nextWrapperURL, t4.length === 0)
                  return e3.creatives = [], n2(e3);
                t4.forEach(function(t5) {
                  t5 && w.mergeWrapperAdData(t5, e3);
                }), n2(t4);
              });
            }).catch(function(t4) {
              e3.errorCode = 301, e3.errorMessage = t4.message, n2(e3);
            });
          });
        } }, { key: "completeWrapperResolving", value: function(e3) {
          if (e3.ads.length === 0)
            this.trackVastError(e3.errorURLTemplates, { ERRORCODE: 303 });
          else
            for (var t3 = e3.ads.length - 1; t3 >= 0; t3--) {
              var r3 = e3.ads[t3];
              (r3.errorCode || r3.creatives.length === 0) && (this.trackVastError(r3.errorURLTemplates.concat(e3.errorURLTemplates), { ERRORCODE: r3.errorCode || 303 }, { ERRORMESSAGE: r3.errorMessage || "" }, { extensions: r3.extensions }, { system: r3.system }), e3.ads.splice(t3, 1));
            }
        } }]), r2;
      }(K), se = null, le = { data: {}, length: 0, getItem: function(e2) {
        return this.data[e2];
      }, setItem: function(e2, t2) {
        this.data[e2] = t2, this.length = Object.keys(this.data).length;
      }, removeItem: function(e2) {
        delete this.data[e2], this.length = Object.keys(this.data).length;
      }, clear: function() {
        this.data = {}, this.length = 0;
      } }, ue = function() {
        function e2() {
          n(this, e2), this.storage = this.initStorage();
        }
        return o(e2, [{ key: "initStorage", value: function() {
          if (se)
            return se;
          try {
            se = typeof window != "undefined" && window !== null ? window.localStorage || window.sessionStorage : null;
          } catch (e3) {
            se = null;
          }
          return se && !this.isStorageDisabled(se) || (se = le).clear(), se;
        } }, { key: "isStorageDisabled", value: function(e3) {
          var t2 = "__VASTStorage__";
          try {
            if (e3.setItem(t2, t2), e3.getItem(t2) !== t2)
              return e3.removeItem(t2), true;
          } catch (e4) {
            return true;
          }
          return e3.removeItem(t2), false;
        } }, { key: "getItem", value: function(e3) {
          return this.storage.getItem(e3);
        } }, { key: "setItem", value: function(e3, t2) {
          return this.storage.setItem(e3, t2);
        } }, { key: "removeItem", value: function(e3) {
          return this.storage.removeItem(e3);
        } }, { key: "clear", value: function() {
          return this.storage.clear();
        } }]), e2;
      }(), ce = function() {
        function e2(t2, r2, i2) {
          n(this, e2), this.cappingFreeLunch = t2 || 0, this.cappingMinimumTimeInterval = r2 || 0, this.defaultOptions = { withCredentials: false, timeout: 0 }, this.vastParser = new oe(), this.storage = i2 || new ue(), this.lastSuccessfulAd === void 0 && (this.lastSuccessfulAd = 0), this.totalCalls === void 0 && (this.totalCalls = 0), this.totalCallsTimeout === void 0 && (this.totalCallsTimeout = 0);
        }
        return o(e2, [{ key: "getParser", value: function() {
          return this.vastParser;
        } }, { key: "lastSuccessfulAd", get: function() {
          return this.storage.getItem("vast-client-last-successful-ad");
        }, set: function(e3) {
          this.storage.setItem("vast-client-last-successful-ad", e3);
        } }, { key: "totalCalls", get: function() {
          return this.storage.getItem("vast-client-total-calls");
        }, set: function(e3) {
          this.storage.setItem("vast-client-total-calls", e3);
        } }, { key: "totalCallsTimeout", get: function() {
          return this.storage.getItem("vast-client-total-calls-timeout");
        }, set: function(e3) {
          this.storage.setItem("vast-client-total-calls-timeout", e3);
        } }, { key: "hasRemainingAds", value: function() {
          return this.vastParser.remainingAds.length > 0;
        } }, { key: "getNextAds", value: function(e3) {
          return this.vastParser.getRemainingAds(e3);
        } }, { key: "get", value: function(e3) {
          var t2 = this, r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i2 = Date.now();
          return (r2 = Object.assign({}, this.defaultOptions, r2)).hasOwnProperty("resolveAll") || (r2.resolveAll = false), this.totalCallsTimeout < i2 ? (this.totalCalls = 1, this.totalCallsTimeout = i2 + 36e5) : this.totalCalls++, new Promise(function(n2, a2) {
            if (t2.cappingFreeLunch >= t2.totalCalls)
              return a2(new Error("VAST call canceled \u2013 FreeLunch capping not reached yet ".concat(t2.totalCalls, "/").concat(t2.cappingFreeLunch)));
            var o2 = i2 - t2.lastSuccessfulAd;
            if (o2 < 0)
              t2.lastSuccessfulAd = 0;
            else if (o2 < t2.cappingMinimumTimeInterval)
              return a2(new Error("VAST call canceled \u2013 (".concat(t2.cappingMinimumTimeInterval, ")ms minimum interval reached")));
            t2.vastParser.getAndParseVAST(e3, r2).then(function(e4) {
              return n2(e4);
            }).catch(function(e4) {
              return a2(e4);
            });
          });
        } }]), e2;
      }(), de = function(e2) {
        l(a2, e2);
        var t2 = p(a2);
        function a2(e3, r2, i2) {
          var o2, s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          for (var l2 in n(this, a2), (o2 = t2.call(this)).ad = r2, o2.creative = i2, o2.variation = s2, o2.muted = false, o2.impressed = false, o2.skippable = false, o2.trackingEvents = {}, o2.lastPercentage = 0, o2._alreadyTriggeredQuartiles = {}, o2.emitAlwaysEvents = ["creativeView", "start", "firstQuartile", "midpoint", "thirdQuartile", "complete", "resume", "pause", "rewind", "skip", "closeLinear", "close"], o2.creative.trackingEvents) {
            var u2 = o2.creative.trackingEvents[l2];
            o2.trackingEvents[l2] = u2.slice(0);
          }
          return C(o2.creative) ? o2._initLinearTracking() : o2._initVariationTracking(), e3 && o2.on("start", function() {
            e3.lastSuccessfulAd = Date.now();
          }), o2;
        }
        return o(a2, [{ key: "_initLinearTracking", value: function() {
          this.linear = true, this.skipDelay = this.creative.skipDelay, this.setDuration(this.creative.duration), this.clickThroughURLTemplate = this.creative.videoClickThroughURLTemplate, this.clickTrackingURLTemplates = this.creative.videoClickTrackingURLTemplates;
        } }, { key: "_initVariationTracking", value: function() {
          if (this.linear = false, this.skipDelay = -1, this.variation) {
            for (var e3 in this.variation.trackingEvents) {
              var t3 = this.variation.trackingEvents[e3];
              this.trackingEvents[e3] ? this.trackingEvents[e3] = this.trackingEvents[e3].concat(t3.slice(0)) : this.trackingEvents[e3] = t3.slice(0);
            }
            this.variation.adType === "nonLinearAd" ? (this.clickThroughURLTemplate = this.variation.nonlinearClickThroughURLTemplate, this.clickTrackingURLTemplates = this.variation.nonlinearClickTrackingURLTemplates, this.setDuration(this.variation.minSuggestedDuration)) : function(e4) {
              return e4.adType === "companionAd";
            }(this.variation) && (this.clickThroughURLTemplate = this.variation.companionClickThroughURLTemplate, this.clickTrackingURLTemplates = this.variation.companionClickTrackingURLTemplates);
          }
        } }, { key: "setDuration", value: function(e3) {
          N.isValidTimeValue(e3) && (this.assetDuration = e3, this.quartiles = { firstQuartile: Math.round(25 * this.assetDuration) / 100, midpoint: Math.round(50 * this.assetDuration) / 100, thirdQuartile: Math.round(75 * this.assetDuration) / 100 });
        } }, { key: "setProgress", value: function(e3) {
          var t3 = this, r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (N.isValidTimeValue(e3) && i(r2) === "object") {
            var n2 = this.skipDelay || -1;
            if (n2 === -1 || this.skippable || (n2 > e3 ? this.emit("skip-countdown", n2 - e3) : (this.skippable = true, this.emit("skip-countdown", 0))), this.assetDuration > 0) {
              var a3 = Math.round(e3 / this.assetDuration * 100), o2 = [];
              if (e3 > 0) {
                o2.push("start");
                for (var s2 = this.lastPercentage; s2 < a3; s2++)
                  o2.push("progress-".concat(s2 + 1, "%"));
                for (var l2 in o2.push("progress-".concat(Math.round(e3))), this.quartiles)
                  this.isQuartileReached(l2, this.quartiles[l2], e3) && (o2.push(l2), this._alreadyTriggeredQuartiles[l2] = true);
                this.lastPercentage = a3;
              }
              o2.forEach(function(e4) {
                t3.track(e4, { macros: r2, once: true });
              }), e3 < this.progress && this.track("rewind", { macros: r2 });
            }
            this.progress = e3;
          }
        } }, { key: "isQuartileReached", value: function(e3, t3, r2) {
          var i2 = false;
          return t3 <= r2 && !this._alreadyTriggeredQuartiles[e3] && (i2 = true), i2;
        } }, { key: "setMuted", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          typeof e3 == "boolean" && i(t3) === "object" && (this.muted !== e3 && this.track(e3 ? "mute" : "unmute", { macros: t3 }), this.muted = e3);
        } }, { key: "setPaused", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          typeof e3 == "boolean" && i(t3) === "object" && (this.paused !== e3 && this.track(e3 ? "pause" : "resume", { macros: t3 }), this.paused = e3);
        } }, { key: "setFullscreen", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          typeof e3 == "boolean" && i(t3) === "object" && (this.fullscreen !== e3 && this.track(e3 ? "fullscreen" : "exitFullscreen", { macros: t3 }), this.fullscreen = e3);
        } }, { key: "setExpand", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          typeof e3 == "boolean" && i(t3) === "object" && (this.expanded !== e3 && (this.track(e3 ? "expand" : "collapse", { macros: t3 }), this.track(e3 ? "playerExpand" : "playerCollapse", { macros: t3 })), this.expanded = e3);
        } }, { key: "setSkipDelay", value: function(e3) {
          N.isValidTimeValue(e3) && (this.skipDelay = e3);
        } }, { key: "trackImpression", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && (this.impressed || (this.impressed = true, this.trackURLs(this.ad.impressionURLTemplates, e3), this.track("creativeView", { macros: e3 })));
        } }, { key: "error", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t3 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
          i(e3) === "object" && typeof t3 == "boolean" && this.trackURLs(this.ad.errorURLTemplates, e3, { isCustomCode: t3 });
        } }, { key: "errorWithCode", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
          typeof e3 == "string" && typeof t3 == "boolean" && (this.error({ ERRORCODE: e3 }, t3), console.log("The method errorWithCode is deprecated, please use vast tracker error method instead"));
        } }, { key: "complete", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("complete", { macros: e3 });
        } }, { key: "notUsed", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && (this.track("notUsed", { macros: e3 }), this.trackingEvents = []);
        } }, { key: "otherAdInteraction", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("otherAdInteraction", { macros: e3 });
        } }, { key: "acceptInvitation", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("acceptInvitation", { macros: e3 });
        } }, { key: "adExpand", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("adExpand", { macros: e3 });
        } }, { key: "adCollapse", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("adCollapse", { macros: e3 });
        } }, { key: "minimize", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("minimize", { macros: e3 });
        } }, { key: "verificationNotExecuted", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (typeof e3 == "string" && i(t3) === "object") {
            if (!this.ad || !this.ad.adVerifications || !this.ad.adVerifications.length)
              throw new Error("No adVerifications provided");
            if (!e3)
              throw new Error("No vendor provided, unable to find associated verificationNotExecuted");
            var r2 = this.ad.adVerifications.find(function(t4) {
              return t4.vendor === e3;
            });
            if (!r2)
              throw new Error("No associated verification element found for vendor: ".concat(e3));
            var n2 = r2.trackingEvents;
            if (n2 && n2.verificationNotExecuted) {
              var a3 = n2.verificationNotExecuted;
              this.trackURLs(a3, t3), this.emit("verificationNotExecuted", { trackingURLTemplates: a3 });
            }
          }
        } }, { key: "overlayViewDuration", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          typeof e3 == "string" && i(t3) === "object" && (t3.ADPLAYHEAD = e3, this.track("overlayViewDuration", { macros: t3 }));
        } }, { key: "close", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track(this.linear ? "closeLinear" : "close", { macros: e3 });
        } }, { key: "skip", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("skip", { macros: e3 });
        } }, { key: "load", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          i(e3) === "object" && this.track("loaded", { macros: e3 });
        } }, { key: "click", value: function() {
          var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if ((e3 === null || typeof e3 == "string") && i(t3) === "object") {
            this.clickTrackingURLTemplates && this.clickTrackingURLTemplates.length && this.trackURLs(this.clickTrackingURLTemplates, t3);
            var n2 = this.clickThroughURLTemplate || e3, a3 = r({}, t3);
            if (n2) {
              this.progress && (a3.ADPLAYHEAD = this.progressFormatted());
              var o2 = N.resolveURLTemplates([n2], a3)[0];
              this.emit("clickthrough", o2);
            }
          }
        } }, { key: "track", value: function(e3) {
          var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r2 = t3.macros, n2 = r2 === void 0 ? {} : r2, a3 = t3.once, o2 = a3 !== void 0 && a3;
          if (i(n2) === "object") {
            e3 === "closeLinear" && !this.trackingEvents[e3] && this.trackingEvents.close && (e3 = "close");
            var s2 = this.trackingEvents[e3], l2 = this.emitAlwaysEvents.indexOf(e3) > -1;
            s2 ? (this.emit(e3, { trackingURLTemplates: s2 }), this.trackURLs(s2, n2)) : l2 && this.emit(e3, null), o2 && (delete this.trackingEvents[e3], l2 && this.emitAlwaysEvents.splice(this.emitAlwaysEvents.indexOf(e3), 1));
          }
        } }, { key: "trackURLs", value: function(e3) {
          var t3, i2, n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o2 = r({}, n2);
          this.linear && (this.creative && this.creative.mediaFiles && this.creative.mediaFiles[0] && this.creative.mediaFiles[0].fileURL && (o2.ASSETURI = this.creative.mediaFiles[0].fileURL), this.progress && (o2.ADPLAYHEAD = this.progressFormatted())), (t3 = this.creative) !== null && t3 !== void 0 && (i2 = t3.universalAdIds) !== null && i2 !== void 0 && i2.length && (o2.UNIVERSALADID = this.creative.universalAdIds.map(function(e4) {
            return e4.idRegistry.concat(" ", e4.value);
          }).join(",")), this.ad && (this.ad.sequence && (o2.PODSEQUENCE = this.ad.sequence), this.ad.adType && (o2.ADTYPE = this.ad.adType), this.ad.adServingId && (o2.ADSERVINGID = this.ad.adServingId), this.ad.categories && this.ad.categories.length && (o2.ADCATEGORIES = this.ad.categories.map(function(e4) {
            return e4.value;
          }).join(",")), this.ad.blockedAdCategories && this.ad.blockedAdCategories.length && (o2.BLOCKEDADCATEGORIES = this.ad.blockedAdCategories)), N.track(e3, o2, a3);
        } }, { key: "convertToTimecode", value: function(e3) {
          if (!N.isValidTimeValue(e3))
            return "";
          var t3 = 1e3 * e3, r2 = Math.floor(t3 / 36e5), i2 = Math.floor(t3 / 6e4 % 60), n2 = Math.floor(t3 / 1e3 % 60), a3 = Math.floor(t3 % 1e3);
          return "".concat(N.addLeadingZeros(r2, 2), ":").concat(N.addLeadingZeros(i2, 2), ":").concat(N.addLeadingZeros(n2, 2), ".").concat(N.addLeadingZeros(a3, 3));
        } }, { key: "progressFormatted", value: function() {
          return this.convertToTimecode(this.progress);
        } }]), a2;
      }(K);
      e.VASTClient = ce, e.VASTParser = oe, e.VASTTracker = de, Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});

// node_modules/global/window.js
var require_window = __commonJS({
  "node_modules/global/window.js"(exports, module) {
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof window !== "undefined") {
      win = window;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    module.exports = win;
  }
});

// (disabled):node_modules/min-document/index.js
var require_min_document = __commonJS({
  "(disabled):node_modules/min-document/index.js"() {
  }
});

// node_modules/global/document.js
var require_document = __commonJS({
  "node_modules/global/document.js"(exports, module) {
    var topLevel = typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : {};
    var minDoc = require_min_document();
    var doccy;
    if (typeof document !== "undefined") {
      doccy = document;
    } else {
      doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
      if (!doccy) {
        doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
      }
    }
    module.exports = doccy;
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends() {
      return module.exports = _extends = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t)
            ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends.apply(null, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/keycode/index.js
var require_keycode = __commonJS({
  "node_modules/keycode/index.js"(exports, module) {
    function keyCode(searchInput) {
      if (searchInput && typeof searchInput === "object") {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
        if (hasKeyCode)
          searchInput = hasKeyCode;
      }
      if (typeof searchInput === "number")
        return names[searchInput];
      var search = String(searchInput);
      var foundNamedKey = codes[search.toLowerCase()];
      if (foundNamedKey)
        return foundNamedKey;
      var foundNamedKey = aliases[search.toLowerCase()];
      if (foundNamedKey)
        return foundNamedKey;
      if (search.length === 1)
        return search.charCodeAt(0);
      return void 0;
    }
    keyCode.isEventKey = function isEventKey(event, nameOrCode) {
      if (event && typeof event === "object") {
        var keyCode2 = event.which || event.keyCode || event.charCode;
        if (keyCode2 === null || keyCode2 === void 0) {
          return false;
        }
        if (typeof nameOrCode === "string") {
          var foundNamedKey = codes[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
          var foundNamedKey = aliases[nameOrCode.toLowerCase()];
          if (foundNamedKey) {
            return foundNamedKey === keyCode2;
          }
        } else if (typeof nameOrCode === "number") {
          return nameOrCode === keyCode2;
        }
        return false;
      }
    };
    exports = module.exports = keyCode;
    var codes = exports.code = exports.codes = {
      "backspace": 8,
      "tab": 9,
      "enter": 13,
      "shift": 16,
      "ctrl": 17,
      "alt": 18,
      "pause/break": 19,
      "caps lock": 20,
      "esc": 27,
      "space": 32,
      "page up": 33,
      "page down": 34,
      "end": 35,
      "home": 36,
      "left": 37,
      "up": 38,
      "right": 39,
      "down": 40,
      "insert": 45,
      "delete": 46,
      "command": 91,
      "left command": 91,
      "right command": 93,
      "numpad *": 106,
      "numpad +": 107,
      "numpad -": 109,
      "numpad .": 110,
      "numpad /": 111,
      "num lock": 144,
      "scroll lock": 145,
      "my computer": 182,
      "my calculator": 183,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    var aliases = exports.aliases = {
      "windows": 91,
      "\u21E7": 16,
      "\u2325": 18,
      "\u2303": 17,
      "\u2318": 91,
      "ctl": 17,
      "control": 17,
      "option": 18,
      "pause": 19,
      "break": 19,
      "caps": 20,
      "return": 13,
      "escape": 27,
      "spc": 32,
      "spacebar": 32,
      "pgup": 33,
      "pgdn": 34,
      "ins": 45,
      "del": 46,
      "cmd": 91
    };
    for (i = 97; i < 123; i++)
      codes[String.fromCharCode(i)] = i - 32;
    for (i = 48; i < 58; i++)
      codes[i - 48] = i;
    var i;
    for (i = 1; i < 13; i++)
      codes["f" + i] = i + 111;
    for (i = 0; i < 10; i++)
      codes["numpad " + i] = i + 96;
    var names = exports.names = exports.title = {};
    for (i in codes)
      names[codes[i]] = i;
    for (alias in aliases) {
      codes[alias] = aliases[alias];
    }
    var alias;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(e) {
      if (e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(t, e) {
      return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/inheritsLoose.js
var require_inheritsLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/inheritsLoose.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inheritsLoose2(t, o) {
      t.prototype = Object.create(o.prototype), t.prototype.constructor = t, setPrototypeOf(t, o);
    }
    module.exports = _inheritsLoose2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/safe-json-parse/tuple.js
var require_tuple = __commonJS({
  "node_modules/safe-json-parse/tuple.js"(exports, module) {
    module.exports = SafeParseTuple;
    function SafeParseTuple(obj2, reviver) {
      var json;
      var error = null;
      try {
        json = JSON.parse(obj2, reviver);
      } catch (err) {
        error = err;
      }
      return [error, json];
    }
  }
});

// node_modules/is-function/index.js
var require_is_function = __commonJS({
  "node_modules/is-function/index.js"(exports, module) {
    module.exports = isFunction;
    var toString = Object.prototype.toString;
    function isFunction(fn) {
      if (!fn) {
        return false;
      }
      var string = toString.call(fn);
      return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
    }
  }
});

// node_modules/@videojs/xhr/lib/http-handler.js
var require_http_handler = __commonJS({
  "node_modules/@videojs/xhr/lib/http-handler.js"(exports, module) {
    "use strict";
    var window3 = require_window();
    var httpResponseHandler = function httpResponseHandler2(callback, decodeResponseBody) {
      if (decodeResponseBody === void 0) {
        decodeResponseBody = false;
      }
      return function(err, response, responseBody) {
        if (err) {
          callback(err);
          return;
        }
        if (response.statusCode >= 400 && response.statusCode <= 599) {
          var cause = responseBody;
          if (decodeResponseBody) {
            if (window3.TextDecoder) {
              var charset = getCharset(response.headers && response.headers["content-type"]);
              try {
                cause = new TextDecoder(charset).decode(responseBody);
              } catch (e) {
              }
            } else {
              cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
            }
          }
          callback({
            cause
          });
          return;
        }
        callback(null, responseBody);
      };
    };
    function getCharset(contentTypeHeader) {
      if (contentTypeHeader === void 0) {
        contentTypeHeader = "";
      }
      return contentTypeHeader.toLowerCase().split(";").reduce(function(charset, contentType) {
        var _contentType$split = contentType.split("="), type = _contentType$split[0], value = _contentType$split[1];
        if (type.trim() === "charset") {
          return value.trim();
        }
        return charset;
      }, "utf-8");
    }
    module.exports = httpResponseHandler;
  }
});

// node_modules/@videojs/xhr/lib/index.js
var require_lib = __commonJS({
  "node_modules/@videojs/xhr/lib/index.js"(exports, module) {
    "use strict";
    var window3 = require_window();
    var _extends = require_extends();
    var isFunction = require_is_function();
    createXHR.httpHandler = require_http_handler();
    var parseHeaders = function parseHeaders2(headers) {
      var result = {};
      if (!headers) {
        return result;
      }
      headers.trim().split("\n").forEach(function(row) {
        var index = row.indexOf(":");
        var key = row.slice(0, index).trim().toLowerCase();
        var value = row.slice(index + 1).trim();
        if (typeof result[key] === "undefined") {
          result[key] = value;
        } else if (Array.isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [result[key], value];
        }
      });
      return result;
    };
    module.exports = createXHR;
    module.exports.default = createXHR;
    createXHR.XMLHttpRequest = window3.XMLHttpRequest || noop;
    createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window3.XDomainRequest;
    forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
      createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback);
        options.method = method.toUpperCase();
        return _createXHR(options);
      };
    });
    function forEachArray(array, iterator) {
      for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
      }
    }
    function isEmpty(obj2) {
      for (var i in obj2) {
        if (obj2.hasOwnProperty(i))
          return false;
      }
      return true;
    }
    function initParams(uri, options, callback) {
      var params = uri;
      if (isFunction(options)) {
        callback = options;
        if (typeof uri === "string") {
          params = {
            uri
          };
        }
      } else {
        params = _extends({}, options, {
          uri
        });
      }
      params.callback = callback;
      return params;
    }
    function createXHR(uri, options, callback) {
      options = initParams(uri, options, callback);
      return _createXHR(options);
    }
    function _createXHR(options) {
      if (typeof options.callback === "undefined") {
        throw new Error("callback argument missing");
      }
      var called = false;
      var callback = function cbOnce(err, response, body2) {
        if (!called) {
          called = true;
          options.callback(err, response, body2);
        }
      };
      function readystatechange() {
        if (xhr.readyState === 4) {
          setTimeout(loadFunc, 0);
        }
      }
      function getBody() {
        var body2 = void 0;
        if (xhr.response) {
          body2 = xhr.response;
        } else {
          body2 = xhr.responseText || getXml(xhr);
        }
        if (isJson) {
          try {
            body2 = JSON.parse(body2);
          } catch (e) {
          }
        }
        return body2;
      }
      function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if (!(evt instanceof Error)) {
          evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
        }
        evt.statusCode = 0;
        return callback(evt, failureResponse);
      }
      function loadFunc() {
        if (aborted)
          return;
        var status;
        clearTimeout(timeoutTimer);
        if (options.useXDR && xhr.status === void 0) {
          status = 200;
        } else {
          status = xhr.status === 1223 ? 204 : xhr.status;
        }
        var response = failureResponse;
        var err = null;
        if (status !== 0) {
          response = {
            body: getBody(),
            statusCode: status,
            method,
            headers: {},
            url: uri,
            rawRequest: xhr
          };
          if (xhr.getAllResponseHeaders) {
            response.headers = parseHeaders(xhr.getAllResponseHeaders());
          }
        } else {
          err = new Error("Internal XMLHttpRequest Error");
        }
        return callback(err, response, response.body);
      }
      var xhr = options.xhr || null;
      if (!xhr) {
        if (options.cors || options.useXDR) {
          xhr = new createXHR.XDomainRequest();
        } else {
          xhr = new createXHR.XMLHttpRequest();
        }
      }
      var key;
      var aborted;
      var uri = xhr.url = options.uri || options.url;
      var method = xhr.method = options.method || "GET";
      var body = options.body || options.data;
      var headers = xhr.headers = options.headers || {};
      var sync = !!options.sync;
      var isJson = false;
      var timeoutTimer;
      var failureResponse = {
        body: void 0,
        headers: {},
        statusCode: 0,
        method,
        url: uri,
        rawRequest: xhr
      };
      if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
        if (method !== "GET" && method !== "HEAD") {
          headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
          body = JSON.stringify(options.json === true ? body : options.json);
        }
      }
      xhr.onreadystatechange = readystatechange;
      xhr.onload = loadFunc;
      xhr.onerror = errorFunc;
      xhr.onprogress = function() {
      };
      xhr.onabort = function() {
        aborted = true;
      };
      xhr.ontimeout = errorFunc;
      xhr.open(method, uri, !sync, options.username, options.password);
      if (!sync) {
        xhr.withCredentials = !!options.withCredentials;
      }
      if (!sync && options.timeout > 0) {
        timeoutTimer = setTimeout(function() {
          if (aborted)
            return;
          aborted = true;
          xhr.abort("timeout");
          var e = new Error("XMLHttpRequest timeout");
          e.code = "ETIMEDOUT";
          errorFunc(e);
        }, options.timeout);
      }
      if (xhr.setRequestHeader) {
        for (key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
      }
      if ("responseType" in options) {
        xhr.responseType = options.responseType;
      }
      if ("beforeSend" in options && typeof options.beforeSend === "function") {
        options.beforeSend(xhr);
      }
      xhr.send(body || null);
      return xhr;
    }
    function getXml(xhr) {
      try {
        if (xhr.responseType === "document") {
          return xhr.responseXML;
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
          return xhr.responseXML;
        }
      } catch (e) {
      }
      return null;
    }
    function noop() {
    }
  }
});

// node_modules/videojs-vtt.js/lib/vtt.js
var require_vtt = __commonJS({
  "node_modules/videojs-vtt.js/lib/vtt.js"(exports, module) {
    var document3 = require_document();
    var _objCreate = Object.create || function() {
      function F() {
      }
      return function(o) {
        if (arguments.length !== 1) {
          throw new Error("Object.create shim only accepts one parameter.");
        }
        F.prototype = o;
        return new F();
      };
    }();
    function ParsingError(errorData, message) {
      this.name = "ParsingError";
      this.code = errorData.code;
      this.message = message || errorData.message;
    }
    ParsingError.prototype = _objCreate(Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    ParsingError.Errors = {
      BadSignature: {
        code: 0,
        message: "Malformed WebVTT signature."
      },
      BadTimeStamp: {
        code: 1,
        message: "Malformed time stamp."
      }
    };
    function parseTimeStamp(input) {
      function computeSeconds(h, m2, s, f) {
        return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + (f | 0) / 1e3;
      }
      var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
      if (!m) {
        return null;
      }
      if (m[3]) {
        return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
      } else if (m[1] > 59) {
        return computeSeconds(m[1], m[2], 0, m[4]);
      } else {
        return computeSeconds(0, m[1], m[2], m[4]);
      }
    }
    function Settings() {
      this.values = _objCreate(null);
    }
    Settings.prototype = {
      set: function(k, v) {
        if (!this.get(k) && v !== "") {
          this.values[k] = v;
        }
      },
      get: function(k, dflt, defaultKey) {
        if (defaultKey) {
          return this.has(k) ? this.values[k] : dflt[defaultKey];
        }
        return this.has(k) ? this.values[k] : dflt;
      },
      has: function(k) {
        return k in this.values;
      },
      alt: function(k, v, a) {
        for (var n = 0; n < a.length; ++n) {
          if (v === a[n]) {
            this.set(k, v);
            break;
          }
        }
      },
      integer: function(k, v) {
        if (/^-?\d+$/.test(v)) {
          this.set(k, parseInt(v, 10));
        }
      },
      percent: function(k, v) {
        var m;
        if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
          v = parseFloat(v);
          if (v >= 0 && v <= 100) {
            this.set(k, v);
            return true;
          }
        }
        return false;
      }
    };
    function parseOptions(input, callback, keyValueDelim, groupDelim) {
      var groups = groupDelim ? input.split(groupDelim) : [input];
      for (var i in groups) {
        if (typeof groups[i] !== "string") {
          continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
          continue;
        }
        var k = kv[0].trim();
        var v = kv[1].trim();
        callback(k, v);
      }
    }
    function parseCue(input, cue, regionList) {
      var oInput = input;
      function consumeTimeStamp() {
        var ts = parseTimeStamp(input);
        if (ts === null) {
          throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed timestamp: " + oInput);
        }
        input = input.replace(/^[^\sa-zA-Z-]+/, "");
        return ts;
      }
      function consumeCueSettings(input2, cue2) {
        var settings2 = new Settings();
        parseOptions(input2, function(k, v) {
          switch (k) {
            case "region":
              for (var i = regionList.length - 1; i >= 0; i--) {
                if (regionList[i].id === v) {
                  settings2.set(k, regionList[i].region);
                  break;
                }
              }
              break;
            case "vertical":
              settings2.alt(k, v, ["rl", "lr"]);
              break;
            case "line":
              var vals = v.split(","), vals0 = vals[0];
              settings2.integer(k, vals0);
              settings2.percent(k, vals0) ? settings2.set("snapToLines", false) : null;
              settings2.alt(k, vals0, ["auto"]);
              if (vals.length === 2) {
                settings2.alt("lineAlign", vals[1], ["start", "center", "end"]);
              }
              break;
            case "position":
              vals = v.split(",");
              settings2.percent(k, vals[0]);
              if (vals.length === 2) {
                settings2.alt("positionAlign", vals[1], ["start", "center", "end"]);
              }
              break;
            case "size":
              settings2.percent(k, v);
              break;
            case "align":
              settings2.alt(k, v, ["start", "center", "end", "left", "right"]);
              break;
          }
        }, /:/, /\s/);
        cue2.region = settings2.get("region", null);
        cue2.vertical = settings2.get("vertical", "");
        try {
          cue2.line = settings2.get("line", "auto");
        } catch (e) {
        }
        cue2.lineAlign = settings2.get("lineAlign", "start");
        cue2.snapToLines = settings2.get("snapToLines", true);
        cue2.size = settings2.get("size", 100);
        try {
          cue2.align = settings2.get("align", "center");
        } catch (e) {
          cue2.align = settings2.get("align", "middle");
        }
        try {
          cue2.position = settings2.get("position", "auto");
        } catch (e) {
          cue2.position = settings2.get("position", {
            start: 0,
            left: 0,
            center: 50,
            middle: 50,
            end: 100,
            right: 100
          }, cue2.align);
        }
        cue2.positionAlign = settings2.get("positionAlign", {
          start: "start",
          left: "start",
          center: "center",
          middle: "center",
          end: "end",
          right: "end"
        }, cue2.align);
      }
      function skipWhitespace() {
        input = input.replace(/^\s+/, "");
      }
      skipWhitespace();
      cue.startTime = consumeTimeStamp();
      skipWhitespace();
      if (input.substr(0, 3) !== "-->") {
        throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
      }
      input = input.substr(3);
      skipWhitespace();
      cue.endTime = consumeTimeStamp();
      skipWhitespace();
      consumeCueSettings(input, cue);
    }
    var TEXTAREA_ELEMENT = document3.createElement && document3.createElement("textarea");
    var TAG_NAME = {
      c: "span",
      i: "i",
      b: "b",
      u: "u",
      ruby: "ruby",
      rt: "rt",
      v: "span",
      lang: "span"
    };
    var DEFAULT_COLOR_CLASS = {
      white: "rgba(255,255,255,1)",
      lime: "rgba(0,255,0,1)",
      cyan: "rgba(0,255,255,1)",
      red: "rgba(255,0,0,1)",
      yellow: "rgba(255,255,0,1)",
      magenta: "rgba(255,0,255,1)",
      blue: "rgba(0,0,255,1)",
      black: "rgba(0,0,0,1)"
    };
    var TAG_ANNOTATION = {
      v: "title",
      lang: "lang"
    };
    var NEEDS_PARENT = {
      rt: "ruby"
    };
    function parseContent(window3, input) {
      function nextToken() {
        if (!input) {
          return null;
        }
        function consume(result) {
          input = input.substr(result.length);
          return result;
        }
        var m2 = input.match(/^([^<]*)(<[^>]*>?)?/);
        return consume(m2[1] ? m2[1] : m2[2]);
      }
      function unescape2(s) {
        TEXTAREA_ELEMENT.innerHTML = s;
        s = TEXTAREA_ELEMENT.textContent;
        TEXTAREA_ELEMENT.textContent = "";
        return s;
      }
      function shouldAdd(current2, element) {
        return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current2.localName;
      }
      function createElement(type, annotation) {
        var tagName = TAG_NAME[type];
        if (!tagName) {
          return null;
        }
        var element = window3.document.createElement(tagName);
        var name = TAG_ANNOTATION[type];
        if (name && annotation) {
          element[name] = annotation.trim();
        }
        return element;
      }
      var rootDiv = window3.document.createElement("div"), current = rootDiv, t, tagStack = [];
      while ((t = nextToken()) !== null) {
        if (t[0] === "<") {
          if (t[1] === "/") {
            if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
              tagStack.pop();
              current = current.parentNode;
            }
            continue;
          }
          var ts = parseTimeStamp(t.substr(1, t.length - 2));
          var node;
          if (ts) {
            node = window3.document.createProcessingInstruction("timestamp", ts);
            current.appendChild(node);
            continue;
          }
          var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
          if (!m) {
            continue;
          }
          node = createElement(m[1], m[3]);
          if (!node) {
            continue;
          }
          if (!shouldAdd(current, node)) {
            continue;
          }
          if (m[2]) {
            var classes = m[2].split(".");
            classes.forEach(function(cl) {
              var bgColor = /^bg_/.test(cl);
              var colorName = bgColor ? cl.slice(3) : cl;
              if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
                var propName = bgColor ? "background-color" : "color";
                var propValue = DEFAULT_COLOR_CLASS[colorName];
                node.style[propName] = propValue;
              }
            });
            node.className = classes.join(" ");
          }
          tagStack.push(m[1]);
          current.appendChild(node);
          current = node;
          continue;
        }
        current.appendChild(window3.document.createTextNode(unescape2(t)));
      }
      return rootDiv;
    }
    var strongRTLRanges = [
      [1470, 1470],
      [1472, 1472],
      [1475, 1475],
      [1478, 1478],
      [1488, 1514],
      [1520, 1524],
      [1544, 1544],
      [1547, 1547],
      [1549, 1549],
      [1563, 1563],
      [1566, 1610],
      [1645, 1647],
      [1649, 1749],
      [1765, 1766],
      [1774, 1775],
      [1786, 1805],
      [1807, 1808],
      [1810, 1839],
      [1869, 1957],
      [1969, 1969],
      [1984, 2026],
      [2036, 2037],
      [2042, 2042],
      [2048, 2069],
      [2074, 2074],
      [2084, 2084],
      [2088, 2088],
      [2096, 2110],
      [2112, 2136],
      [2142, 2142],
      [2208, 2208],
      [2210, 2220],
      [8207, 8207],
      [64285, 64285],
      [64287, 64296],
      [64298, 64310],
      [64312, 64316],
      [64318, 64318],
      [64320, 64321],
      [64323, 64324],
      [64326, 64449],
      [64467, 64829],
      [64848, 64911],
      [64914, 64967],
      [65008, 65020],
      [65136, 65140],
      [65142, 65276],
      [67584, 67589],
      [67592, 67592],
      [67594, 67637],
      [67639, 67640],
      [67644, 67644],
      [67647, 67669],
      [67671, 67679],
      [67840, 67867],
      [67872, 67897],
      [67903, 67903],
      [67968, 68023],
      [68030, 68031],
      [68096, 68096],
      [68112, 68115],
      [68117, 68119],
      [68121, 68147],
      [68160, 68167],
      [68176, 68184],
      [68192, 68223],
      [68352, 68405],
      [68416, 68437],
      [68440, 68466],
      [68472, 68479],
      [68608, 68680],
      [126464, 126467],
      [126469, 126495],
      [126497, 126498],
      [126500, 126500],
      [126503, 126503],
      [126505, 126514],
      [126516, 126519],
      [126521, 126521],
      [126523, 126523],
      [126530, 126530],
      [126535, 126535],
      [126537, 126537],
      [126539, 126539],
      [126541, 126543],
      [126545, 126546],
      [126548, 126548],
      [126551, 126551],
      [126553, 126553],
      [126555, 126555],
      [126557, 126557],
      [126559, 126559],
      [126561, 126562],
      [126564, 126564],
      [126567, 126570],
      [126572, 126578],
      [126580, 126583],
      [126585, 126588],
      [126590, 126590],
      [126592, 126601],
      [126603, 126619],
      [126625, 126627],
      [126629, 126633],
      [126635, 126651],
      [1114109, 1114109]
    ];
    function isStrongRTLChar(charCode) {
      for (var i = 0; i < strongRTLRanges.length; i++) {
        var currentRange = strongRTLRanges[i];
        if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
          return true;
        }
      }
      return false;
    }
    function determineBidi(cueDiv) {
      var nodeStack = [], text = "", charCode;
      if (!cueDiv || !cueDiv.childNodes) {
        return "ltr";
      }
      function pushNodes(nodeStack2, node) {
        for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
          nodeStack2.push(node.childNodes[i2]);
        }
      }
      function nextTextNode(nodeStack2) {
        if (!nodeStack2 || !nodeStack2.length) {
          return null;
        }
        var node = nodeStack2.pop(), text2 = node.textContent || node.innerText;
        if (text2) {
          var m = text2.match(/^.*(\n|\r)/);
          if (m) {
            nodeStack2.length = 0;
            return m[0];
          }
          return text2;
        }
        if (node.tagName === "ruby") {
          return nextTextNode(nodeStack2);
        }
        if (node.childNodes) {
          pushNodes(nodeStack2, node);
          return nextTextNode(nodeStack2);
        }
      }
      pushNodes(nodeStack, cueDiv);
      while (text = nextTextNode(nodeStack)) {
        for (var i = 0; i < text.length; i++) {
          charCode = text.charCodeAt(i);
          if (isStrongRTLChar(charCode)) {
            return "rtl";
          }
        }
      }
      return "ltr";
    }
    function computeLinePos(cue) {
      if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
        return cue.line;
      }
      if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
        return -1;
      }
      var track = cue.track, trackList = track.textTrackList, count = 0;
      for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
        if (trackList[i].mode === "showing") {
          count++;
        }
      }
      return ++count * -1;
    }
    function StyleBox() {
    }
    StyleBox.prototype.applyStyles = function(styles, div) {
      div = div || this.div;
      for (var prop in styles) {
        if (styles.hasOwnProperty(prop)) {
          div.style[prop] = styles[prop];
        }
      }
    };
    StyleBox.prototype.formatStyle = function(val, unit) {
      return val === 0 ? 0 : val + unit;
    };
    function CueStyleBox(window3, cue, styleOptions) {
      StyleBox.call(this);
      this.cue = cue;
      this.cueDiv = parseContent(window3, cue.text);
      var styles = {
        color: "rgba(255, 255, 255, 1)",
        backgroundColor: "rgba(0, 0, 0, 0.8)",
        position: "relative",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        display: "inline",
        writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
        unicodeBidi: "plaintext"
      };
      this.applyStyles(styles, this.cueDiv);
      this.div = window3.document.createElement("div");
      styles = {
        direction: determineBidi(this.cueDiv),
        writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
        unicodeBidi: "plaintext",
        textAlign: cue.align === "middle" ? "center" : cue.align,
        font: styleOptions.font,
        whiteSpace: "pre-line",
        position: "absolute"
      };
      this.applyStyles(styles);
      this.div.appendChild(this.cueDiv);
      var textPos = 0;
      switch (cue.positionAlign) {
        case "start":
        case "line-left":
          textPos = cue.position;
          break;
        case "center":
          textPos = cue.position - cue.size / 2;
          break;
        case "end":
        case "line-right":
          textPos = cue.position - cue.size;
          break;
      }
      if (cue.vertical === "") {
        this.applyStyles({
          left: this.formatStyle(textPos, "%"),
          width: this.formatStyle(cue.size, "%")
        });
      } else {
        this.applyStyles({
          top: this.formatStyle(textPos, "%"),
          height: this.formatStyle(cue.size, "%")
        });
      }
      this.move = function(box) {
        this.applyStyles({
          top: this.formatStyle(box.top, "px"),
          bottom: this.formatStyle(box.bottom, "px"),
          left: this.formatStyle(box.left, "px"),
          right: this.formatStyle(box.right, "px"),
          height: this.formatStyle(box.height, "px"),
          width: this.formatStyle(box.width, "px")
        });
      };
    }
    CueStyleBox.prototype = _objCreate(StyleBox.prototype);
    CueStyleBox.prototype.constructor = CueStyleBox;
    function BoxPosition(obj2) {
      var lh, height, width, top;
      if (obj2.div) {
        height = obj2.div.offsetHeight;
        width = obj2.div.offsetWidth;
        top = obj2.div.offsetTop;
        var rects = (rects = obj2.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
        obj2 = obj2.div.getBoundingClientRect();
        lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj2.height / rects.length) : 0;
      }
      this.left = obj2.left;
      this.right = obj2.right;
      this.top = obj2.top || top;
      this.height = obj2.height || height;
      this.bottom = obj2.bottom || top + (obj2.height || height);
      this.width = obj2.width || width;
      this.lineHeight = lh !== void 0 ? lh : obj2.lineHeight;
    }
    BoxPosition.prototype.move = function(axis, toMove) {
      toMove = toMove !== void 0 ? toMove : this.lineHeight;
      switch (axis) {
        case "+x":
          this.left += toMove;
          this.right += toMove;
          break;
        case "-x":
          this.left -= toMove;
          this.right -= toMove;
          break;
        case "+y":
          this.top += toMove;
          this.bottom += toMove;
          break;
        case "-y":
          this.top -= toMove;
          this.bottom -= toMove;
          break;
      }
    };
    BoxPosition.prototype.overlaps = function(b2) {
      return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
    };
    BoxPosition.prototype.overlapsAny = function(boxes) {
      for (var i = 0; i < boxes.length; i++) {
        if (this.overlaps(boxes[i])) {
          return true;
        }
      }
      return false;
    };
    BoxPosition.prototype.within = function(container) {
      return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
    };
    BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
      switch (axis) {
        case "+x":
          return this.left < container.left;
        case "-x":
          return this.right > container.right;
        case "+y":
          return this.top < container.top;
        case "-y":
          return this.bottom > container.bottom;
      }
    };
    BoxPosition.prototype.intersectPercentage = function(b2) {
      var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y;
      return intersectArea / (this.height * this.width);
    };
    BoxPosition.prototype.toCSSCompatValues = function(reference) {
      return {
        top: this.top - reference.top,
        bottom: reference.bottom - this.bottom,
        left: this.left - reference.left,
        right: reference.right - this.right,
        height: this.height,
        width: this.width
      };
    };
    BoxPosition.getSimpleBoxPosition = function(obj2) {
      var height = obj2.div ? obj2.div.offsetHeight : obj2.tagName ? obj2.offsetHeight : 0;
      var width = obj2.div ? obj2.div.offsetWidth : obj2.tagName ? obj2.offsetWidth : 0;
      var top = obj2.div ? obj2.div.offsetTop : obj2.tagName ? obj2.offsetTop : 0;
      obj2 = obj2.div ? obj2.div.getBoundingClientRect() : obj2.tagName ? obj2.getBoundingClientRect() : obj2;
      var ret = {
        left: obj2.left,
        right: obj2.right,
        top: obj2.top || top,
        height: obj2.height || height,
        bottom: obj2.bottom || top + (obj2.height || height),
        width: obj2.width || width
      };
      return ret;
    };
    function moveBoxToLinePosition(window3, styleBox, containerBox, boxPositions) {
      function findBestPosition(b, axis2) {
        var bestPosition2, specifiedPosition = new BoxPosition(b), percentage = 1;
        for (var i = 0; i < axis2.length; i++) {
          while (b.overlapsOppositeAxis(containerBox, axis2[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {
            b.move(axis2[i]);
          }
          if (b.within(containerBox)) {
            return b;
          }
          var p = b.intersectPercentage(containerBox);
          if (percentage > p) {
            bestPosition2 = new BoxPosition(b);
            percentage = p;
          }
          b = new BoxPosition(specifiedPosition);
        }
        return bestPosition2 || specifiedPosition;
      }
      var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
      if (cue.snapToLines) {
        var size;
        switch (cue.vertical) {
          case "":
            axis = ["+y", "-y"];
            size = "height";
            break;
          case "rl":
            axis = ["+x", "-x"];
            size = "width";
            break;
          case "lr":
            axis = ["-x", "+x"];
            size = "width";
            break;
        }
        var step = boxPosition.lineHeight, position = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
        if (Math.abs(position) > maxPosition) {
          position = position < 0 ? -1 : 1;
          position *= Math.ceil(maxPosition / step) * step;
        }
        if (linePos < 0) {
          position += cue.vertical === "" ? containerBox.height : containerBox.width;
          axis = axis.reverse();
        }
        boxPosition.move(initialAxis, position);
      } else {
        var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
        switch (cue.lineAlign) {
          case "center":
            linePos -= calculatedPercentage / 2;
            break;
          case "end":
            linePos -= calculatedPercentage;
            break;
        }
        switch (cue.vertical) {
          case "":
            styleBox.applyStyles({
              top: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "rl":
            styleBox.applyStyles({
              left: styleBox.formatStyle(linePos, "%")
            });
            break;
          case "lr":
            styleBox.applyStyles({
              right: styleBox.formatStyle(linePos, "%")
            });
            break;
        }
        axis = ["+y", "-x", "+x", "-y"];
        boxPosition = new BoxPosition(styleBox);
      }
      var bestPosition = findBestPosition(boxPosition, axis);
      styleBox.move(bestPosition.toCSSCompatValues(containerBox));
    }
    function WebVTT2() {
    }
    WebVTT2.StringDecoder = function() {
      return {
        decode: function(data) {
          if (!data) {
            return "";
          }
          if (typeof data !== "string") {
            throw new Error("Error - expected string data.");
          }
          return decodeURIComponent(encodeURIComponent(data));
        }
      };
    };
    WebVTT2.convertCueToDOMTree = function(window3, cuetext) {
      if (!window3 || !cuetext) {
        return null;
      }
      return parseContent(window3, cuetext);
    };
    var FONT_SIZE_PERCENT = 0.05;
    var FONT_STYLE = "sans-serif";
    var CUE_BACKGROUND_PADDING = "1.5%";
    WebVTT2.processCues = function(window3, cues, overlay) {
      if (!window3 || !cues || !overlay) {
        return null;
      }
      while (overlay.firstChild) {
        overlay.removeChild(overlay.firstChild);
      }
      var paddedOverlay = window3.document.createElement("div");
      paddedOverlay.style.position = "absolute";
      paddedOverlay.style.left = "0";
      paddedOverlay.style.right = "0";
      paddedOverlay.style.top = "0";
      paddedOverlay.style.bottom = "0";
      paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
      overlay.appendChild(paddedOverlay);
      function shouldCompute(cues2) {
        for (var i2 = 0; i2 < cues2.length; i2++) {
          if (cues2[i2].hasBeenReset || !cues2[i2].displayState) {
            return true;
          }
        }
        return false;
      }
      if (!shouldCompute(cues)) {
        for (var i = 0; i < cues.length; i++) {
          paddedOverlay.appendChild(cues[i].displayState);
        }
        return;
      }
      var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
      var styleOptions = {
        font: fontSize + "px " + FONT_STYLE
      };
      (function() {
        var styleBox, cue;
        for (var i2 = 0; i2 < cues.length; i2++) {
          cue = cues[i2];
          styleBox = new CueStyleBox(window3, cue, styleOptions);
          paddedOverlay.appendChild(styleBox.div);
          moveBoxToLinePosition(window3, styleBox, containerBox, boxPositions);
          cue.displayState = styleBox.div;
          boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
        }
      })();
    };
    WebVTT2.Parser = function(window3, vttjs, decoder) {
      if (!decoder) {
        decoder = vttjs;
        vttjs = {};
      }
      if (!vttjs) {
        vttjs = {};
      }
      this.window = window3;
      this.vttjs = vttjs;
      this.state = "INITIAL";
      this.buffer = "";
      this.decoder = decoder || new TextDecoder("utf8");
      this.regionList = [];
    };
    WebVTT2.Parser.prototype = {
      reportOrThrowError: function(e) {
        if (e instanceof ParsingError) {
          this.onparsingerror && this.onparsingerror(e);
        } else {
          throw e;
        }
      },
      parse: function(data) {
        var self2 = this;
        if (data) {
          self2.buffer += self2.decoder.decode(data, { stream: true });
        }
        function collectNextLine() {
          var buffer = self2.buffer;
          var pos = 0;
          while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
            ++pos;
          }
          var line2 = buffer.substr(0, pos);
          if (buffer[pos] === "\r") {
            ++pos;
          }
          if (buffer[pos] === "\n") {
            ++pos;
          }
          self2.buffer = buffer.substr(pos);
          return line2;
        }
        function parseRegion(input) {
          var settings2 = new Settings();
          parseOptions(input, function(k, v) {
            switch (k) {
              case "id":
                settings2.set(k, v);
                break;
              case "width":
                settings2.percent(k, v);
                break;
              case "lines":
                settings2.integer(k, v);
                break;
              case "regionanchor":
              case "viewportanchor":
                var xy = v.split(",");
                if (xy.length !== 2) {
                  break;
                }
                var anchor = new Settings();
                anchor.percent("x", xy[0]);
                anchor.percent("y", xy[1]);
                if (!anchor.has("x") || !anchor.has("y")) {
                  break;
                }
                settings2.set(k + "X", anchor.get("x"));
                settings2.set(k + "Y", anchor.get("y"));
                break;
              case "scroll":
                settings2.alt(k, v, ["up"]);
                break;
            }
          }, /=/, /\s/);
          if (settings2.has("id")) {
            var region = new (self2.vttjs.VTTRegion || self2.window.VTTRegion)();
            region.width = settings2.get("width", 100);
            region.lines = settings2.get("lines", 3);
            region.regionAnchorX = settings2.get("regionanchorX", 0);
            region.regionAnchorY = settings2.get("regionanchorY", 100);
            region.viewportAnchorX = settings2.get("viewportanchorX", 0);
            region.viewportAnchorY = settings2.get("viewportanchorY", 100);
            region.scroll = settings2.get("scroll", "");
            self2.onregion && self2.onregion(region);
            self2.regionList.push({
              id: settings2.get("id"),
              region
            });
          }
        }
        function parseTimestampMap(input) {
          var settings2 = new Settings();
          parseOptions(input, function(k, v) {
            switch (k) {
              case "MPEGT":
                settings2.integer(k + "S", v);
                break;
              case "LOCA":
                settings2.set(k + "L", parseTimeStamp(v));
                break;
            }
          }, /[^\d]:/, /,/);
          self2.ontimestampmap && self2.ontimestampmap({
            "MPEGTS": settings2.get("MPEGTS"),
            "LOCAL": settings2.get("LOCAL")
          });
        }
        function parseHeader(input) {
          if (input.match(/X-TIMESTAMP-MAP/)) {
            parseOptions(input, function(k, v) {
              switch (k) {
                case "X-TIMESTAMP-MAP":
                  parseTimestampMap(v);
                  break;
              }
            }, /=/);
          } else {
            parseOptions(input, function(k, v) {
              switch (k) {
                case "Region":
                  parseRegion(v);
                  break;
              }
            }, /:/);
          }
        }
        try {
          var line;
          if (self2.state === "INITIAL") {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            line = collectNextLine();
            var m = line.match(/^WEBVTT([ \t].*)?$/);
            if (!m || !m[0]) {
              throw new ParsingError(ParsingError.Errors.BadSignature);
            }
            self2.state = "HEADER";
          }
          var alreadyCollectedLine = false;
          while (self2.buffer) {
            if (!/\r\n|\n/.test(self2.buffer)) {
              return this;
            }
            if (!alreadyCollectedLine) {
              line = collectNextLine();
            } else {
              alreadyCollectedLine = false;
            }
            switch (self2.state) {
              case "HEADER":
                if (/:/.test(line)) {
                  parseHeader(line);
                } else if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "NOTE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
              case "ID":
                if (/^NOTE($|[ \t])/.test(line)) {
                  self2.state = "NOTE";
                  break;
                }
                if (!line) {
                  continue;
                }
                self2.cue = new (self2.vttjs.VTTCue || self2.window.VTTCue)(0, 0, "");
                try {
                  self2.cue.align = "center";
                } catch (e) {
                  self2.cue.align = "middle";
                }
                self2.state = "CUE";
                if (line.indexOf("-->") === -1) {
                  self2.cue.id = line;
                  continue;
                }
              case "CUE":
                try {
                  parseCue(line, self2.cue, self2.regionList);
                } catch (e) {
                  self2.reportOrThrowError(e);
                  self2.cue = null;
                  self2.state = "BADCUE";
                  continue;
                }
                self2.state = "CUETEXT";
                continue;
              case "CUETEXT":
                var hasSubstring = line.indexOf("-->") !== -1;
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  self2.oncue && self2.oncue(self2.cue);
                  self2.cue = null;
                  self2.state = "ID";
                  continue;
                }
                if (self2.cue.text) {
                  self2.cue.text += "\n";
                }
                self2.cue.text += line.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
                continue;
              case "BADCUE":
                if (!line) {
                  self2.state = "ID";
                }
                continue;
            }
          }
        } catch (e) {
          self2.reportOrThrowError(e);
          if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
            self2.oncue(self2.cue);
          }
          self2.cue = null;
          self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
        }
        return this;
      },
      flush: function() {
        var self2 = this;
        try {
          self2.buffer += self2.decoder.decode();
          if (self2.cue || self2.state === "HEADER") {
            self2.buffer += "\n\n";
            self2.parse();
          }
          if (self2.state === "INITIAL") {
            throw new ParsingError(ParsingError.Errors.BadSignature);
          }
        } catch (e) {
          self2.reportOrThrowError(e);
        }
        self2.onflush && self2.onflush();
        return this;
      }
    };
    module.exports = WebVTT2;
  }
});

// node_modules/videojs-vtt.js/lib/vttcue.js
var require_vttcue = __commonJS({
  "node_modules/videojs-vtt.js/lib/vttcue.js"(exports, module) {
    var autoKeyword = "auto";
    var directionSetting = {
      "": 1,
      "lr": 1,
      "rl": 1
    };
    var alignSetting = {
      "start": 1,
      "center": 1,
      "end": 1,
      "left": 1,
      "right": 1,
      "auto": 1,
      "line-left": 1,
      "line-right": 1
    };
    function findDirectionSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var dir = directionSetting[value.toLowerCase()];
      return dir ? value.toLowerCase() : false;
    }
    function findAlignSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var align = alignSetting[value.toLowerCase()];
      return align ? value.toLowerCase() : false;
    }
    function VTTCue(startTime, endTime, text) {
      this.hasBeenReset = false;
      var _id = "";
      var _pauseOnExit = false;
      var _startTime = startTime;
      var _endTime = endTime;
      var _text = text;
      var _region = null;
      var _vertical = "";
      var _snapToLines = true;
      var _line = "auto";
      var _lineAlign = "start";
      var _position = "auto";
      var _positionAlign = "auto";
      var _size = 100;
      var _align = "center";
      Object.defineProperties(this, {
        "id": {
          enumerable: true,
          get: function() {
            return _id;
          },
          set: function(value) {
            _id = "" + value;
          }
        },
        "pauseOnExit": {
          enumerable: true,
          get: function() {
            return _pauseOnExit;
          },
          set: function(value) {
            _pauseOnExit = !!value;
          }
        },
        "startTime": {
          enumerable: true,
          get: function() {
            return _startTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Start time must be set to a number.");
            }
            _startTime = value;
            this.hasBeenReset = true;
          }
        },
        "endTime": {
          enumerable: true,
          get: function() {
            return _endTime;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("End time must be set to a number.");
            }
            _endTime = value;
            this.hasBeenReset = true;
          }
        },
        "text": {
          enumerable: true,
          get: function() {
            return _text;
          },
          set: function(value) {
            _text = "" + value;
            this.hasBeenReset = true;
          }
        },
        "region": {
          enumerable: true,
          get: function() {
            return _region;
          },
          set: function(value) {
            _region = value;
            this.hasBeenReset = true;
          }
        },
        "vertical": {
          enumerable: true,
          get: function() {
            return _vertical;
          },
          set: function(value) {
            var setting = findDirectionSetting(value);
            if (setting === false) {
              throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
            }
            _vertical = setting;
            this.hasBeenReset = true;
          }
        },
        "snapToLines": {
          enumerable: true,
          get: function() {
            return _snapToLines;
          },
          set: function(value) {
            _snapToLines = !!value;
            this.hasBeenReset = true;
          }
        },
        "line": {
          enumerable: true,
          get: function() {
            return _line;
          },
          set: function(value) {
            if (typeof value !== "number" && value !== autoKeyword) {
              throw new SyntaxError("Line: an invalid number or illegal string was specified.");
            }
            _line = value;
            this.hasBeenReset = true;
          }
        },
        "lineAlign": {
          enumerable: true,
          get: function() {
            return _lineAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              console.warn("lineAlign: an invalid or illegal string was specified.");
            } else {
              _lineAlign = setting;
              this.hasBeenReset = true;
            }
          }
        },
        "position": {
          enumerable: true,
          get: function() {
            return _position;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Position must be between 0 and 100.");
            }
            _position = value;
            this.hasBeenReset = true;
          }
        },
        "positionAlign": {
          enumerable: true,
          get: function() {
            return _positionAlign;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              console.warn("positionAlign: an invalid or illegal string was specified.");
            } else {
              _positionAlign = setting;
              this.hasBeenReset = true;
            }
          }
        },
        "size": {
          enumerable: true,
          get: function() {
            return _size;
          },
          set: function(value) {
            if (value < 0 || value > 100) {
              throw new Error("Size must be between 0 and 100.");
            }
            _size = value;
            this.hasBeenReset = true;
          }
        },
        "align": {
          enumerable: true,
          get: function() {
            return _align;
          },
          set: function(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
            }
            _align = setting;
            this.hasBeenReset = true;
          }
        }
      });
      this.displayState = void 0;
    }
    VTTCue.prototype.getCueAsHTML = function() {
      return WebVTT.convertCueToDOMTree(window, this.text);
    };
    module.exports = VTTCue;
  }
});

// node_modules/videojs-vtt.js/lib/vttregion.js
var require_vttregion = __commonJS({
  "node_modules/videojs-vtt.js/lib/vttregion.js"(exports, module) {
    var scrollSetting = {
      "": true,
      "up": true
    };
    function findScrollSetting(value) {
      if (typeof value !== "string") {
        return false;
      }
      var scroll = scrollSetting[value.toLowerCase()];
      return scroll ? value.toLowerCase() : false;
    }
    function isValidPercentValue(value) {
      return typeof value === "number" && (value >= 0 && value <= 100);
    }
    function VTTRegion() {
      var _width = 100;
      var _lines = 3;
      var _regionAnchorX = 0;
      var _regionAnchorY = 100;
      var _viewportAnchorX = 0;
      var _viewportAnchorY = 100;
      var _scroll = "";
      Object.defineProperties(this, {
        "width": {
          enumerable: true,
          get: function() {
            return _width;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("Width must be between 0 and 100.");
            }
            _width = value;
          }
        },
        "lines": {
          enumerable: true,
          get: function() {
            return _lines;
          },
          set: function(value) {
            if (typeof value !== "number") {
              throw new TypeError("Lines must be set to a number.");
            }
            _lines = value;
          }
        },
        "regionAnchorY": {
          enumerable: true,
          get: function() {
            return _regionAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorX must be between 0 and 100.");
            }
            _regionAnchorY = value;
          }
        },
        "regionAnchorX": {
          enumerable: true,
          get: function() {
            return _regionAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("RegionAnchorY must be between 0 and 100.");
            }
            _regionAnchorX = value;
          }
        },
        "viewportAnchorY": {
          enumerable: true,
          get: function() {
            return _viewportAnchorY;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorY must be between 0 and 100.");
            }
            _viewportAnchorY = value;
          }
        },
        "viewportAnchorX": {
          enumerable: true,
          get: function() {
            return _viewportAnchorX;
          },
          set: function(value) {
            if (!isValidPercentValue(value)) {
              throw new Error("ViewportAnchorX must be between 0 and 100.");
            }
            _viewportAnchorX = value;
          }
        },
        "scroll": {
          enumerable: true,
          get: function() {
            return _scroll;
          },
          set: function(value) {
            var setting = findScrollSetting(value);
            if (setting === false) {
              console.warn("Scroll: an invalid or illegal string was specified.");
            } else {
              _scroll = setting;
            }
          }
        }
      });
    }
    module.exports = VTTRegion;
  }
});

// node_modules/videojs-vtt.js/lib/browser-index.js
var require_browser_index = __commonJS({
  "node_modules/videojs-vtt.js/lib/browser-index.js"(exports, module) {
    var window3 = require_window();
    var vttjs = module.exports = {
      WebVTT: require_vtt(),
      VTTCue: require_vttcue(),
      VTTRegion: require_vttregion()
    };
    window3.vttjs = vttjs;
    window3.WebVTT = vttjs.WebVTT;
    var cueShim = vttjs.VTTCue;
    var regionShim = vttjs.VTTRegion;
    var nativeVTTCue = window3.VTTCue;
    var nativeVTTRegion = window3.VTTRegion;
    vttjs.shim = function() {
      window3.VTTCue = cueShim;
      window3.VTTRegion = regionShim;
    };
    vttjs.restore = function() {
      window3.VTTCue = nativeVTTCue;
      window3.VTTRegion = nativeVTTRegion;
    };
    if (!window3.VTTCue) {
      vttjs.shim();
    }
  }
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module) {
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/construct.js
var require_construct = __commonJS({
  "node_modules/@babel/runtime/helpers/construct.js"(exports, module) {
    var isNativeReflectConstruct = require_isNativeReflectConstruct();
    var setPrototypeOf = require_setPrototypeOf();
    function _construct(t, e, r) {
      if (isNativeReflectConstruct())
        return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && setPrototypeOf(p, r.prototype), p;
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(t, e) {
      if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: true,
          configurable: true
        }
      }), Object.defineProperty(t, "prototype", {
        writable: false
      }), e && setPrototypeOf(t, e);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        "default": e
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/url-toolkit/src/url-toolkit.js
var require_url_toolkit = __commonJS({
  "node_modules/url-toolkit/src/url-toolkit.js"(exports, module) {
    (function(root) {
      var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
      var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
      var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
      var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
      var URLToolkit = {
        buildAbsoluteURL: function(baseURL, relativeURL, opts) {
          opts = opts || {};
          baseURL = baseURL.trim();
          relativeURL = relativeURL.trim();
          if (!relativeURL) {
            if (!opts.alwaysNormalize) {
              return baseURL;
            }
            var basePartsForNormalise = URLToolkit.parseURL(baseURL);
            if (!basePartsForNormalise) {
              throw new Error("Error trying to parse base URL.");
            }
            basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
            return URLToolkit.buildURLFromParts(basePartsForNormalise);
          }
          var relativeParts = URLToolkit.parseURL(relativeURL);
          if (!relativeParts) {
            throw new Error("Error trying to parse relative URL.");
          }
          if (relativeParts.scheme) {
            if (!opts.alwaysNormalize) {
              return relativeURL;
            }
            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
            return URLToolkit.buildURLFromParts(relativeParts);
          }
          var baseParts = URLToolkit.parseURL(baseURL);
          if (!baseParts) {
            throw new Error("Error trying to parse base URL.");
          }
          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
            baseParts.netLoc = pathParts[1];
            baseParts.path = pathParts[2];
          }
          if (baseParts.netLoc && !baseParts.path) {
            baseParts.path = "/";
          }
          var builtParts = {
            scheme: baseParts.scheme,
            netLoc: relativeParts.netLoc,
            path: null,
            params: relativeParts.params,
            query: relativeParts.query,
            fragment: relativeParts.fragment
          };
          if (!relativeParts.netLoc) {
            builtParts.netLoc = baseParts.netLoc;
            if (relativeParts.path[0] !== "/") {
              if (!relativeParts.path) {
                builtParts.path = baseParts.path;
                if (!relativeParts.params) {
                  builtParts.params = baseParts.params;
                  if (!relativeParts.query) {
                    builtParts.query = baseParts.query;
                  }
                }
              } else {
                var baseURLPath = baseParts.path;
                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                builtParts.path = URLToolkit.normalizePath(newPath);
              }
            }
          }
          if (builtParts.path === null) {
            builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
          }
          return URLToolkit.buildURLFromParts(builtParts);
        },
        parseURL: function(url) {
          var parts = URL_REGEX.exec(url);
          if (!parts) {
            return null;
          }
          return {
            scheme: parts[1] || "",
            netLoc: parts[2] || "",
            path: parts[3] || "",
            params: parts[4] || "",
            query: parts[5] || "",
            fragment: parts[6] || ""
          };
        },
        normalizePath: function(path) {
          path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
          }
          return path.split("").reverse().join("");
        },
        buildURLFromParts: function(parts) {
          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
        }
      };
      if (typeof exports === "object" && typeof module === "object")
        module.exports = URLToolkit;
      else if (typeof define === "function" && define.amd)
        define([], function() {
          return URLToolkit;
        });
      else if (typeof exports === "object")
        exports["URLToolkit"] = URLToolkit;
      else
        root["URLToolkit"] = URLToolkit;
    })(exports);
  }
});

// node_modules/@videojs/vhs-utils/cjs/resolve-url.js
var require_resolve_url = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/resolve-url.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _urlToolkit = _interopRequireDefault(require_url_toolkit());
    var _window = _interopRequireDefault(require_window());
    var DEFAULT_LOCATION = "http://example.com";
    var resolveUrl = function resolveUrl2(baseUrl, relativeUrl) {
      if (/^[a-z]+:/i.test(relativeUrl)) {
        return relativeUrl;
      }
      if (/^data:/.test(baseUrl)) {
        baseUrl = _window.default.location && _window.default.location.href || "";
      }
      var nativeURL = typeof _window.default.URL === "function";
      var protocolLess = /^\/\//.test(baseUrl);
      var removeLocation = !_window.default.location && !/\/\//i.test(baseUrl);
      if (nativeURL) {
        baseUrl = new _window.default.URL(baseUrl, _window.default.location || DEFAULT_LOCATION);
      } else if (!/\/\//i.test(baseUrl)) {
        baseUrl = _urlToolkit.default.buildAbsoluteURL(_window.default.location && _window.default.location.href || "", baseUrl);
      }
      if (nativeURL) {
        var newUrl = new URL(relativeUrl, baseUrl);
        if (removeLocation) {
          return newUrl.href.slice(DEFAULT_LOCATION.length);
        } else if (protocolLess) {
          return newUrl.href.slice(newUrl.protocol.length);
        }
        return newUrl.href;
      }
      return _urlToolkit.default.buildAbsoluteURL(baseUrl, relativeUrl);
    };
    var _default = resolveUrl;
    exports.default = _default;
    module.exports = exports.default;
  }
});

// node_modules/@videojs/vhs-utils/cjs/stream.js
var require_stream = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/stream.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Stream = /* @__PURE__ */ function() {
      function Stream2() {
        this.listeners = {};
      }
      var _proto = Stream2.prototype;
      _proto.on = function on(type, listener) {
        if (!this.listeners[type]) {
          this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
      };
      _proto.off = function off(type, listener) {
        if (!this.listeners[type]) {
          return false;
        }
        var index = this.listeners[type].indexOf(listener);
        this.listeners[type] = this.listeners[type].slice(0);
        this.listeners[type].splice(index, 1);
        return index > -1;
      };
      _proto.trigger = function trigger(type) {
        var callbacks = this.listeners[type];
        if (!callbacks) {
          return;
        }
        if (arguments.length === 2) {
          var length = callbacks.length;
          for (var i = 0; i < length; ++i) {
            callbacks[i].call(this, arguments[1]);
          }
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var _length = callbacks.length;
          for (var _i = 0; _i < _length; ++_i) {
            callbacks[_i].apply(this, args);
          }
        }
      };
      _proto.dispose = function dispose() {
        this.listeners = {};
      };
      _proto.pipe = function pipe(destination) {
        this.on("data", function(data) {
          destination.push(data);
        });
      };
      return Stream2;
    }();
    exports.default = Stream;
    module.exports = exports.default;
  }
});

// node_modules/@videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js
var require_decode_b64_to_uint8_array = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/decode-b64-to-uint8-array.js"(exports, module) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = decodeB64ToUint8Array;
    var _window = _interopRequireDefault(require_window());
    var atob = function atob2(s) {
      return _window.default.atob ? _window.default.atob(s) : Buffer.from(s, "base64").toString("binary");
    };
    function decodeB64ToUint8Array(b64Text) {
      var decodedString = atob(b64Text);
      var array = new Uint8Array(decodedString.length);
      for (var i = 0; i < decodedString.length; i++) {
        array[i] = decodedString.charCodeAt(i);
      }
      return array;
    }
    module.exports = exports.default;
  }
});

// node_modules/m3u8-parser/dist/m3u8-parser.cjs.js
var require_m3u8_parser_cjs = __commonJS({
  "node_modules/m3u8-parser/dist/m3u8-parser.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _inheritsLoose2 = require_inheritsLoose();
    var Stream = require_stream();
    var _extends = require_extends();
    var _assertThisInitialized = require_assertThisInitialized();
    var decodeB64ToUint8Array = require_decode_b64_to_uint8_array();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var _inheritsLoose__default = /* @__PURE__ */ _interopDefaultLegacy(_inheritsLoose2);
    var Stream__default = /* @__PURE__ */ _interopDefaultLegacy(Stream);
    var _extends__default = /* @__PURE__ */ _interopDefaultLegacy(_extends);
    var _assertThisInitialized__default = /* @__PURE__ */ _interopDefaultLegacy(_assertThisInitialized);
    var decodeB64ToUint8Array__default = /* @__PURE__ */ _interopDefaultLegacy(decodeB64ToUint8Array);
    var LineStream = /* @__PURE__ */ function(_Stream) {
      _inheritsLoose__default["default"](LineStream2, _Stream);
      function LineStream2() {
        var _this;
        _this = _Stream.call(this) || this;
        _this.buffer = "";
        return _this;
      }
      var _proto = LineStream2.prototype;
      _proto.push = function push(data) {
        var nextNewline;
        this.buffer += data;
        nextNewline = this.buffer.indexOf("\n");
        for (; nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
          this.trigger("data", this.buffer.substring(0, nextNewline));
          this.buffer = this.buffer.substring(nextNewline + 1);
        }
      };
      return LineStream2;
    }(Stream__default["default"]);
    var TAB = String.fromCharCode(9);
    var parseByterange = function parseByterange2(byterangeString) {
      var match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
      var result = {};
      if (match[1]) {
        result.length = parseInt(match[1], 10);
      }
      if (match[2]) {
        result.offset = parseInt(match[2], 10);
      }
      return result;
    };
    var attributeSeparator = function attributeSeparator2() {
      var key = "[^=]*";
      var value = '"[^"]*"|[^,]*';
      var keyvalue = "(?:" + key + ")=(?:" + value + ")";
      return new RegExp("(?:^|,)(" + keyvalue + ")");
    };
    var parseAttributes = function parseAttributes2(attributes) {
      var attrs = attributes.split(attributeSeparator());
      var result = {};
      var i = attrs.length;
      var attr;
      while (i--) {
        if (attrs[i] === "") {
          continue;
        }
        attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
        attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
        attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
        attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
        result[attr[0]] = attr[1];
      }
      return result;
    };
    var ParseStream = /* @__PURE__ */ function(_Stream) {
      _inheritsLoose__default["default"](ParseStream2, _Stream);
      function ParseStream2() {
        var _this;
        _this = _Stream.call(this) || this;
        _this.customParsers = [];
        _this.tagMappers = [];
        return _this;
      }
      var _proto = ParseStream2.prototype;
      _proto.push = function push(line) {
        var _this2 = this;
        var match;
        var event;
        line = line.trim();
        if (line.length === 0) {
          return;
        }
        if (line[0] !== "#") {
          this.trigger("data", {
            type: "uri",
            uri: line
          });
          return;
        }
        var newLines = this.tagMappers.reduce(function(acc, mapper) {
          var mappedLine = mapper(line);
          if (mappedLine === line) {
            return acc;
          }
          return acc.concat([mappedLine]);
        }, [line]);
        newLines.forEach(function(newLine) {
          for (var i = 0; i < _this2.customParsers.length; i++) {
            if (_this2.customParsers[i].call(_this2, newLine)) {
              return;
            }
          }
          if (newLine.indexOf("#EXT") !== 0) {
            _this2.trigger("data", {
              type: "comment",
              text: newLine.slice(1)
            });
            return;
          }
          newLine = newLine.replace("\r", "");
          match = /^#EXTM3U/.exec(newLine);
          if (match) {
            _this2.trigger("data", {
              type: "tag",
              tagType: "m3u"
            });
            return;
          }
          match = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "inf"
            };
            if (match[1]) {
              event.duration = parseFloat(match[1]);
            }
            if (match[2]) {
              event.title = match[2];
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "targetduration"
            };
            if (match[1]) {
              event.duration = parseInt(match[1], 10);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "version"
            };
            if (match[1]) {
              event.version = parseInt(match[1], 10);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "media-sequence"
            };
            if (match[1]) {
              event.number = parseInt(match[1], 10);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "discontinuity-sequence"
            };
            if (match[1]) {
              event.number = parseInt(match[1], 10);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "playlist-type"
            };
            if (match[1]) {
              event.playlistType = match[1];
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);
          if (match) {
            event = _extends__default["default"](parseByterange(match[1]), {
              type: "tag",
              tagType: "byterange"
            });
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "allow-cache"
            };
            if (match[1]) {
              event.allowed = !/NO/.test(match[1]);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "map"
            };
            if (match[1]) {
              var attributes = parseAttributes(match[1]);
              if (attributes.URI) {
                event.uri = attributes.URI;
              }
              if (attributes.BYTERANGE) {
                event.byterange = parseByterange(attributes.BYTERANGE);
              }
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "stream-inf"
            };
            if (match[1]) {
              event.attributes = parseAttributes(match[1]);
              if (event.attributes.RESOLUTION) {
                var split = event.attributes.RESOLUTION.split("x");
                var resolution = {};
                if (split[0]) {
                  resolution.width = parseInt(split[0], 10);
                }
                if (split[1]) {
                  resolution.height = parseInt(split[1], 10);
                }
                event.attributes.RESOLUTION = resolution;
              }
              if (event.attributes.BANDWIDTH) {
                event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
              }
              if (event.attributes["FRAME-RATE"]) {
                event.attributes["FRAME-RATE"] = parseFloat(event.attributes["FRAME-RATE"]);
              }
              if (event.attributes["PROGRAM-ID"]) {
                event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
              }
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "media"
            };
            if (match[1]) {
              event.attributes = parseAttributes(match[1]);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-ENDLIST/.exec(newLine);
          if (match) {
            _this2.trigger("data", {
              type: "tag",
              tagType: "endlist"
            });
            return;
          }
          match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
          if (match) {
            _this2.trigger("data", {
              type: "tag",
              tagType: "discontinuity"
            });
            return;
          }
          match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "program-date-time"
            };
            if (match[1]) {
              event.dateTimeString = match[1];
              event.dateTimeObject = new Date(match[1]);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "key"
            };
            if (match[1]) {
              event.attributes = parseAttributes(match[1]);
              if (event.attributes.IV) {
                if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") {
                  event.attributes.IV = event.attributes.IV.substring(2);
                }
                event.attributes.IV = event.attributes.IV.match(/.{8}/g);
                event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
                event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
                event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
                event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
                event.attributes.IV = new Uint32Array(event.attributes.IV);
              }
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-START:?(.*)$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "start"
            };
            if (match[1]) {
              event.attributes = parseAttributes(match[1]);
              event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
              event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "cue-out-cont"
            };
            if (match[1]) {
              event.data = match[1];
            } else {
              event.data = "";
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "cue-out"
            };
            if (match[1]) {
              event.data = match[1];
            } else {
              event.data = "";
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
          if (match) {
            event = {
              type: "tag",
              tagType: "cue-in"
            };
            if (match[1]) {
              event.data = match[1];
            } else {
              event.data = "";
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
          if (match && match[1]) {
            event = {
              type: "tag",
              tagType: "skip"
            };
            event.attributes = parseAttributes(match[1]);
            if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) {
              event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
            }
            if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) {
              event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-PART:(.*)$/.exec(newLine);
          if (match && match[1]) {
            event = {
              type: "tag",
              tagType: "part"
            };
            event.attributes = parseAttributes(match[1]);
            ["DURATION"].forEach(function(key) {
              if (event.attributes.hasOwnProperty(key)) {
                event.attributes[key] = parseFloat(event.attributes[key]);
              }
            });
            ["INDEPENDENT", "GAP"].forEach(function(key) {
              if (event.attributes.hasOwnProperty(key)) {
                event.attributes[key] = /YES/.test(event.attributes[key]);
              }
            });
            if (event.attributes.hasOwnProperty("BYTERANGE")) {
              event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
            }
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
          if (match && match[1]) {
            event = {
              type: "tag",
              tagType: "server-control"
            };
            event.attributes = parseAttributes(match[1]);
            ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(key) {
              if (event.attributes.hasOwnProperty(key)) {
                event.attributes[key] = parseFloat(event.attributes[key]);
              }
            });
            ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(key) {
              if (event.attributes.hasOwnProperty(key)) {
                event.attributes[key] = /YES/.test(event.attributes[key]);
              }
            });
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
          if (match && match[1]) {
            event = {
              type: "tag",
              tagType: "part-inf"
            };
            event.attributes = parseAttributes(match[1]);
            ["PART-TARGET"].forEach(function(key) {
              if (event.attributes.hasOwnProperty(key)) {
                event.attributes[key] = parseFloat(event.attributes[key]);
              }
            });
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
          if (match && match[1]) {
            event = {
              type: "tag",
              tagType: "preload-hint"
            };
            event.attributes = parseAttributes(match[1]);
            ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(key) {
              if (event.attributes.hasOwnProperty(key)) {
                event.attributes[key] = parseInt(event.attributes[key], 10);
                var subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
                event.attributes.byterange = event.attributes.byterange || {};
                event.attributes.byterange[subkey] = event.attributes[key];
                delete event.attributes[key];
              }
            });
            _this2.trigger("data", event);
            return;
          }
          match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
          if (match && match[1]) {
            event = {
              type: "tag",
              tagType: "rendition-report"
            };
            event.attributes = parseAttributes(match[1]);
            ["LAST-MSN", "LAST-PART"].forEach(function(key) {
              if (event.attributes.hasOwnProperty(key)) {
                event.attributes[key] = parseInt(event.attributes[key], 10);
              }
            });
            _this2.trigger("data", event);
            return;
          }
          _this2.trigger("data", {
            type: "tag",
            data: newLine.slice(4)
          });
        });
      };
      _proto.addParser = function addParser(_ref) {
        var _this3 = this;
        var expression = _ref.expression, customType = _ref.customType, dataParser = _ref.dataParser, segment = _ref.segment;
        if (typeof dataParser !== "function") {
          dataParser = function dataParser2(line) {
            return line;
          };
        }
        this.customParsers.push(function(line) {
          var match = expression.exec(line);
          if (match) {
            _this3.trigger("data", {
              type: "custom",
              data: dataParser(line),
              customType,
              segment
            });
            return true;
          }
        });
      };
      _proto.addTagMapper = function addTagMapper(_ref2) {
        var expression = _ref2.expression, map = _ref2.map;
        var mapFn = function mapFn2(line) {
          if (expression.test(line)) {
            return map(line);
          }
          return line;
        };
        this.tagMappers.push(mapFn);
      };
      return ParseStream2;
    }(Stream__default["default"]);
    var camelCase = function camelCase2(str) {
      return str.toLowerCase().replace(/-(\w)/g, function(a) {
        return a[1].toUpperCase();
      });
    };
    var camelCaseKeys = function camelCaseKeys2(attributes) {
      var result = {};
      Object.keys(attributes).forEach(function(key) {
        result[camelCase(key)] = attributes[key];
      });
      return result;
    };
    var setHoldBack = function setHoldBack2(manifest) {
      var serverControl = manifest.serverControl, targetDuration = manifest.targetDuration, partTargetDuration = manifest.partTargetDuration;
      if (!serverControl) {
        return;
      }
      var tag = "#EXT-X-SERVER-CONTROL";
      var hb = "holdBack";
      var phb = "partHoldBack";
      var minTargetDuration = targetDuration && targetDuration * 3;
      var minPartDuration = partTargetDuration && partTargetDuration * 2;
      if (targetDuration && !serverControl.hasOwnProperty(hb)) {
        serverControl[hb] = minTargetDuration;
        this.trigger("info", {
          message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
        });
      }
      if (minTargetDuration && serverControl[hb] < minTargetDuration) {
        this.trigger("warn", {
          message: tag + " clamping HOLD-BACK (" + serverControl[hb] + ") to targetDuration * 3 (" + minTargetDuration + ")"
        });
        serverControl[hb] = minTargetDuration;
      }
      if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
        serverControl[phb] = partTargetDuration * 3;
        this.trigger("info", {
          message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
        });
      }
      if (partTargetDuration && serverControl[phb] < minPartDuration) {
        this.trigger("warn", {
          message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
        });
        serverControl[phb] = minPartDuration;
      }
    };
    var Parser = /* @__PURE__ */ function(_Stream) {
      _inheritsLoose__default["default"](Parser2, _Stream);
      function Parser2() {
        var _this;
        _this = _Stream.call(this) || this;
        _this.lineStream = new LineStream();
        _this.parseStream = new ParseStream();
        _this.lineStream.pipe(_this.parseStream);
        var self2 = _assertThisInitialized__default["default"](_this);
        var uris = [];
        var currentUri = {};
        var currentMap;
        var _key;
        var hasParts = false;
        var noop = function noop2() {
        };
        var defaultMediaGroups = {
          "AUDIO": {},
          "VIDEO": {},
          "CLOSED-CAPTIONS": {},
          "SUBTITLES": {}
        };
        var widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
        var currentTimeline = 0;
        _this.manifest = {
          allowCache: true,
          discontinuityStarts: [],
          segments: []
        };
        var lastByterangeEnd = 0;
        var lastPartByterangeEnd = 0;
        _this.on("end", function() {
          if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
            return;
          }
          if (!currentUri.map && currentMap) {
            currentUri.map = currentMap;
          }
          if (!currentUri.key && _key) {
            currentUri.key = _key;
          }
          if (!currentUri.timeline && typeof currentTimeline === "number") {
            currentUri.timeline = currentTimeline;
          }
          _this.manifest.preloadSegment = currentUri;
        });
        _this.parseStream.on("data", function(entry) {
          var mediaGroup;
          var rendition;
          ({
            tag: function tag() {
              ({
                version: function version2() {
                  if (entry.version) {
                    this.manifest.version = entry.version;
                  }
                },
                "allow-cache": function allowCache() {
                  this.manifest.allowCache = entry.allowed;
                  if (!("allowed" in entry)) {
                    this.trigger("info", {
                      message: "defaulting allowCache to YES"
                    });
                    this.manifest.allowCache = true;
                  }
                },
                byterange: function byterange() {
                  var byterange2 = {};
                  if ("length" in entry) {
                    currentUri.byterange = byterange2;
                    byterange2.length = entry.length;
                    if (!("offset" in entry)) {
                      entry.offset = lastByterangeEnd;
                    }
                  }
                  if ("offset" in entry) {
                    currentUri.byterange = byterange2;
                    byterange2.offset = entry.offset;
                  }
                  lastByterangeEnd = byterange2.offset + byterange2.length;
                },
                endlist: function endlist() {
                  this.manifest.endList = true;
                },
                inf: function inf() {
                  if (!("mediaSequence" in this.manifest)) {
                    this.manifest.mediaSequence = 0;
                    this.trigger("info", {
                      message: "defaulting media sequence to zero"
                    });
                  }
                  if (!("discontinuitySequence" in this.manifest)) {
                    this.manifest.discontinuitySequence = 0;
                    this.trigger("info", {
                      message: "defaulting discontinuity sequence to zero"
                    });
                  }
                  if (entry.duration > 0) {
                    currentUri.duration = entry.duration;
                  }
                  if (entry.duration === 0) {
                    currentUri.duration = 0.01;
                    this.trigger("info", {
                      message: "updating zero segment duration to a small value"
                    });
                  }
                  this.manifest.segments = uris;
                },
                key: function key() {
                  if (!entry.attributes) {
                    this.trigger("warn", {
                      message: "ignoring key declaration without attribute list"
                    });
                    return;
                  }
                  if (entry.attributes.METHOD === "NONE") {
                    _key = null;
                    return;
                  }
                  if (!entry.attributes.URI) {
                    this.trigger("warn", {
                      message: "ignoring key declaration without URI"
                    });
                    return;
                  }
                  if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                    this.manifest.contentProtection = this.manifest.contentProtection || {};
                    this.manifest.contentProtection["com.apple.fps.1_0"] = {
                      attributes: entry.attributes
                    };
                    return;
                  }
                  if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                    this.manifest.contentProtection = this.manifest.contentProtection || {};
                    this.manifest.contentProtection["com.microsoft.playready"] = {
                      uri: entry.attributes.URI
                    };
                    return;
                  }
                  if (entry.attributes.KEYFORMAT === widevineUuid) {
                    var VALID_METHODS = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                    if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                      this.trigger("warn", {
                        message: "invalid key method provided for Widevine"
                      });
                      return;
                    }
                    if (entry.attributes.METHOD === "SAMPLE-AES-CENC") {
                      this.trigger("warn", {
                        message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                      });
                    }
                    if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                      this.trigger("warn", {
                        message: "invalid key URI provided for Widevine"
                      });
                      return;
                    }
                    if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                      this.trigger("warn", {
                        message: "invalid key ID provided for Widevine"
                      });
                      return;
                    }
                    this.manifest.contentProtection = this.manifest.contentProtection || {};
                    this.manifest.contentProtection["com.widevine.alpha"] = {
                      attributes: {
                        schemeIdUri: entry.attributes.KEYFORMAT,
                        keyId: entry.attributes.KEYID.substring(2)
                      },
                      pssh: decodeB64ToUint8Array__default["default"](entry.attributes.URI.split(",")[1])
                    };
                    return;
                  }
                  if (!entry.attributes.METHOD) {
                    this.trigger("warn", {
                      message: "defaulting key method to AES-128"
                    });
                  }
                  _key = {
                    method: entry.attributes.METHOD || "AES-128",
                    uri: entry.attributes.URI
                  };
                  if (typeof entry.attributes.IV !== "undefined") {
                    _key.iv = entry.attributes.IV;
                  }
                },
                "media-sequence": function mediaSequence() {
                  if (!isFinite(entry.number)) {
                    this.trigger("warn", {
                      message: "ignoring invalid media sequence: " + entry.number
                    });
                    return;
                  }
                  this.manifest.mediaSequence = entry.number;
                },
                "discontinuity-sequence": function discontinuitySequence() {
                  if (!isFinite(entry.number)) {
                    this.trigger("warn", {
                      message: "ignoring invalid discontinuity sequence: " + entry.number
                    });
                    return;
                  }
                  this.manifest.discontinuitySequence = entry.number;
                  currentTimeline = entry.number;
                },
                "playlist-type": function playlistType() {
                  if (!/VOD|EVENT/.test(entry.playlistType)) {
                    this.trigger("warn", {
                      message: "ignoring unknown playlist type: " + entry.playlist
                    });
                    return;
                  }
                  this.manifest.playlistType = entry.playlistType;
                },
                map: function map() {
                  currentMap = {};
                  if (entry.uri) {
                    currentMap.uri = entry.uri;
                  }
                  if (entry.byterange) {
                    currentMap.byterange = entry.byterange;
                  }
                  if (_key) {
                    currentMap.key = _key;
                  }
                },
                "stream-inf": function streamInf() {
                  this.manifest.playlists = uris;
                  this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                  if (!entry.attributes) {
                    this.trigger("warn", {
                      message: "ignoring empty stream-inf attributes"
                    });
                    return;
                  }
                  if (!currentUri.attributes) {
                    currentUri.attributes = {};
                  }
                  _extends__default["default"](currentUri.attributes, entry.attributes);
                },
                media: function media() {
                  this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                  if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                    this.trigger("warn", {
                      message: "ignoring incomplete or missing media group"
                    });
                    return;
                  }
                  var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
                  mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
                  mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
                  rendition = {
                    default: /yes/i.test(entry.attributes.DEFAULT)
                  };
                  if (rendition.default) {
                    rendition.autoselect = true;
                  } else {
                    rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
                  }
                  if (entry.attributes.LANGUAGE) {
                    rendition.language = entry.attributes.LANGUAGE;
                  }
                  if (entry.attributes.URI) {
                    rendition.uri = entry.attributes.URI;
                  }
                  if (entry.attributes["INSTREAM-ID"]) {
                    rendition.instreamId = entry.attributes["INSTREAM-ID"];
                  }
                  if (entry.attributes.CHARACTERISTICS) {
                    rendition.characteristics = entry.attributes.CHARACTERISTICS;
                  }
                  if (entry.attributes.FORCED) {
                    rendition.forced = /yes/i.test(entry.attributes.FORCED);
                  }
                  mediaGroup[entry.attributes.NAME] = rendition;
                },
                discontinuity: function discontinuity() {
                  currentTimeline += 1;
                  currentUri.discontinuity = true;
                  this.manifest.discontinuityStarts.push(uris.length);
                },
                "program-date-time": function programDateTime() {
                  if (typeof this.manifest.dateTimeString === "undefined") {
                    this.manifest.dateTimeString = entry.dateTimeString;
                    this.manifest.dateTimeObject = entry.dateTimeObject;
                  }
                  currentUri.dateTimeString = entry.dateTimeString;
                  currentUri.dateTimeObject = entry.dateTimeObject;
                },
                targetduration: function targetduration() {
                  if (!isFinite(entry.duration) || entry.duration < 0) {
                    this.trigger("warn", {
                      message: "ignoring invalid target duration: " + entry.duration
                    });
                    return;
                  }
                  this.manifest.targetDuration = entry.duration;
                  setHoldBack.call(this, this.manifest);
                },
                start: function start2() {
                  if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                    this.trigger("warn", {
                      message: "ignoring start declaration without appropriate attribute list"
                    });
                    return;
                  }
                  this.manifest.start = {
                    timeOffset: entry.attributes["TIME-OFFSET"],
                    precise: entry.attributes.PRECISE
                  };
                },
                "cue-out": function cueOut() {
                  currentUri.cueOut = entry.data;
                },
                "cue-out-cont": function cueOutCont() {
                  currentUri.cueOutCont = entry.data;
                },
                "cue-in": function cueIn() {
                  currentUri.cueIn = entry.data;
                },
                "skip": function skip() {
                  this.manifest.skip = camelCaseKeys(entry.attributes);
                  this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, ["SKIPPED-SEGMENTS"]);
                },
                "part": function part() {
                  var _this2 = this;
                  hasParts = true;
                  var segmentIndex = this.manifest.segments.length;
                  var part2 = camelCaseKeys(entry.attributes);
                  currentUri.parts = currentUri.parts || [];
                  currentUri.parts.push(part2);
                  if (part2.byterange) {
                    if (!part2.byterange.hasOwnProperty("offset")) {
                      part2.byterange.offset = lastPartByterangeEnd;
                    }
                    lastPartByterangeEnd = part2.byterange.offset + part2.byterange.length;
                  }
                  var partIndex = currentUri.parts.length - 1;
                  this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ["URI", "DURATION"]);
                  if (this.manifest.renditionReports) {
                    this.manifest.renditionReports.forEach(function(r, i) {
                      if (!r.hasOwnProperty("lastPart")) {
                        _this2.trigger("warn", {
                          message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
                        });
                      }
                    });
                  }
                },
                "server-control": function serverControl() {
                  var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
                  if (!attrs.hasOwnProperty("canBlockReload")) {
                    attrs.canBlockReload = false;
                    this.trigger("info", {
                      message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                    });
                  }
                  setHoldBack.call(this, this.manifest);
                  if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) {
                    this.trigger("warn", {
                      message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                    });
                  }
                },
                "preload-hint": function preloadHint() {
                  var segmentIndex = this.manifest.segments.length;
                  var hint = camelCaseKeys(entry.attributes);
                  var isPart = hint.type && hint.type === "PART";
                  currentUri.preloadHints = currentUri.preloadHints || [];
                  currentUri.preloadHints.push(hint);
                  if (hint.byterange) {
                    if (!hint.byterange.hasOwnProperty("offset")) {
                      hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                      if (isPart) {
                        lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                      }
                    }
                  }
                  var index = currentUri.preloadHints.length - 1;
                  this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex, entry.attributes, ["TYPE", "URI"]);
                  if (!hint.type) {
                    return;
                  }
                  for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
                    var otherHint = currentUri.preloadHints[i];
                    if (!otherHint.type) {
                      continue;
                    }
                    if (otherHint.type === hint.type) {
                      this.trigger("warn", {
                        message: "#EXT-X-PRELOAD-HINT #" + index + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
                      });
                    }
                  }
                },
                "rendition-report": function renditionReport() {
                  var report = camelCaseKeys(entry.attributes);
                  this.manifest.renditionReports = this.manifest.renditionReports || [];
                  this.manifest.renditionReports.push(report);
                  var index = this.manifest.renditionReports.length - 1;
                  var required = ["LAST-MSN", "URI"];
                  if (hasParts) {
                    required.push("LAST-PART");
                  }
                  this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index, entry.attributes, required);
                },
                "part-inf": function partInf() {
                  this.manifest.partInf = camelCaseKeys(entry.attributes);
                  this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, ["PART-TARGET"]);
                  if (this.manifest.partInf.partTarget) {
                    this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
                  }
                  setHoldBack.call(this, this.manifest);
                }
              }[entry.tagType] || noop).call(self2);
            },
            uri: function uri() {
              currentUri.uri = entry.uri;
              uris.push(currentUri);
              if (this.manifest.targetDuration && !("duration" in currentUri)) {
                this.trigger("warn", {
                  message: "defaulting segment duration to the target duration"
                });
                currentUri.duration = this.manifest.targetDuration;
              }
              if (_key) {
                currentUri.key = _key;
              }
              currentUri.timeline = currentTimeline;
              if (currentMap) {
                currentUri.map = currentMap;
              }
              lastPartByterangeEnd = 0;
              currentUri = {};
            },
            comment: function comment() {
            },
            custom: function custom() {
              if (entry.segment) {
                currentUri.custom = currentUri.custom || {};
                currentUri.custom[entry.customType] = entry.data;
              } else {
                this.manifest.custom = this.manifest.custom || {};
                this.manifest.custom[entry.customType] = entry.data;
              }
            }
          })[entry.type].call(self2);
        });
        return _this;
      }
      var _proto = Parser2.prototype;
      _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier, attributes, required) {
        var missing = [];
        required.forEach(function(key) {
          if (!attributes.hasOwnProperty(key)) {
            missing.push(key);
          }
        });
        if (missing.length) {
          this.trigger("warn", {
            message: identifier + " lacks required attribute(s): " + missing.join(", ")
          });
        }
      };
      _proto.push = function push(chunk) {
        this.lineStream.push(chunk);
      };
      _proto.end = function end2() {
        this.lineStream.push("\n");
        this.trigger("end");
      };
      _proto.addParser = function addParser(options) {
        this.parseStream.addParser(options);
      };
      _proto.addTagMapper = function addTagMapper(options) {
        this.parseStream.addTagMapper(options);
      };
      return Parser2;
    }(Stream__default["default"]);
    exports.LineStream = LineStream;
    exports.ParseStream = ParseStream;
    exports.Parser = Parser;
  }
});

// node_modules/@videojs/vhs-utils/cjs/codecs.js
var require_codecs = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/codecs.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DEFAULT_VIDEO_CODEC = exports.DEFAULT_AUDIO_CODEC = exports.muxerSupportsCodec = exports.browserSupportsCodec = exports.getMimeForCodec = exports.isTextCodec = exports.isAudioCodec = exports.isVideoCodec = exports.codecsFromDefault = exports.parseCodecs = exports.mapLegacyAvcCodecs = exports.translateLegacyCodecs = exports.translateLegacyCodec = void 0;
    var _window = _interopRequireDefault(require_window());
    var regexs = {
      mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
      webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
      ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
      video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
      audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
      text: /^(stpp.ttml.im1t)/,
      muxerVideo: /^(avc0?1)/,
      muxerAudio: /^(mp4a)/,
      muxerText: /a^/
    };
    var mediaTypes = ["video", "audio", "text"];
    var upperMediaTypes = ["Video", "Audio", "Text"];
    var translateLegacyCodec = function translateLegacyCodec2(codec) {
      if (!codec) {
        return codec;
      }
      return codec.replace(/avc1\.(\d+)\.(\d+)/i, function(orig, profile, avcLevel) {
        var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
        var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
        return "avc1." + profileHex + "00" + avcLevelHex;
      });
    };
    exports.translateLegacyCodec = translateLegacyCodec;
    var translateLegacyCodecs = function translateLegacyCodecs2(codecs) {
      return codecs.map(translateLegacyCodec);
    };
    exports.translateLegacyCodecs = translateLegacyCodecs;
    var mapLegacyAvcCodecs = function mapLegacyAvcCodecs2(codecString) {
      return codecString.replace(/avc1\.(\d+)\.(\d+)/i, function(match) {
        return translateLegacyCodecs([match])[0];
      });
    };
    exports.mapLegacyAvcCodecs = mapLegacyAvcCodecs;
    var parseCodecs = function parseCodecs2(codecString) {
      if (codecString === void 0) {
        codecString = "";
      }
      var codecs = codecString.split(",");
      var result = [];
      codecs.forEach(function(codec) {
        codec = codec.trim();
        var codecType;
        mediaTypes.forEach(function(name) {
          var match = regexs[name].exec(codec.toLowerCase());
          if (!match || match.length <= 1) {
            return;
          }
          codecType = name;
          var type = codec.substring(0, match[1].length);
          var details = codec.replace(type, "");
          result.push({
            type,
            details,
            mediaType: name
          });
        });
        if (!codecType) {
          result.push({
            type: codec,
            details: "",
            mediaType: "unknown"
          });
        }
      });
      return result;
    };
    exports.parseCodecs = parseCodecs;
    var codecsFromDefault = function codecsFromDefault2(master, audioGroupId) {
      if (!master.mediaGroups.AUDIO || !audioGroupId) {
        return null;
      }
      var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
      if (!audioGroup) {
        return null;
      }
      for (var name in audioGroup) {
        var audioType = audioGroup[name];
        if (audioType.default && audioType.playlists) {
          return parseCodecs(audioType.playlists[0].attributes.CODECS);
        }
      }
      return null;
    };
    exports.codecsFromDefault = codecsFromDefault;
    var isVideoCodec = function isVideoCodec2(codec) {
      if (codec === void 0) {
        codec = "";
      }
      return regexs.video.test(codec.trim().toLowerCase());
    };
    exports.isVideoCodec = isVideoCodec;
    var isAudioCodec = function isAudioCodec2(codec) {
      if (codec === void 0) {
        codec = "";
      }
      return regexs.audio.test(codec.trim().toLowerCase());
    };
    exports.isAudioCodec = isAudioCodec;
    var isTextCodec = function isTextCodec2(codec) {
      if (codec === void 0) {
        codec = "";
      }
      return regexs.text.test(codec.trim().toLowerCase());
    };
    exports.isTextCodec = isTextCodec;
    var getMimeForCodec = function getMimeForCodec2(codecString) {
      if (!codecString || typeof codecString !== "string") {
        return;
      }
      var codecs = codecString.toLowerCase().split(",").map(function(c) {
        return translateLegacyCodec(c.trim());
      });
      var type = "video";
      if (codecs.length === 1 && isAudioCodec(codecs[0])) {
        type = "audio";
      } else if (codecs.length === 1 && isTextCodec(codecs[0])) {
        type = "application";
      }
      var container = "mp4";
      if (codecs.every(function(c) {
        return regexs.mp4.test(c);
      })) {
        container = "mp4";
      } else if (codecs.every(function(c) {
        return regexs.webm.test(c);
      })) {
        container = "webm";
      } else if (codecs.every(function(c) {
        return regexs.ogg.test(c);
      })) {
        container = "ogg";
      }
      return type + "/" + container + ';codecs="' + codecString + '"';
    };
    exports.getMimeForCodec = getMimeForCodec;
    var browserSupportsCodec = function browserSupportsCodec2(codecString) {
      if (codecString === void 0) {
        codecString = "";
      }
      return _window.default.MediaSource && _window.default.MediaSource.isTypeSupported && _window.default.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
    };
    exports.browserSupportsCodec = browserSupportsCodec;
    var muxerSupportsCodec = function muxerSupportsCodec2(codecString) {
      if (codecString === void 0) {
        codecString = "";
      }
      return codecString.toLowerCase().split(",").every(function(codec) {
        codec = codec.trim();
        for (var i = 0; i < upperMediaTypes.length; i++) {
          var type = upperMediaTypes[i];
          if (regexs["muxer" + type].test(codec)) {
            return true;
          }
        }
        return false;
      });
    };
    exports.muxerSupportsCodec = muxerSupportsCodec;
    var DEFAULT_AUDIO_CODEC = "mp4a.40.2";
    exports.DEFAULT_AUDIO_CODEC = DEFAULT_AUDIO_CODEC;
    var DEFAULT_VIDEO_CODEC = "avc1.4d400d";
    exports.DEFAULT_VIDEO_CODEC = DEFAULT_VIDEO_CODEC;
  }
});

// node_modules/@videojs/vhs-utils/cjs/media-types.js
var require_media_types = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/media-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.simpleTypeFromSourceType = void 0;
    var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
    var DASH_REGEX = /^application\/dash\+xml/i;
    var simpleTypeFromSourceType = function simpleTypeFromSourceType2(type) {
      if (MPEGURL_REGEX.test(type)) {
        return "hls";
      }
      if (DASH_REGEX.test(type)) {
        return "dash";
      }
      if (type === "application/vnd.videojs.vhs+json") {
        return "vhs-json";
      }
      return null;
    };
    exports.simpleTypeFromSourceType = simpleTypeFromSourceType;
  }
});

// node_modules/@videojs/vhs-utils/cjs/byte-helpers.js
var require_byte_helpers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/byte-helpers.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reverseBytes = exports.sliceBytes = exports.bytesMatch = exports.concatTypedArrays = exports.stringToBytes = exports.bytesToString = exports.numberToBytes = exports.bytesToNumber = exports.IS_LITTLE_ENDIAN = exports.IS_BIG_ENDIAN = exports.ENDIANNESS = exports.toBinaryString = exports.toHexString = exports.toUint8 = exports.isTypedArray = exports.isArrayBufferView = exports.padStart = exports.countBytes = exports.countBits = void 0;
    var _window = _interopRequireDefault(require_window());
    var repeat = function repeat2(str, len) {
      var acc = "";
      while (len--) {
        acc += str;
      }
      return acc;
    };
    var countBits = function countBits2(x) {
      return x.toString(2).length;
    };
    exports.countBits = countBits;
    var countBytes = function countBytes2(x) {
      return Math.ceil(countBits(x) / 8);
    };
    exports.countBytes = countBytes;
    var padStart = function padStart2(b, len, str) {
      if (str === void 0) {
        str = " ";
      }
      return (repeat(str, len) + b.toString()).slice(-len);
    };
    exports.padStart = padStart;
    var isArrayBufferView = function isArrayBufferView2(obj2) {
      if (ArrayBuffer.isView === "function") {
        return ArrayBuffer.isView(obj2);
      }
      return obj2 && obj2.buffer instanceof ArrayBuffer;
    };
    exports.isArrayBufferView = isArrayBufferView;
    var isTypedArray = function isTypedArray2(obj2) {
      return isArrayBufferView(obj2);
    };
    exports.isTypedArray = isTypedArray;
    var toUint8 = function toUint82(bytes) {
      if (bytes instanceof Uint8Array) {
        return bytes;
      }
      if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {
        if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) {
          bytes = 0;
        } else {
          bytes = [bytes];
        }
      }
      return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
    };
    exports.toUint8 = toUint8;
    var toHexString = function toHexString2(bytes) {
      bytes = toUint8(bytes);
      var str = "";
      for (var i = 0; i < bytes.length; i++) {
        str += padStart(bytes[i].toString(16), 2, "0");
      }
      return str;
    };
    exports.toHexString = toHexString;
    var toBinaryString = function toBinaryString2(bytes) {
      bytes = toUint8(bytes);
      var str = "";
      for (var i = 0; i < bytes.length; i++) {
        str += padStart(bytes[i].toString(2), 8, "0");
      }
      return str;
    };
    exports.toBinaryString = toBinaryString;
    var BigInt = _window.default.BigInt || Number;
    var BYTE_TABLE = [BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000")];
    var ENDIANNESS = function() {
      var a = new Uint16Array([65484]);
      var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
      if (b[0] === 255) {
        return "big";
      }
      if (b[0] === 204) {
        return "little";
      }
      return "unknown";
    }();
    exports.ENDIANNESS = ENDIANNESS;
    var IS_BIG_ENDIAN = ENDIANNESS === "big";
    exports.IS_BIG_ENDIAN = IS_BIG_ENDIAN;
    var IS_LITTLE_ENDIAN = ENDIANNESS === "little";
    exports.IS_LITTLE_ENDIAN = IS_LITTLE_ENDIAN;
    var bytesToNumber = function bytesToNumber2(bytes, _temp) {
      var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le = _ref$le === void 0 ? false : _ref$le;
      bytes = toUint8(bytes);
      var fn = le ? "reduce" : "reduceRight";
      var obj2 = bytes[fn] ? bytes[fn] : Array.prototype[fn];
      var number = obj2.call(bytes, function(total, byte, i) {
        var exponent = le ? i : Math.abs(i + 1 - bytes.length);
        return total + BigInt(byte) * BYTE_TABLE[exponent];
      }, BigInt(0));
      if (signed) {
        var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);
        number = BigInt(number);
        if (number > max) {
          number -= max;
          number -= max;
          number -= BigInt(2);
        }
      }
      return Number(number);
    };
    exports.bytesToNumber = bytesToNumber;
    var numberToBytes = function numberToBytes2(number, _temp2) {
      var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le = _ref2$le === void 0 ? false : _ref2$le;
      if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) {
        number = 0;
      }
      number = BigInt(number);
      var byteCount = countBytes(number);
      var bytes = new Uint8Array(new ArrayBuffer(byteCount));
      for (var i = 0; i < byteCount; i++) {
        var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
        bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(255));
        if (number < 0) {
          bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
          bytes[byteIndex] -= i === 0 ? 1 : 2;
        }
      }
      return bytes;
    };
    exports.numberToBytes = numberToBytes;
    var bytesToString = function bytesToString2(bytes) {
      if (!bytes) {
        return "";
      }
      bytes = Array.prototype.slice.call(bytes);
      var string = String.fromCharCode.apply(null, toUint8(bytes));
      try {
        return decodeURIComponent(escape(string));
      } catch (e) {
      }
      return string;
    };
    exports.bytesToString = bytesToString;
    var stringToBytes = function stringToBytes2(string, stringIsBytes) {
      if (typeof string !== "string" && string && typeof string.toString === "function") {
        string = string.toString();
      }
      if (typeof string !== "string") {
        return new Uint8Array();
      }
      if (!stringIsBytes) {
        string = unescape(encodeURIComponent(string));
      }
      var view = new Uint8Array(string.length);
      for (var i = 0; i < string.length; i++) {
        view[i] = string.charCodeAt(i);
      }
      return view;
    };
    exports.stringToBytes = stringToBytes;
    var concatTypedArrays = function concatTypedArrays2() {
      for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
        buffers[_key] = arguments[_key];
      }
      buffers = buffers.filter(function(b) {
        return b && (b.byteLength || b.length) && typeof b !== "string";
      });
      if (buffers.length <= 1) {
        return toUint8(buffers[0]);
      }
      var totalLen = buffers.reduce(function(total, buf, i) {
        return total + (buf.byteLength || buf.length);
      }, 0);
      var tempBuffer = new Uint8Array(totalLen);
      var offset = 0;
      buffers.forEach(function(buf) {
        buf = toUint8(buf);
        tempBuffer.set(buf, offset);
        offset += buf.byteLength;
      });
      return tempBuffer;
    };
    exports.concatTypedArrays = concatTypedArrays;
    var bytesMatch = function bytesMatch2(a, b, _temp3) {
      var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
      a = toUint8(a);
      b = toUint8(b);
      var fn = b.every ? b.every : Array.prototype.every;
      return b.length && a.length - offset >= b.length && fn.call(b, function(bByte, i) {
        var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];
        return bByte === aByte;
      });
    };
    exports.bytesMatch = bytesMatch;
    var sliceBytes = function sliceBytes2(src, start2, end2) {
      if (Uint8Array.prototype.slice) {
        return Uint8Array.prototype.slice.call(src, start2, end2);
      }
      return new Uint8Array(Array.prototype.slice.call(src, start2, end2));
    };
    exports.sliceBytes = sliceBytes;
    var reverseBytes = function reverseBytes2(src) {
      if (src.reverse) {
        return src.reverse();
      }
      return Array.prototype.reverse.call(src);
    };
    exports.reverseBytes = reverseBytes;
  }
});

// node_modules/@videojs/vhs-utils/cjs/media-groups.js
var require_media_groups = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/media-groups.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forEachMediaGroup = void 0;
    var forEachMediaGroup = function forEachMediaGroup2(master, groups, callback) {
      groups.forEach(function(mediaType) {
        for (var groupKey in master.mediaGroups[mediaType]) {
          for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
            var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
            callback(mediaProperties, mediaType, groupKey, labelKey);
          }
        }
      });
    };
    exports.forEachMediaGroup = forEachMediaGroup;
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      HTML: "text/html",
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.assign = assign;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input)
        return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message)
        this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      length: 0,
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      hasFeature: function(feature, version2) {
        return true;
      },
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      isSupported: function(feature, version2) {
        return this.ownerDocument.implementation.hasFeature(feature, version2);
      },
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (!hasInsertableNodeType(node) || isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start2 = this.data.substring(0, offset);
        var end2 = this.data.substring(offset + count);
        text = start2 + text + end2;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end3) {
        if (end3 > start2) {
          var xt = source.substring(start2, end3).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start2);
          domBuilder.characters(xt, 0, end3 - start2);
          start2 = end3;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start2 = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start2);
          if (tagStart < 0) {
            if (!source.substr(start2).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start2));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start2) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end2 = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end2).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end2 < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end2 = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end2 = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end2++;
              break;
            case "?":
              locator && position(tagStart);
              end2 = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end2 = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end2 = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end2, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end2 = parseHtmlSpecialContent(source, end2, el.tagName, entityReplacer, domBuilder);
              } else {
                end2++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end2 = -1;
        }
        if (end2 > start2) {
          start2 = end2;
        } else {
          appendText(Math.max(tagStart, start2) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start2, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(qname, value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer), startIndex);
      }
      var attrName;
      var value;
      var p = ++start2;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start2, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start2, p);
              }
              start2 = p + 1;
              p = source.indexOf(c, start2);
              if (p > 0) {
                value = source.slice(start2, p);
                addAttribute(attrName, value, start2 - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start2, p);
              addAttribute(attrName, value, start2);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start2 = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start2, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start2, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                value = source.slice(start2, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start2);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start2);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          case "\x80":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start2, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start2, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start2, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start2);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start2);
                  start2 = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start2 = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start2 = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start2, domBuilder, errorHandler) {
      var next = source.charAt(start2 + 2);
      switch (next) {
        case "-":
          if (source.charAt(start2 + 3) === "-") {
            var end2 = source.indexOf("-->", start2 + 4);
            if (end2 > start2) {
              domBuilder.comment(source, start2 + 4, end2 - start2 - 4);
              return end2 + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start2 + 3, 6) == "CDATA[") {
            var end2 = source.indexOf("]]>", start2 + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start2 + 9, end2 - start2 - 9);
            domBuilder.endCDATA();
            return end2 + 3;
          }
          var matchs = split(source, start2);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start2, domBuilder) {
      var end2 = source.indexOf("?>", start2);
      if (end2) {
        var match = source.substring(start2, end2).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end2 + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
    };
    function split(source, start2) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start2;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1])
          return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser(options) {
      this.options = options || { locator: {} };
    }
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(normalize(source), defaultNSMap, entityMap);
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start2, length) {
      },
      characters: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      comment: function(chars, start2, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start2, length) {
      if (typeof chars == "string") {
        return chars.substr(start2, length);
      } else {
        if (chars.length >= start2 + length || start2) {
          return new java.lang.String(chars, start2, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.normalizeLineEndings = normalizeLineEndings;
    exports.DOMParser = DOMParser;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/mpd-parser/dist/mpd-parser.cjs.js
var require_mpd_parser_cjs = __commonJS({
  "node_modules/mpd-parser/dist/mpd-parser.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolveUrl = require_resolve_url();
    var window3 = require_window();
    var mediaGroups = require_media_groups();
    var decodeB64ToUint8Array = require_decode_b64_to_uint8_array();
    var xmldom = require_lib2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var resolveUrl__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUrl);
    var window__default = /* @__PURE__ */ _interopDefaultLegacy(window3);
    var decodeB64ToUint8Array__default = /* @__PURE__ */ _interopDefaultLegacy(decodeB64ToUint8Array);
    var version2 = "0.22.1";
    var isObject = function isObject2(obj2) {
      return !!obj2 && typeof obj2 === "object";
    };
    var merge = function merge2() {
      for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }
      return objects.reduce(function(result, source) {
        if (typeof source !== "object") {
          return result;
        }
        Object.keys(source).forEach(function(key) {
          if (Array.isArray(result[key]) && Array.isArray(source[key])) {
            result[key] = result[key].concat(source[key]);
          } else if (isObject(result[key]) && isObject(source[key])) {
            result[key] = merge2(result[key], source[key]);
          } else {
            result[key] = source[key];
          }
        });
        return result;
      }, {});
    };
    var values = function values2(o) {
      return Object.keys(o).map(function(k) {
        return o[k];
      });
    };
    var range = function range2(start2, end2) {
      var result = [];
      for (var i = start2; i < end2; i++) {
        result.push(i);
      }
      return result;
    };
    var flatten = function flatten2(lists) {
      return lists.reduce(function(x, y) {
        return x.concat(y);
      }, []);
    };
    var from = function from2(list) {
      if (!list.length) {
        return [];
      }
      var result = [];
      for (var i = 0; i < list.length; i++) {
        result.push(list[i]);
      }
      return result;
    };
    var findIndexes = function findIndexes2(l, key) {
      return l.reduce(function(a, e, i) {
        if (e[key]) {
          a.push(i);
        }
        return a;
      }, []);
    };
    var findIndex = function findIndex2(list, matchingFunction) {
      for (var i = 0; i < list.length; i++) {
        if (matchingFunction(list[i])) {
          return i;
        }
      }
      return -1;
    };
    var union = function union2(lists, keyFunction) {
      return values(lists.reduce(function(acc, list) {
        list.forEach(function(el) {
          acc[keyFunction(el)] = el;
        });
        return acc;
      }, {}));
    };
    var errors = {
      INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
      DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
      DASH_INVALID_XML: "DASH_INVALID_XML",
      NO_BASE_URL: "NO_BASE_URL",
      MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
      SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
      UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
    };
    var urlTypeToSegment = function urlTypeToSegment2(_ref) {
      var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? "" : _ref$baseUrl, _ref$source = _ref.source, source = _ref$source === void 0 ? "" : _ref$source, _ref$range = _ref.range, range2 = _ref$range === void 0 ? "" : _ref$range, _ref$indexRange = _ref.indexRange, indexRange = _ref$indexRange === void 0 ? "" : _ref$indexRange;
      var segment = {
        uri: source,
        resolvedUri: resolveUrl__default["default"](baseUrl || "", source)
      };
      if (range2 || indexRange) {
        var rangeStr = range2 ? range2 : indexRange;
        var ranges = rangeStr.split("-");
        var startRange = window__default["default"].BigInt ? window__default["default"].BigInt(ranges[0]) : parseInt(ranges[0], 10);
        var endRange = window__default["default"].BigInt ? window__default["default"].BigInt(ranges[1]) : parseInt(ranges[1], 10);
        if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") {
          startRange = Number(startRange);
        }
        if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") {
          endRange = Number(endRange);
        }
        var length;
        if (typeof endRange === "bigint" || typeof startRange === "bigint") {
          length = window__default["default"].BigInt(endRange) - window__default["default"].BigInt(startRange) + window__default["default"].BigInt(1);
        } else {
          length = endRange - startRange + 1;
        }
        if (typeof length === "bigint" && length < Number.MAX_SAFE_INTEGER) {
          length = Number(length);
        }
        segment.byterange = {
          length,
          offset: startRange
        };
      }
      return segment;
    };
    var byteRangeToString = function byteRangeToString2(byterange) {
      var endRange;
      if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
        endRange = window__default["default"].BigInt(byterange.offset) + window__default["default"].BigInt(byterange.length) - window__default["default"].BigInt(1);
      } else {
        endRange = byterange.offset + byterange.length - 1;
      }
      return byterange.offset + "-" + endRange;
    };
    var parseEndNumber = function parseEndNumber2(endNumber) {
      if (endNumber && typeof endNumber !== "number") {
        endNumber = parseInt(endNumber, 10);
      }
      if (isNaN(endNumber)) {
        return null;
      }
      return endNumber;
    };
    var segmentRange = {
      static: function _static(attributes) {
        var duration = attributes.duration, _attributes$timescale = attributes.timescale, timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale, sourceDuration = attributes.sourceDuration, periodDuration = attributes.periodDuration;
        var endNumber = parseEndNumber(attributes.endNumber);
        var segmentDuration = duration / timescale;
        if (typeof endNumber === "number") {
          return {
            start: 0,
            end: endNumber
          };
        }
        if (typeof periodDuration === "number") {
          return {
            start: 0,
            end: periodDuration / segmentDuration
          };
        }
        return {
          start: 0,
          end: sourceDuration / segmentDuration
        };
      },
      dynamic: function dynamic(attributes) {
        var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime = attributes.availabilityStartTime, _attributes$timescale2 = attributes.timescale, timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, duration = attributes.duration, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp, _attributes$timeShift = attributes.timeShiftBufferDepth, timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;
        var endNumber = parseEndNumber(attributes.endNumber);
        var now = (NOW + clientOffset) / 1e3;
        var periodStartWC = availabilityStartTime + periodStart;
        var periodEndWC = now + minimumUpdatePeriod;
        var periodDuration = periodEndWC - periodStartWC;
        var segmentCount = Math.ceil(periodDuration * timescale / duration);
        var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);
        var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);
        return {
          start: Math.max(0, availableStart),
          end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
        };
      }
    };
    var toSegments = function toSegments2(attributes) {
      return function(number) {
        var duration = attributes.duration, _attributes$timescale3 = attributes.timescale, timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3, periodStart = attributes.periodStart, _attributes$startNumb = attributes.startNumber, startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;
        return {
          number: startNumber + number,
          duration: duration / timescale,
          timeline: periodStart,
          time: number * duration
        };
      };
    };
    var parseByDuration = function parseByDuration2(attributes) {
      var type = attributes.type, duration = attributes.duration, _attributes$timescale4 = attributes.timescale, timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4, periodDuration = attributes.periodDuration, sourceDuration = attributes.sourceDuration;
      var _segmentRange$type = segmentRange[type](attributes), start2 = _segmentRange$type.start, end2 = _segmentRange$type.end;
      var segments = range(start2, end2).map(toSegments(attributes));
      if (type === "static") {
        var index = segments.length - 1;
        var sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
        segments[index].duration = sectionDuration - duration / timescale * index;
      }
      return segments;
    };
    var segmentsFromBase = function segmentsFromBase2(attributes) {
      var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ, sourceDuration = attributes.sourceDuration, _attributes$indexRang = attributes.indexRange, indexRange = _attributes$indexRang === void 0 ? "" : _attributes$indexRang, periodStart = attributes.periodStart, presentationTime = attributes.presentationTime, _attributes$number = attributes.number, number = _attributes$number === void 0 ? 0 : _attributes$number, duration = attributes.duration;
      if (!baseUrl) {
        throw new Error(errors.NO_BASE_URL);
      }
      var initSegment = urlTypeToSegment({
        baseUrl,
        source: initialization.sourceURL,
        range: initialization.range
      });
      var segment = urlTypeToSegment({
        baseUrl,
        source: baseUrl,
        indexRange
      });
      segment.map = initSegment;
      if (duration) {
        var segmentTimeInfo = parseByDuration(attributes);
        if (segmentTimeInfo.length) {
          segment.duration = segmentTimeInfo[0].duration;
          segment.timeline = segmentTimeInfo[0].timeline;
        }
      } else if (sourceDuration) {
        segment.duration = sourceDuration;
        segment.timeline = periodStart;
      }
      segment.presentationTime = presentationTime || periodStart;
      segment.number = number;
      return [segment];
    };
    var addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist2(playlist, sidx, baseUrl) {
      var initSegment = playlist.sidx.map ? playlist.sidx.map : null;
      var sourceDuration = playlist.sidx.duration;
      var timeline = playlist.timeline || 0;
      var sidxByteRange = playlist.sidx.byterange;
      var sidxEnd = sidxByteRange.offset + sidxByteRange.length;
      var timescale = sidx.timescale;
      var mediaReferences = sidx.references.filter(function(r) {
        return r.referenceType !== 1;
      });
      var segments = [];
      var type = playlist.endList ? "static" : "dynamic";
      var periodStart = playlist.sidx.timeline;
      var presentationTime = periodStart;
      var number = playlist.mediaSequence || 0;
      var startIndex;
      if (typeof sidx.firstOffset === "bigint") {
        startIndex = window__default["default"].BigInt(sidxEnd) + sidx.firstOffset;
      } else {
        startIndex = sidxEnd + sidx.firstOffset;
      }
      for (var i = 0; i < mediaReferences.length; i++) {
        var reference = sidx.references[i];
        var size = reference.referencedSize;
        var duration = reference.subsegmentDuration;
        var endIndex = void 0;
        if (typeof startIndex === "bigint") {
          endIndex = startIndex + window__default["default"].BigInt(size) - window__default["default"].BigInt(1);
        } else {
          endIndex = startIndex + size - 1;
        }
        var indexRange = startIndex + "-" + endIndex;
        var attributes = {
          baseUrl,
          timescale,
          timeline,
          periodStart,
          presentationTime,
          number,
          duration,
          sourceDuration,
          indexRange,
          type
        };
        var segment = segmentsFromBase(attributes)[0];
        if (initSegment) {
          segment.map = initSegment;
        }
        segments.push(segment);
        if (typeof startIndex === "bigint") {
          startIndex += window__default["default"].BigInt(size);
        } else {
          startIndex += size;
        }
        presentationTime += duration / timescale;
        number++;
      }
      playlist.segments = segments;
      return playlist;
    };
    var SUPPORTED_MEDIA_TYPES = ["AUDIO", "SUBTITLES"];
    var TIME_FUDGE = 1 / 60;
    var getUniqueTimelineStarts = function getUniqueTimelineStarts2(timelineStarts) {
      return union(timelineStarts, function(_ref) {
        var timeline = _ref.timeline;
        return timeline;
      }).sort(function(a, b) {
        return a.timeline > b.timeline ? 1 : -1;
      });
    };
    var findPlaylistWithName = function findPlaylistWithName2(playlists, name) {
      for (var i = 0; i < playlists.length; i++) {
        if (playlists[i].attributes.NAME === name) {
          return playlists[i];
        }
      }
      return null;
    };
    var getMediaGroupPlaylists = function getMediaGroupPlaylists2(manifest) {
      var mediaGroupPlaylists = [];
      mediaGroups.forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, function(properties, type, group, label) {
        mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
      });
      return mediaGroupPlaylists;
    };
    var updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist2(_ref2) {
      var playlist = _ref2.playlist, mediaSequence = _ref2.mediaSequence;
      playlist.mediaSequence = mediaSequence;
      playlist.segments.forEach(function(segment, index) {
        segment.number = playlist.mediaSequence + index;
      });
    };
    var updateSequenceNumbers = function updateSequenceNumbers2(_ref3) {
      var oldPlaylists = _ref3.oldPlaylists, newPlaylists = _ref3.newPlaylists, timelineStarts = _ref3.timelineStarts;
      newPlaylists.forEach(function(playlist) {
        playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref4) {
          var timeline = _ref4.timeline;
          return timeline === playlist.timeline;
        });
        var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
        if (!oldPlaylist) {
          return;
        }
        if (playlist.sidx) {
          return;
        }
        var firstNewSegment = playlist.segments[0];
        var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function(oldSegment) {
          return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
        });
        if (oldMatchingSegmentIndex === -1) {
          updateMediaSequenceForPlaylist({
            playlist,
            mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
          });
          playlist.segments[0].discontinuity = true;
          playlist.discontinuityStarts.unshift(0);
          if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {
            playlist.discontinuitySequence--;
          }
          return;
        }
        var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
        if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
          firstNewSegment.discontinuity = true;
          playlist.discontinuityStarts.unshift(0);
          playlist.discontinuitySequence--;
        }
        updateMediaSequenceForPlaylist({
          playlist,
          mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
        });
      });
    };
    var positionManifestOnTimeline = function positionManifestOnTimeline2(_ref5) {
      var oldManifest = _ref5.oldManifest, newManifest = _ref5.newManifest;
      var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
      var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
      newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);
      updateSequenceNumbers({
        oldPlaylists,
        newPlaylists,
        timelineStarts: newManifest.timelineStarts
      });
      return newManifest;
    };
    var generateSidxKey = function generateSidxKey2(sidx) {
      return sidx && sidx.uri + "-" + byteRangeToString(sidx.byterange);
    };
    var mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists2(playlists) {
      var mergedPlaylists = values(playlists.reduce(function(acc, playlist) {
        var name = playlist.attributes.id + (playlist.attributes.lang || "");
        if (!acc[name]) {
          acc[name] = playlist;
          acc[name].attributes.timelineStarts = [];
        } else {
          if (playlist.segments) {
            var _acc$name$segments;
            if (playlist.segments[0]) {
              playlist.segments[0].discontinuity = true;
            }
            (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);
          }
          if (playlist.attributes.contentProtection) {
            acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
          }
        }
        acc[name].attributes.timelineStarts.push({
          start: playlist.attributes.periodStart,
          timeline: playlist.attributes.periodStart
        });
        return acc;
      }, {}));
      return mergedPlaylists.map(function(playlist) {
        playlist.discontinuityStarts = findIndexes(playlist.segments || [], "discontinuity");
        return playlist;
      });
    };
    var addSidxSegmentsToPlaylist = function addSidxSegmentsToPlaylist2(playlist, sidxMapping) {
      var sidxKey = generateSidxKey(playlist.sidx);
      var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
      if (sidxMatch) {
        addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
      }
      return playlist;
    };
    var addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists2(playlists, sidxMapping) {
      if (sidxMapping === void 0) {
        sidxMapping = {};
      }
      if (!Object.keys(sidxMapping).length) {
        return playlists;
      }
      for (var i in playlists) {
        playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);
      }
      return playlists;
    };
    var formatAudioPlaylist = function formatAudioPlaylist2(_ref, isAudioOnly) {
      var _attributes;
      var attributes = _ref.attributes, segments = _ref.segments, sidx = _ref.sidx, mediaSequence = _ref.mediaSequence, discontinuitySequence = _ref.discontinuitySequence, discontinuityStarts = _ref.discontinuityStarts;
      var playlist = {
        attributes: (_attributes = {
          NAME: attributes.id,
          BANDWIDTH: attributes.bandwidth,
          CODECS: attributes.codecs
        }, _attributes["PROGRAM-ID"] = 1, _attributes),
        uri: "",
        endList: attributes.type === "static",
        timeline: attributes.periodStart,
        resolvedUri: "",
        targetDuration: attributes.duration,
        discontinuitySequence,
        discontinuityStarts,
        timelineStarts: attributes.timelineStarts,
        mediaSequence,
        segments
      };
      if (attributes.contentProtection) {
        playlist.contentProtection = attributes.contentProtection;
      }
      if (sidx) {
        playlist.sidx = sidx;
      }
      if (isAudioOnly) {
        playlist.attributes.AUDIO = "audio";
        playlist.attributes.SUBTITLES = "subs";
      }
      return playlist;
    };
    var formatVttPlaylist = function formatVttPlaylist2(_ref2) {
      var _m3u8Attributes;
      var attributes = _ref2.attributes, segments = _ref2.segments, mediaSequence = _ref2.mediaSequence, discontinuityStarts = _ref2.discontinuityStarts, discontinuitySequence = _ref2.discontinuitySequence;
      if (typeof segments === "undefined") {
        segments = [{
          uri: attributes.baseUrl,
          timeline: attributes.periodStart,
          resolvedUri: attributes.baseUrl || "",
          duration: attributes.sourceDuration,
          number: 0
        }];
        attributes.duration = attributes.sourceDuration;
      }
      var m3u8Attributes = (_m3u8Attributes = {
        NAME: attributes.id,
        BANDWIDTH: attributes.bandwidth
      }, _m3u8Attributes["PROGRAM-ID"] = 1, _m3u8Attributes);
      if (attributes.codecs) {
        m3u8Attributes.CODECS = attributes.codecs;
      }
      return {
        attributes: m3u8Attributes,
        uri: "",
        endList: attributes.type === "static",
        timeline: attributes.periodStart,
        resolvedUri: attributes.baseUrl || "",
        targetDuration: attributes.duration,
        timelineStarts: attributes.timelineStarts,
        discontinuityStarts,
        discontinuitySequence,
        mediaSequence,
        segments
      };
    };
    var organizeAudioPlaylists = function organizeAudioPlaylists2(playlists, sidxMapping, isAudioOnly) {
      if (sidxMapping === void 0) {
        sidxMapping = {};
      }
      if (isAudioOnly === void 0) {
        isAudioOnly = false;
      }
      var mainPlaylist;
      var formattedPlaylists = playlists.reduce(function(a, playlist) {
        var role = playlist.attributes.role && playlist.attributes.role.value || "";
        var language = playlist.attributes.lang || "";
        var label = playlist.attributes.label || "main";
        if (language && !playlist.attributes.label) {
          var roleLabel = role ? " (" + role + ")" : "";
          label = "" + playlist.attributes.lang + roleLabel;
        }
        if (!a[label]) {
          a[label] = {
            language,
            autoselect: true,
            default: role === "main",
            playlists: [],
            uri: ""
          };
        }
        var formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);
        a[label].playlists.push(formatted);
        if (typeof mainPlaylist === "undefined" && role === "main") {
          mainPlaylist = playlist;
          mainPlaylist.default = true;
        }
        return a;
      }, {});
      if (!mainPlaylist) {
        var firstLabel = Object.keys(formattedPlaylists)[0];
        formattedPlaylists[firstLabel].default = true;
      }
      return formattedPlaylists;
    };
    var organizeVttPlaylists = function organizeVttPlaylists2(playlists, sidxMapping) {
      if (sidxMapping === void 0) {
        sidxMapping = {};
      }
      return playlists.reduce(function(a, playlist) {
        var label = playlist.attributes.lang || "text";
        if (!a[label]) {
          a[label] = {
            language: label,
            default: false,
            autoselect: false,
            playlists: [],
            uri: ""
          };
        }
        a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));
        return a;
      }, {});
    };
    var organizeCaptionServices = function organizeCaptionServices2(captionServices) {
      return captionServices.reduce(function(svcObj, svc) {
        if (!svc) {
          return svcObj;
        }
        svc.forEach(function(service) {
          var channel = service.channel, language = service.language;
          svcObj[language] = {
            autoselect: false,
            default: false,
            instreamId: channel,
            language
          };
          if (service.hasOwnProperty("aspectRatio")) {
            svcObj[language].aspectRatio = service.aspectRatio;
          }
          if (service.hasOwnProperty("easyReader")) {
            svcObj[language].easyReader = service.easyReader;
          }
          if (service.hasOwnProperty("3D")) {
            svcObj[language]["3D"] = service["3D"];
          }
        });
        return svcObj;
      }, {});
    };
    var formatVideoPlaylist = function formatVideoPlaylist2(_ref3) {
      var _attributes2;
      var attributes = _ref3.attributes, segments = _ref3.segments, sidx = _ref3.sidx, discontinuityStarts = _ref3.discontinuityStarts;
      var playlist = {
        attributes: (_attributes2 = {
          NAME: attributes.id,
          AUDIO: "audio",
          SUBTITLES: "subs",
          RESOLUTION: {
            width: attributes.width,
            height: attributes.height
          },
          CODECS: attributes.codecs,
          BANDWIDTH: attributes.bandwidth
        }, _attributes2["PROGRAM-ID"] = 1, _attributes2),
        uri: "",
        endList: attributes.type === "static",
        timeline: attributes.periodStart,
        resolvedUri: "",
        targetDuration: attributes.duration,
        discontinuityStarts,
        timelineStarts: attributes.timelineStarts,
        segments
      };
      if (attributes.frameRate) {
        playlist.attributes["FRAME-RATE"] = attributes.frameRate;
      }
      if (attributes.contentProtection) {
        playlist.contentProtection = attributes.contentProtection;
      }
      if (sidx) {
        playlist.sidx = sidx;
      }
      return playlist;
    };
    var videoOnly = function videoOnly2(_ref4) {
      var attributes = _ref4.attributes;
      return attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
    };
    var audioOnly = function audioOnly2(_ref5) {
      var attributes = _ref5.attributes;
      return attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
    };
    var vttOnly = function vttOnly2(_ref6) {
      var attributes = _ref6.attributes;
      return attributes.mimeType === "text/vtt" || attributes.contentType === "text";
    };
    var addMediaSequenceValues = function addMediaSequenceValues2(playlists, timelineStarts) {
      playlists.forEach(function(playlist) {
        playlist.mediaSequence = 0;
        playlist.discontinuitySequence = findIndex(timelineStarts, function(_ref7) {
          var timeline = _ref7.timeline;
          return timeline === playlist.timeline;
        });
        if (!playlist.segments) {
          return;
        }
        playlist.segments.forEach(function(segment, index) {
          segment.number = index;
        });
      });
    };
    var flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists2(mediaGroupObject) {
      if (!mediaGroupObject) {
        return [];
      }
      return Object.keys(mediaGroupObject).reduce(function(acc, label) {
        var labelContents = mediaGroupObject[label];
        return acc.concat(labelContents.playlists);
      }, []);
    };
    var toM3u8 = function toM3u82(_ref8) {
      var _mediaGroups;
      var dashPlaylists = _ref8.dashPlaylists, locations = _ref8.locations, _ref8$sidxMapping = _ref8.sidxMapping, sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping, previousManifest = _ref8.previousManifest;
      if (!dashPlaylists.length) {
        return {};
      }
      var _dashPlaylists$0$attr = dashPlaylists[0].attributes, duration = _dashPlaylists$0$attr.sourceDuration, type = _dashPlaylists$0$attr.type, suggestedPresentationDelay = _dashPlaylists$0$attr.suggestedPresentationDelay, minimumUpdatePeriod = _dashPlaylists$0$attr.minimumUpdatePeriod;
      var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
      var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
      var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
      var captions = dashPlaylists.map(function(playlist) {
        return playlist.attributes.captionServices;
      }).filter(Boolean);
      var manifest = {
        allowCache: true,
        discontinuityStarts: [],
        segments: [],
        endList: true,
        mediaGroups: (_mediaGroups = {
          AUDIO: {},
          VIDEO: {}
        }, _mediaGroups["CLOSED-CAPTIONS"] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),
        uri: "",
        duration,
        playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
      };
      if (minimumUpdatePeriod >= 0) {
        manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1e3;
      }
      if (locations) {
        manifest.locations = locations;
      }
      if (type === "dynamic") {
        manifest.suggestedPresentationDelay = suggestedPresentationDelay;
      }
      var isAudioOnly = manifest.playlists.length === 0;
      var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;
      var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
      var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
      var playlistTimelineStarts = formattedPlaylists.map(function(_ref9) {
        var timelineStarts = _ref9.timelineStarts;
        return timelineStarts;
      });
      manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
      addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
      if (organizedAudioGroup) {
        manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
      }
      if (organizedVttGroup) {
        manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
      }
      if (captions.length) {
        manifest.mediaGroups["CLOSED-CAPTIONS"].cc = organizeCaptionServices(captions);
      }
      if (previousManifest) {
        return positionManifestOnTimeline({
          oldManifest: previousManifest,
          newManifest: manifest
        });
      }
      return manifest;
    };
    var getLiveRValue = function getLiveRValue2(attributes, time, duration) {
      var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime = attributes.availabilityStartTime, _attributes$timescale = attributes.timescale, timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;
      var now = (NOW + clientOffset) / 1e3;
      var periodStartWC = availabilityStartTime + periodStart;
      var periodEndWC = now + minimumUpdatePeriod;
      var periodDuration = periodEndWC - periodStartWC;
      return Math.ceil((periodDuration * timescale - time) / duration);
    };
    var parseByTimeline = function parseByTimeline2(attributes, segmentTimeline) {
      var type = attributes.type, _attributes$minimumUp2 = attributes.minimumUpdatePeriod, minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2, _attributes$media = attributes.media, media = _attributes$media === void 0 ? "" : _attributes$media, sourceDuration = attributes.sourceDuration, _attributes$timescale2 = attributes.timescale, timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, _attributes$startNumb = attributes.startNumber, startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb, timeline = attributes.periodStart;
      var segments = [];
      var time = -1;
      for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
        var S = segmentTimeline[sIndex];
        var duration = S.d;
        var repeat = S.r || 0;
        var segmentTime = S.t || 0;
        if (time < 0) {
          time = segmentTime;
        }
        if (segmentTime && segmentTime > time) {
          time = segmentTime;
        }
        var count = void 0;
        if (repeat < 0) {
          var nextS = sIndex + 1;
          if (nextS === segmentTimeline.length) {
            if (type === "dynamic" && minimumUpdatePeriod > 0 && media.indexOf("$Number$") > 0) {
              count = getLiveRValue(attributes, time, duration);
            } else {
              count = (sourceDuration * timescale - time) / duration;
            }
          } else {
            count = (segmentTimeline[nextS].t - time) / duration;
          }
        } else {
          count = repeat + 1;
        }
        var end2 = startNumber + segments.length + count;
        var number = startNumber + segments.length;
        while (number < end2) {
          segments.push({
            number,
            duration: duration / timescale,
            time,
            timeline
          });
          time += duration;
          number++;
        }
      }
      return segments;
    };
    var identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
    var identifierReplacement = function identifierReplacement2(values2) {
      return function(match, identifier, format, width) {
        if (match === "$$") {
          return "$";
        }
        if (typeof values2[identifier] === "undefined") {
          return match;
        }
        var value = "" + values2[identifier];
        if (identifier === "RepresentationID") {
          return value;
        }
        if (!format) {
          width = 1;
        } else {
          width = parseInt(width, 10);
        }
        if (value.length >= width) {
          return value;
        }
        return "" + new Array(width - value.length + 1).join("0") + value;
      };
    };
    var constructTemplateUrl = function constructTemplateUrl2(url, values2) {
      return url.replace(identifierPattern, identifierReplacement(values2));
    };
    var parseTemplateInfo = function parseTemplateInfo2(attributes, segmentTimeline) {
      if (!attributes.duration && !segmentTimeline) {
        return [{
          number: attributes.startNumber || 1,
          duration: attributes.sourceDuration,
          time: 0,
          timeline: attributes.periodStart
        }];
      }
      if (attributes.duration) {
        return parseByDuration(attributes);
      }
      return parseByTimeline(attributes, segmentTimeline);
    };
    var segmentsFromTemplate = function segmentsFromTemplate2(attributes, segmentTimeline) {
      var templateValues = {
        RepresentationID: attributes.id,
        Bandwidth: attributes.bandwidth || 0
      };
      var _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {
        sourceURL: "",
        range: ""
      } : _attributes$initializ;
      var mapSegment = urlTypeToSegment({
        baseUrl: attributes.baseUrl,
        source: constructTemplateUrl(initialization.sourceURL, templateValues),
        range: initialization.range
      });
      var segments = parseTemplateInfo(attributes, segmentTimeline);
      return segments.map(function(segment) {
        templateValues.Number = segment.number;
        templateValues.Time = segment.time;
        var uri = constructTemplateUrl(attributes.media || "", templateValues);
        var timescale = attributes.timescale || 1;
        var presentationTimeOffset = attributes.presentationTimeOffset || 0;
        var presentationTime = attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;
        var map = {
          uri,
          timeline: segment.timeline,
          duration: segment.duration,
          resolvedUri: resolveUrl__default["default"](attributes.baseUrl || "", uri),
          map: mapSegment,
          number: segment.number,
          presentationTime
        };
        return map;
      });
    };
    var SegmentURLToSegmentObject = function SegmentURLToSegmentObject2(attributes, segmentUrl) {
      var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;
      var initSegment = urlTypeToSegment({
        baseUrl,
        source: initialization.sourceURL,
        range: initialization.range
      });
      var segment = urlTypeToSegment({
        baseUrl,
        source: segmentUrl.media,
        range: segmentUrl.mediaRange
      });
      segment.map = initSegment;
      return segment;
    };
    var segmentsFromList = function segmentsFromList2(attributes, segmentTimeline) {
      var duration = attributes.duration, _attributes$segmentUr = attributes.segmentUrls, segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr, periodStart = attributes.periodStart;
      if (!duration && !segmentTimeline || duration && segmentTimeline) {
        throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
      }
      var segmentUrlMap = segmentUrls.map(function(segmentUrlObject) {
        return SegmentURLToSegmentObject(attributes, segmentUrlObject);
      });
      var segmentTimeInfo;
      if (duration) {
        segmentTimeInfo = parseByDuration(attributes);
      }
      if (segmentTimeline) {
        segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
      }
      var segments = segmentTimeInfo.map(function(segmentTime, index) {
        if (segmentUrlMap[index]) {
          var segment = segmentUrlMap[index];
          var timescale = attributes.timescale || 1;
          var presentationTimeOffset = attributes.presentationTimeOffset || 0;
          segment.timeline = segmentTime.timeline;
          segment.duration = segmentTime.duration;
          segment.number = segmentTime.number;
          segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;
          return segment;
        }
      }).filter(function(segment) {
        return segment;
      });
      return segments;
    };
    var generateSegments = function generateSegments2(_ref) {
      var attributes = _ref.attributes, segmentInfo = _ref.segmentInfo;
      var segmentAttributes;
      var segmentsFn;
      if (segmentInfo.template) {
        segmentsFn = segmentsFromTemplate;
        segmentAttributes = merge(attributes, segmentInfo.template);
      } else if (segmentInfo.base) {
        segmentsFn = segmentsFromBase;
        segmentAttributes = merge(attributes, segmentInfo.base);
      } else if (segmentInfo.list) {
        segmentsFn = segmentsFromList;
        segmentAttributes = merge(attributes, segmentInfo.list);
      }
      var segmentsInfo = {
        attributes
      };
      if (!segmentsFn) {
        return segmentsInfo;
      }
      var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
      if (segmentAttributes.duration) {
        var _segmentAttributes = segmentAttributes, duration = _segmentAttributes.duration, _segmentAttributes$ti = _segmentAttributes.timescale, timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;
        segmentAttributes.duration = duration / timescale;
      } else if (segments.length) {
        segmentAttributes.duration = segments.reduce(function(max, segment) {
          return Math.max(max, Math.ceil(segment.duration));
        }, 0);
      } else {
        segmentAttributes.duration = 0;
      }
      segmentsInfo.attributes = segmentAttributes;
      segmentsInfo.segments = segments;
      if (segmentInfo.base && segmentAttributes.indexRange) {
        segmentsInfo.sidx = segments[0];
        segmentsInfo.segments = [];
      }
      return segmentsInfo;
    };
    var toPlaylists = function toPlaylists2(representations) {
      return representations.map(generateSegments);
    };
    var findChildren = function findChildren2(element, name) {
      return from(element.childNodes).filter(function(_ref) {
        var tagName = _ref.tagName;
        return tagName === name;
      });
    };
    var getContent = function getContent2(element) {
      return element.textContent.trim();
    };
    var parseDivisionValue = function parseDivisionValue2(value) {
      return parseFloat(value.split("/").reduce(function(prev, current) {
        return prev / current;
      }));
    };
    var parseDuration = function parseDuration2(str) {
      var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
      var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
      var SECONDS_IN_DAY = 24 * 60 * 60;
      var SECONDS_IN_HOUR = 60 * 60;
      var SECONDS_IN_MIN = 60;
      var durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
      var match = durationRegex.exec(str);
      if (!match) {
        return 0;
      }
      var _match$slice = match.slice(1), year = _match$slice[0], month = _match$slice[1], day = _match$slice[2], hour = _match$slice[3], minute = _match$slice[4], second = _match$slice[5];
      return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
    };
    var parseDate = function parseDate2(str) {
      var dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
      if (dateRegex.test(str)) {
        str += "Z";
      }
      return Date.parse(str);
    };
    var parsers = {
      mediaPresentationDuration: function mediaPresentationDuration(value) {
        return parseDuration(value);
      },
      availabilityStartTime: function availabilityStartTime(value) {
        return parseDate(value) / 1e3;
      },
      minimumUpdatePeriod: function minimumUpdatePeriod(value) {
        return parseDuration(value);
      },
      suggestedPresentationDelay: function suggestedPresentationDelay(value) {
        return parseDuration(value);
      },
      type: function type(value) {
        return value;
      },
      timeShiftBufferDepth: function timeShiftBufferDepth(value) {
        return parseDuration(value);
      },
      start: function start2(value) {
        return parseDuration(value);
      },
      width: function width(value) {
        return parseInt(value, 10);
      },
      height: function height(value) {
        return parseInt(value, 10);
      },
      bandwidth: function bandwidth(value) {
        return parseInt(value, 10);
      },
      frameRate: function frameRate(value) {
        return parseDivisionValue(value);
      },
      startNumber: function startNumber(value) {
        return parseInt(value, 10);
      },
      timescale: function timescale(value) {
        return parseInt(value, 10);
      },
      presentationTimeOffset: function presentationTimeOffset(value) {
        return parseInt(value, 10);
      },
      duration: function duration(value) {
        var parsedValue = parseInt(value, 10);
        if (isNaN(parsedValue)) {
          return parseDuration(value);
        }
        return parsedValue;
      },
      d: function d(value) {
        return parseInt(value, 10);
      },
      t: function t(value) {
        return parseInt(value, 10);
      },
      r: function r(value) {
        return parseInt(value, 10);
      },
      DEFAULT: function DEFAULT(value) {
        return value;
      }
    };
    var parseAttributes = function parseAttributes2(el) {
      if (!(el && el.attributes)) {
        return {};
      }
      return from(el.attributes).reduce(function(a, e) {
        var parseFn = parsers[e.name] || parsers.DEFAULT;
        a[e.name] = parseFn(e.value);
        return a;
      }, {});
    };
    var keySystemsMap = {
      "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
      "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
      "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
      "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
    };
    var buildBaseUrls = function buildBaseUrls2(referenceUrls, baseUrlElements) {
      if (!baseUrlElements.length) {
        return referenceUrls;
      }
      return flatten(referenceUrls.map(function(reference) {
        return baseUrlElements.map(function(baseUrlElement) {
          return resolveUrl__default["default"](reference, getContent(baseUrlElement));
        });
      }));
    };
    var getSegmentInformation = function getSegmentInformation2(adaptationSet) {
      var segmentTemplate = findChildren(adaptationSet, "SegmentTemplate")[0];
      var segmentList = findChildren(adaptationSet, "SegmentList")[0];
      var segmentUrls = segmentList && findChildren(segmentList, "SegmentURL").map(function(s) {
        return merge({
          tag: "SegmentURL"
        }, parseAttributes(s));
      });
      var segmentBase = findChildren(adaptationSet, "SegmentBase")[0];
      var segmentTimelineParentNode = segmentList || segmentTemplate;
      var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
      var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
      var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, "Initialization")[0];
      var template = segmentTemplate && parseAttributes(segmentTemplate);
      if (template && segmentInitialization) {
        template.initialization = segmentInitialization && parseAttributes(segmentInitialization);
      } else if (template && template.initialization) {
        template.initialization = {
          sourceURL: template.initialization
        };
      }
      var segmentInfo = {
        template,
        segmentTimeline: segmentTimeline && findChildren(segmentTimeline, "S").map(function(s) {
          return parseAttributes(s);
        }),
        list: segmentList && merge(parseAttributes(segmentList), {
          segmentUrls,
          initialization: parseAttributes(segmentInitialization)
        }),
        base: segmentBase && merge(parseAttributes(segmentBase), {
          initialization: parseAttributes(segmentInitialization)
        })
      };
      Object.keys(segmentInfo).forEach(function(key) {
        if (!segmentInfo[key]) {
          delete segmentInfo[key];
        }
      });
      return segmentInfo;
    };
    var inheritBaseUrls = function inheritBaseUrls2(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {
      return function(representation) {
        var repBaseUrlElements = findChildren(representation, "BaseURL");
        var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
        var attributes = merge(adaptationSetAttributes, parseAttributes(representation));
        var representationSegmentInfo = getSegmentInformation(representation);
        return repBaseUrls.map(function(baseUrl) {
          return {
            segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),
            attributes: merge(attributes, {
              baseUrl
            })
          };
        });
      };
    };
    var generateKeySystemInformation = function generateKeySystemInformation2(contentProtectionNodes) {
      return contentProtectionNodes.reduce(function(acc, node) {
        var attributes = parseAttributes(node);
        if (attributes.schemeIdUri) {
          attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
        }
        var keySystem = keySystemsMap[attributes.schemeIdUri];
        if (keySystem) {
          acc[keySystem] = {
            attributes
          };
          var psshNode = findChildren(node, "cenc:pssh")[0];
          if (psshNode) {
            var pssh = getContent(psshNode);
            acc[keySystem].pssh = pssh && decodeB64ToUint8Array__default["default"](pssh);
          }
        }
        return acc;
      }, {});
    };
    var parseCaptionServiceMetadata = function parseCaptionServiceMetadata2(service) {
      if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
        var values2 = typeof service.value !== "string" ? [] : service.value.split(";");
        return values2.map(function(value) {
          var channel;
          var language;
          language = value;
          if (/^CC\d=/.test(value)) {
            var _value$split = value.split("=");
            channel = _value$split[0];
            language = _value$split[1];
          } else if (/^CC\d$/.test(value)) {
            channel = value;
          }
          return {
            channel,
            language
          };
        });
      } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
        var _values = typeof service.value !== "string" ? [] : service.value.split(";");
        return _values.map(function(value) {
          var flags = {
            "channel": void 0,
            "language": void 0,
            "aspectRatio": 1,
            "easyReader": 0,
            "3D": 0
          };
          if (/=/.test(value)) {
            var _value$split2 = value.split("="), channel = _value$split2[0], _value$split2$ = _value$split2[1], opts = _value$split2$ === void 0 ? "" : _value$split2$;
            flags.channel = channel;
            flags.language = value;
            opts.split(",").forEach(function(opt) {
              var _opt$split = opt.split(":"), name = _opt$split[0], val = _opt$split[1];
              if (name === "lang") {
                flags.language = val;
              } else if (name === "er") {
                flags.easyReader = Number(val);
              } else if (name === "war") {
                flags.aspectRatio = Number(val);
              } else if (name === "3D") {
                flags["3D"] = Number(val);
              }
            });
          } else {
            flags.language = value;
          }
          if (flags.channel) {
            flags.channel = "SERVICE" + flags.channel;
          }
          return flags;
        });
      }
    };
    var toRepresentations = function toRepresentations2(periodAttributes, periodBaseUrls, periodSegmentInfo) {
      return function(adaptationSet) {
        var adaptationSetAttributes = parseAttributes(adaptationSet);
        var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, "BaseURL"));
        var role = findChildren(adaptationSet, "Role")[0];
        var roleAttributes = {
          role: parseAttributes(role)
        };
        var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);
        var accessibility = findChildren(adaptationSet, "Accessibility")[0];
        var captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));
        if (captionServices) {
          attrs = merge(attrs, {
            captionServices
          });
        }
        var label = findChildren(adaptationSet, "Label")[0];
        if (label && label.childNodes.length) {
          var labelVal = label.childNodes[0].nodeValue.trim();
          attrs = merge(attrs, {
            label: labelVal
          });
        }
        var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, "ContentProtection"));
        if (Object.keys(contentProtection).length) {
          attrs = merge(attrs, {
            contentProtection
          });
        }
        var segmentInfo = getSegmentInformation(adaptationSet);
        var representations = findChildren(adaptationSet, "Representation");
        var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);
        return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
      };
    };
    var toAdaptationSets = function toAdaptationSets2(mpdAttributes, mpdBaseUrls) {
      return function(period, index) {
        var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, "BaseURL"));
        var periodAttributes = merge(mpdAttributes, {
          periodStart: period.attributes.start
        });
        if (typeof period.attributes.duration === "number") {
          periodAttributes.periodDuration = period.attributes.duration;
        }
        var adaptationSets = findChildren(period.node, "AdaptationSet");
        var periodSegmentInfo = getSegmentInformation(period.node);
        return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
      };
    };
    var getPeriodStart = function getPeriodStart2(_ref) {
      var attributes = _ref.attributes, priorPeriodAttributes = _ref.priorPeriodAttributes, mpdType = _ref.mpdType;
      if (typeof attributes.start === "number") {
        return attributes.start;
      }
      if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") {
        return priorPeriodAttributes.start + priorPeriodAttributes.duration;
      }
      if (!priorPeriodAttributes && mpdType === "static") {
        return 0;
      }
      return null;
    };
    var inheritAttributes = function inheritAttributes2(mpd, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$manifestUri = _options.manifestUri, manifestUri = _options$manifestUri === void 0 ? "" : _options$manifestUri, _options$NOW = _options.NOW, NOW = _options$NOW === void 0 ? Date.now() : _options$NOW, _options$clientOffset = _options.clientOffset, clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;
      var periodNodes = findChildren(mpd, "Period");
      if (!periodNodes.length) {
        throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
      }
      var locations = findChildren(mpd, "Location");
      var mpdAttributes = parseAttributes(mpd);
      var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, "BaseURL"));
      mpdAttributes.type = mpdAttributes.type || "static";
      mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
      mpdAttributes.NOW = NOW;
      mpdAttributes.clientOffset = clientOffset;
      if (locations.length) {
        mpdAttributes.locations = locations.map(getContent);
      }
      var periods = [];
      periodNodes.forEach(function(node, index) {
        var attributes = parseAttributes(node);
        var priorPeriod = periods[index - 1];
        attributes.start = getPeriodStart({
          attributes,
          priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
          mpdType: mpdAttributes.type
        });
        periods.push({
          node,
          attributes
        });
      });
      return {
        locations: mpdAttributes.locations,
        representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))
      };
    };
    var stringToMpdXml = function stringToMpdXml2(manifestString) {
      if (manifestString === "") {
        throw new Error(errors.DASH_EMPTY_MANIFEST);
      }
      var parser = new xmldom.DOMParser();
      var xml;
      var mpd;
      try {
        xml = parser.parseFromString(manifestString, "application/xml");
        mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
      } catch (e) {
      }
      if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) {
        throw new Error(errors.DASH_INVALID_XML);
      }
      return mpd;
    };
    var parseUTCTimingScheme = function parseUTCTimingScheme2(mpd) {
      var UTCTimingNode = findChildren(mpd, "UTCTiming")[0];
      if (!UTCTimingNode) {
        return null;
      }
      var attributes = parseAttributes(UTCTimingNode);
      switch (attributes.schemeIdUri) {
        case "urn:mpeg:dash:utc:http-head:2014":
        case "urn:mpeg:dash:utc:http-head:2012":
          attributes.method = "HEAD";
          break;
        case "urn:mpeg:dash:utc:http-xsdate:2014":
        case "urn:mpeg:dash:utc:http-iso:2014":
        case "urn:mpeg:dash:utc:http-xsdate:2012":
        case "urn:mpeg:dash:utc:http-iso:2012":
          attributes.method = "GET";
          break;
        case "urn:mpeg:dash:utc:direct:2014":
        case "urn:mpeg:dash:utc:direct:2012":
          attributes.method = "DIRECT";
          attributes.value = Date.parse(attributes.value);
          break;
        case "urn:mpeg:dash:utc:http-ntp:2014":
        case "urn:mpeg:dash:utc:ntp:2014":
        case "urn:mpeg:dash:utc:sntp:2014":
        default:
          throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
      }
      return attributes;
    };
    var VERSION = version2;
    var parse = function parse2(manifestString, options) {
      if (options === void 0) {
        options = {};
      }
      var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
      var playlists = toPlaylists(parsedManifestInfo.representationInfo);
      return toM3u8({
        dashPlaylists: playlists,
        locations: parsedManifestInfo.locations,
        sidxMapping: options.sidxMapping,
        previousManifest: options.previousManifest
      });
    };
    var parseUTCTiming = function parseUTCTiming2(manifestString) {
      return parseUTCTimingScheme(stringToMpdXml(manifestString));
    };
    exports.VERSION = VERSION;
    exports.addSidxSegmentsToPlaylist = addSidxSegmentsToPlaylist$1;
    exports.generateSidxKey = generateSidxKey;
    exports.inheritAttributes = inheritAttributes;
    exports.parse = parse;
    exports.parseUTCTiming = parseUTCTiming;
    exports.stringToMpdXml = stringToMpdXml;
    exports.toM3u8 = toM3u8;
    exports.toPlaylists = toPlaylists;
  }
});

// node_modules/mux.js/lib/utils/numbers.js
var require_numbers = __commonJS({
  "node_modules/mux.js/lib/utils/numbers.js"(exports, module) {
    var MAX_UINT32 = Math.pow(2, 32);
    var getUint64 = function(uint8) {
      var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
      var value;
      if (dv.getBigUint64) {
        value = dv.getBigUint64(0);
        if (value < Number.MAX_SAFE_INTEGER) {
          return Number(value);
        }
        return value;
      }
      return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
    };
    module.exports = {
      getUint64,
      MAX_UINT32
    };
  }
});

// node_modules/mux.js/lib/tools/parse-sidx.js
var require_parse_sidx = __commonJS({
  "node_modules/mux.js/lib/tools/parse-sidx.js"(exports, module) {
    var getUint64 = require_numbers().getUint64;
    var parseSidx = function(data) {
      var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
        version: data[0],
        flags: new Uint8Array(data.subarray(1, 4)),
        references: [],
        referenceId: view.getUint32(4),
        timescale: view.getUint32(8)
      }, i = 12;
      if (result.version === 0) {
        result.earliestPresentationTime = view.getUint32(i);
        result.firstOffset = view.getUint32(i + 4);
        i += 8;
      } else {
        result.earliestPresentationTime = getUint64(data.subarray(i));
        result.firstOffset = getUint64(data.subarray(i + 8));
        i += 16;
      }
      i += 2;
      var referenceCount = view.getUint16(i);
      i += 2;
      for (; referenceCount > 0; i += 12, referenceCount--) {
        result.references.push({
          referenceType: (data[i] & 128) >>> 7,
          referencedSize: view.getUint32(i) & 2147483647,
          subsegmentDuration: view.getUint32(i + 4),
          startsWithSap: !!(data[i + 8] & 128),
          sapType: (data[i + 8] & 112) >>> 4,
          sapDeltaTime: view.getUint32(i + 8) & 268435455
        });
      }
      return result;
    };
    module.exports = parseSidx;
  }
});

// node_modules/@videojs/vhs-utils/cjs/id3-helpers.js
var require_id3_helpers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/id3-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getId3Offset = exports.getId3Size = void 0;
    var _byteHelpers = require_byte_helpers();
    var ID3 = (0, _byteHelpers.toUint8)([73, 68, 51]);
    var getId3Size = function getId3Size2(bytes, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      bytes = (0, _byteHelpers.toUint8)(bytes);
      var flags = bytes[offset + 5];
      var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];
      var footerPresent = (flags & 16) >> 4;
      if (footerPresent) {
        return returnSize + 20;
      }
      return returnSize + 10;
    };
    exports.getId3Size = getId3Size;
    var getId3Offset = function getId3Offset2(bytes, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      bytes = (0, _byteHelpers.toUint8)(bytes);
      if (bytes.length - offset < 10 || !(0, _byteHelpers.bytesMatch)(bytes, ID3, {
        offset
      })) {
        return offset;
      }
      offset += getId3Size(bytes, offset);
      return getId3Offset2(bytes, offset);
    };
    exports.getId3Offset = getId3Offset;
  }
});

// node_modules/@videojs/vhs-utils/cjs/codec-helpers.js
var require_codec_helpers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/codec-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getHvcCodec = exports.getAvcCodec = exports.getAv1Codec = void 0;
    var _byteHelpers = require_byte_helpers();
    var getAv1Codec = function getAv1Codec2(bytes) {
      var codec = "";
      var profile = bytes[1] >>> 3;
      var level = bytes[1] & 31;
      var tier = bytes[2] >>> 7;
      var highBitDepth = (bytes[2] & 64) >> 6;
      var twelveBit = (bytes[2] & 32) >> 5;
      var monochrome = (bytes[2] & 16) >> 4;
      var chromaSubsamplingX = (bytes[2] & 8) >> 3;
      var chromaSubsamplingY = (bytes[2] & 4) >> 2;
      var chromaSamplePosition = bytes[2] & 3;
      codec += profile + "." + (0, _byteHelpers.padStart)(level, 2, "0");
      if (tier === 0) {
        codec += "M";
      } else if (tier === 1) {
        codec += "H";
      }
      var bitDepth;
      if (profile === 2 && highBitDepth) {
        bitDepth = twelveBit ? 12 : 10;
      } else {
        bitDepth = highBitDepth ? 10 : 8;
      }
      codec += "." + (0, _byteHelpers.padStart)(bitDepth, 2, "0");
      codec += "." + monochrome;
      codec += "." + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition;
      return codec;
    };
    exports.getAv1Codec = getAv1Codec;
    var getAvcCodec = function getAvcCodec2(bytes) {
      var profileId = (0, _byteHelpers.toHexString)(bytes[1]);
      var constraintFlags = (0, _byteHelpers.toHexString)(bytes[2] & 252);
      var levelId = (0, _byteHelpers.toHexString)(bytes[3]);
      return "" + profileId + constraintFlags + levelId;
    };
    exports.getAvcCodec = getAvcCodec;
    var getHvcCodec = function getHvcCodec2(bytes) {
      var codec = "";
      var profileSpace = bytes[1] >> 6;
      var profileId = bytes[1] & 31;
      var tierFlag = (bytes[1] & 32) >> 5;
      var profileCompat = bytes.subarray(2, 6);
      var constraintIds = bytes.subarray(6, 12);
      var levelId = bytes[12];
      if (profileSpace === 1) {
        codec += "A";
      } else if (profileSpace === 2) {
        codec += "B";
      } else if (profileSpace === 3) {
        codec += "C";
      }
      codec += profileId + ".";
      var profileCompatVal = parseInt((0, _byteHelpers.toBinaryString)(profileCompat).split("").reverse().join(""), 2);
      if (profileCompatVal > 255) {
        profileCompatVal = parseInt((0, _byteHelpers.toBinaryString)(profileCompat), 2);
      }
      codec += profileCompatVal.toString(16) + ".";
      if (tierFlag === 0) {
        codec += "L";
      } else {
        codec += "H";
      }
      codec += levelId;
      var constraints = "";
      for (var i = 0; i < constraintIds.length; i++) {
        var v = constraintIds[i];
        if (v) {
          if (constraints) {
            constraints += ".";
          }
          constraints += v.toString(16);
        }
      }
      if (constraints) {
        codec += "." + constraints;
      }
      return codec;
    };
    exports.getHvcCodec = getHvcCodec;
  }
});

// node_modules/@videojs/vhs-utils/cjs/opus-helpers.js
var require_opus_helpers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/opus-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setOpusHead = exports.parseOpusHead = exports.OPUS_HEAD = void 0;
    var OPUS_HEAD = new Uint8Array([
      79,
      112,
      117,
      115,
      72,
      101,
      97,
      100
    ]);
    exports.OPUS_HEAD = OPUS_HEAD;
    var parseOpusHead = function parseOpusHead2(bytes) {
      var view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      var version2 = view.getUint8(0);
      var littleEndian = version2 !== 0;
      var config = {
        version: version2,
        channels: view.getUint8(1),
        preSkip: view.getUint16(2, littleEndian),
        sampleRate: view.getUint32(4, littleEndian),
        outputGain: view.getUint16(8, littleEndian),
        channelMappingFamily: view.getUint8(10)
      };
      if (config.channelMappingFamily > 0 && bytes.length > 10) {
        config.streamCount = view.getUint8(11);
        config.twoChannelStreamCount = view.getUint8(12);
        config.channelMapping = [];
        for (var c = 0; c < config.channels; c++) {
          config.channelMapping.push(view.getUint8(13 + c));
        }
      }
      return config;
    };
    exports.parseOpusHead = parseOpusHead;
    var setOpusHead = function setOpusHead2(config) {
      var size = config.channelMappingFamily <= 0 ? 11 : 12 + config.channels;
      var view = new DataView(new ArrayBuffer(size));
      var littleEndian = config.version !== 0;
      view.setUint8(0, config.version);
      view.setUint8(1, config.channels);
      view.setUint16(2, config.preSkip, littleEndian);
      view.setUint32(4, config.sampleRate, littleEndian);
      view.setUint16(8, config.outputGain, littleEndian);
      view.setUint8(10, config.channelMappingFamily);
      if (config.channelMappingFamily > 0) {
        view.setUint8(11, config.streamCount);
        config.channelMapping.foreach(function(cm, i) {
          view.setUint8(12 + i, cm);
        });
      }
      return new Uint8Array(view.buffer);
    };
    exports.setOpusHead = setOpusHead;
  }
});

// node_modules/@videojs/vhs-utils/cjs/mp4-helpers.js
var require_mp4_helpers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/mp4-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseMediaInfo = exports.parseTracks = exports.addSampleDescription = exports.buildFrameTable = exports.findNamedBox = exports.findBox = exports.parseDescriptors = void 0;
    var _byteHelpers = require_byte_helpers();
    var _codecHelpers = require_codec_helpers();
    var _opusHelpers = require_opus_helpers();
    var normalizePath = function normalizePath2(path) {
      if (typeof path === "string") {
        return (0, _byteHelpers.stringToBytes)(path);
      }
      if (typeof path === "number") {
        return path;
      }
      return path;
    };
    var normalizePaths = function normalizePaths2(paths) {
      if (!Array.isArray(paths)) {
        return [normalizePath(paths)];
      }
      return paths.map(function(p) {
        return normalizePath(p);
      });
    };
    var DESCRIPTORS;
    var parseDescriptors = function parseDescriptors2(bytes) {
      bytes = (0, _byteHelpers.toUint8)(bytes);
      var results = [];
      var i = 0;
      while (bytes.length > i) {
        var tag = bytes[i];
        var size = 0;
        var headerSize = 0;
        headerSize++;
        var byte = bytes[headerSize];
        headerSize++;
        while (byte & 128) {
          size = (byte & 127) << 7;
          byte = bytes[headerSize];
          headerSize++;
        }
        size += byte & 127;
        for (var z = 0; z < DESCRIPTORS.length; z++) {
          var _DESCRIPTORS$z = DESCRIPTORS[z], id = _DESCRIPTORS$z.id, parser = _DESCRIPTORS$z.parser;
          if (tag === id) {
            results.push(parser(bytes.subarray(headerSize, headerSize + size)));
            break;
          }
        }
        i += size + headerSize;
      }
      return results;
    };
    exports.parseDescriptors = parseDescriptors;
    DESCRIPTORS = [{
      id: 3,
      parser: function parser(bytes) {
        var desc = {
          tag: 3,
          id: bytes[0] << 8 | bytes[1],
          flags: bytes[2],
          size: 3,
          dependsOnEsId: 0,
          ocrEsId: 0,
          descriptors: [],
          url: ""
        };
        if (desc.flags & 128) {
          desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
          desc.size += 2;
        }
        if (desc.flags & 64) {
          var len = bytes[desc.size];
          desc.url = (0, _byteHelpers.bytesToString)(bytes.subarray(desc.size + 1, desc.size + 1 + len));
          desc.size += len;
        }
        if (desc.flags & 32) {
          desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
          desc.size += 2;
        }
        desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];
        return desc;
      }
    }, {
      id: 4,
      parser: function parser(bytes) {
        var desc = {
          tag: 4,
          oti: bytes[0],
          streamType: bytes[1],
          bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],
          maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],
          avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],
          descriptors: parseDescriptors(bytes.subarray(13))
        };
        return desc;
      }
    }, {
      id: 5,
      parser: function parser(bytes) {
        return {
          tag: 5,
          bytes
        };
      }
    }, {
      id: 6,
      parser: function parser(bytes) {
        return {
          tag: 6,
          bytes
        };
      }
    }];
    var findBox = function findBox2(bytes, paths, complete) {
      if (complete === void 0) {
        complete = false;
      }
      paths = normalizePaths(paths);
      bytes = (0, _byteHelpers.toUint8)(bytes);
      var results = [];
      if (!paths.length) {
        return results;
      }
      var i = 0;
      while (i < bytes.length) {
        var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
        var type = bytes.subarray(i + 4, i + 8);
        if (size === 0) {
          break;
        }
        var end2 = i + size;
        if (end2 > bytes.length) {
          if (complete) {
            break;
          }
          end2 = bytes.length;
        }
        var data = bytes.subarray(i + 8, end2);
        if ((0, _byteHelpers.bytesMatch)(type, paths[0])) {
          if (paths.length === 1) {
            results.push(data);
          } else {
            results.push.apply(results, findBox2(data, paths.slice(1), complete));
          }
        }
        i = end2;
      }
      return results;
    };
    exports.findBox = findBox;
    var findNamedBox = function findNamedBox2(bytes, name) {
      name = normalizePath(name);
      if (!name.length) {
        return bytes.subarray(bytes.length);
      }
      var i = 0;
      while (i < bytes.length) {
        if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i, i + name.length), name)) {
          var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;
          var end2 = size > 1 ? i + size : bytes.byteLength;
          return bytes.subarray(i + 4, end2);
        }
        i++;
      }
      return bytes.subarray(bytes.length);
    };
    exports.findNamedBox = findNamedBox;
    var parseSamples = function parseSamples2(data, entrySize, parseEntry) {
      if (entrySize === void 0) {
        entrySize = 4;
      }
      if (parseEntry === void 0) {
        parseEntry = function parseEntry2(d) {
          return (0, _byteHelpers.bytesToNumber)(d);
        };
      }
      var entries = [];
      if (!data || !data.length) {
        return entries;
      }
      var entryCount = (0, _byteHelpers.bytesToNumber)(data.subarray(4, 8));
      for (var i = 8; entryCount; i += entrySize, entryCount--) {
        entries.push(parseEntry(data.subarray(i, i + entrySize)));
      }
      return entries;
    };
    var buildFrameTable = function buildFrameTable2(stbl, timescale) {
      var keySamples = parseSamples(findBox(stbl, ["stss"])[0]);
      var chunkOffsets = parseSamples(findBox(stbl, ["stco"])[0]);
      var timeToSamples = parseSamples(findBox(stbl, ["stts"])[0], 8, function(entry) {
        return {
          sampleCount: (0, _byteHelpers.bytesToNumber)(entry.subarray(0, 4)),
          sampleDelta: (0, _byteHelpers.bytesToNumber)(entry.subarray(4, 8))
        };
      });
      var samplesToChunks = parseSamples(findBox(stbl, ["stsc"])[0], 12, function(entry) {
        return {
          firstChunk: (0, _byteHelpers.bytesToNumber)(entry.subarray(0, 4)),
          samplesPerChunk: (0, _byteHelpers.bytesToNumber)(entry.subarray(4, 8)),
          sampleDescriptionIndex: (0, _byteHelpers.bytesToNumber)(entry.subarray(8, 12))
        };
      });
      var stsz = findBox(stbl, ["stsz"])[0];
      var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);
      var frames = [];
      for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {
        var samplesInChunk = void 0;
        for (var i = 0; i < samplesToChunks.length; i++) {
          var sampleToChunk = samplesToChunks[i];
          var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);
          if (isThisOne) {
            samplesInChunk = sampleToChunk.samplesPerChunk;
            break;
          }
        }
        var chunkOffset = chunkOffsets[chunkIndex];
        for (var _i = 0; _i < samplesInChunk; _i++) {
          var frameEnd = sampleSizes[frames.length];
          var keyframe = !keySamples.length;
          if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {
            keyframe = true;
          }
          var frame = {
            keyframe,
            start: chunkOffset,
            end: chunkOffset + frameEnd
          };
          for (var k = 0; k < timeToSamples.length; k++) {
            var _timeToSamples$k = timeToSamples[k], sampleCount = _timeToSamples$k.sampleCount, sampleDelta = _timeToSamples$k.sampleDelta;
            if (frames.length <= sampleCount) {
              var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;
              frame.timestamp = lastTimestamp + sampleDelta / timescale * 1e3;
              frame.duration = sampleDelta;
              break;
            }
          }
          frames.push(frame);
          chunkOffset += frameEnd;
        }
      }
      return frames;
    };
    exports.buildFrameTable = buildFrameTable;
    var addSampleDescription = function addSampleDescription2(track, bytes) {
      var codec = (0, _byteHelpers.bytesToString)(bytes.subarray(0, 4));
      if (track.type === "video") {
        track.info = track.info || {};
        track.info.width = bytes[28] << 8 | bytes[29];
        track.info.height = bytes[30] << 8 | bytes[31];
      } else if (track.type === "audio") {
        track.info = track.info || {};
        track.info.channels = bytes[20] << 8 | bytes[21];
        track.info.bitDepth = bytes[22] << 8 | bytes[23];
        track.info.sampleRate = bytes[28] << 8 | bytes[29];
      }
      if (codec === "avc1") {
        var avcC = findNamedBox(bytes, "avcC");
        codec += "." + (0, _codecHelpers.getAvcCodec)(avcC);
        track.info.avcC = avcC;
      } else if (codec === "hvc1" || codec === "hev1") {
        codec += "." + (0, _codecHelpers.getHvcCodec)(findNamedBox(bytes, "hvcC"));
      } else if (codec === "mp4a" || codec === "mp4v") {
        var esds = findNamedBox(bytes, "esds");
        var esDescriptor = parseDescriptors(esds.subarray(4))[0];
        var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function(_ref) {
          var tag = _ref.tag;
          return tag === 4;
        })[0];
        if (decoderConfig) {
          codec += "." + (0, _byteHelpers.toHexString)(decoderConfig.oti);
          if (decoderConfig.oti === 64) {
            codec += "." + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();
          } else if (decoderConfig.oti === 32) {
            codec += "." + decoderConfig.descriptors[0].bytes[4].toString();
          } else if (decoderConfig.oti === 221) {
            codec = "vorbis";
          }
        } else if (track.type === "audio") {
          codec += ".40.2";
        } else {
          codec += ".20.9";
        }
      } else if (codec === "av01") {
        codec += "." + (0, _codecHelpers.getAv1Codec)(findNamedBox(bytes, "av1C"));
      } else if (codec === "vp09") {
        var vpcC = findNamedBox(bytes, "vpcC");
        var profile = vpcC[0];
        var level = vpcC[1];
        var bitDepth = vpcC[2] >> 4;
        var chromaSubsampling = (vpcC[2] & 15) >> 1;
        var videoFullRangeFlag = (vpcC[2] & 15) >> 3;
        var colourPrimaries = vpcC[3];
        var transferCharacteristics = vpcC[4];
        var matrixCoefficients = vpcC[5];
        codec += "." + (0, _byteHelpers.padStart)(profile, 2, "0");
        codec += "." + (0, _byteHelpers.padStart)(level, 2, "0");
        codec += "." + (0, _byteHelpers.padStart)(bitDepth, 2, "0");
        codec += "." + (0, _byteHelpers.padStart)(chromaSubsampling, 2, "0");
        codec += "." + (0, _byteHelpers.padStart)(colourPrimaries, 2, "0");
        codec += "." + (0, _byteHelpers.padStart)(transferCharacteristics, 2, "0");
        codec += "." + (0, _byteHelpers.padStart)(matrixCoefficients, 2, "0");
        codec += "." + (0, _byteHelpers.padStart)(videoFullRangeFlag, 2, "0");
      } else if (codec === "theo") {
        codec = "theora";
      } else if (codec === "spex") {
        codec = "speex";
      } else if (codec === ".mp3") {
        codec = "mp4a.40.34";
      } else if (codec === "msVo") {
        codec = "vorbis";
      } else if (codec === "Opus") {
        codec = "opus";
        var dOps = findNamedBox(bytes, "dOps");
        track.info.opus = (0, _opusHelpers.parseOpusHead)(dOps);
        track.info.codecDelay = 65e5;
      } else {
        codec = codec.toLowerCase();
      }
      track.codec = codec;
    };
    exports.addSampleDescription = addSampleDescription;
    var parseTracks = function parseTracks2(bytes, frameTable) {
      if (frameTable === void 0) {
        frameTable = true;
      }
      bytes = (0, _byteHelpers.toUint8)(bytes);
      var traks = findBox(bytes, ["moov", "trak"], true);
      var tracks = [];
      traks.forEach(function(trak) {
        var track = {
          bytes: trak
        };
        var mdia = findBox(trak, ["mdia"])[0];
        var hdlr = findBox(mdia, ["hdlr"])[0];
        var trakType = (0, _byteHelpers.bytesToString)(hdlr.subarray(8, 12));
        if (trakType === "soun") {
          track.type = "audio";
        } else if (trakType === "vide") {
          track.type = "video";
        } else {
          track.type = trakType;
        }
        var tkhd = findBox(trak, ["tkhd"])[0];
        if (tkhd) {
          var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);
          var tkhdVersion = view.getUint8(0);
          track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
        }
        var mdhd = findBox(mdia, ["mdhd"])[0];
        if (mdhd) {
          var version2 = mdhd[0];
          var index = version2 === 0 ? 12 : 20;
          track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;
        }
        var stbl = findBox(mdia, ["minf", "stbl"])[0];
        var stsd = findBox(stbl, ["stsd"])[0];
        var descriptionCount = (0, _byteHelpers.bytesToNumber)(stsd.subarray(4, 8));
        var offset = 8;
        while (descriptionCount--) {
          var len = (0, _byteHelpers.bytesToNumber)(stsd.subarray(offset, offset + 4));
          var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);
          addSampleDescription(track, sampleDescriptor);
          offset += 4 + len;
        }
        if (frameTable) {
          track.frameTable = buildFrameTable(stbl, track.timescale);
        }
        tracks.push(track);
      });
      return tracks;
    };
    exports.parseTracks = parseTracks;
    var parseMediaInfo = function parseMediaInfo2(bytes) {
      var mvhd = findBox(bytes, ["moov", "mvhd"], true)[0];
      if (!mvhd || !mvhd.length) {
        return;
      }
      var info = {};
      if (mvhd[0] === 1) {
        info.timestampScale = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(20, 24));
        info.duration = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(24, 32));
      } else {
        info.timestampScale = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(12, 16));
        info.duration = (0, _byteHelpers.bytesToNumber)(mvhd.subarray(16, 20));
      }
      info.bytes = mvhd;
      return info;
    };
    exports.parseMediaInfo = parseMediaInfo;
  }
});

// node_modules/@videojs/vhs-utils/cjs/ebml-helpers.js
var require_ebml_helpers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/ebml-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseData = exports.parseTracks = exports.decodeBlock = exports.findEbml = exports.EBML_TAGS = void 0;
    var _byteHelpers = require_byte_helpers();
    var _codecHelpers = require_codec_helpers();
    var EBML_TAGS = {
      EBML: (0, _byteHelpers.toUint8)([26, 69, 223, 163]),
      DocType: (0, _byteHelpers.toUint8)([66, 130]),
      Segment: (0, _byteHelpers.toUint8)([24, 83, 128, 103]),
      SegmentInfo: (0, _byteHelpers.toUint8)([21, 73, 169, 102]),
      Tracks: (0, _byteHelpers.toUint8)([22, 84, 174, 107]),
      Track: (0, _byteHelpers.toUint8)([174]),
      TrackNumber: (0, _byteHelpers.toUint8)([215]),
      DefaultDuration: (0, _byteHelpers.toUint8)([35, 227, 131]),
      TrackEntry: (0, _byteHelpers.toUint8)([174]),
      TrackType: (0, _byteHelpers.toUint8)([131]),
      FlagDefault: (0, _byteHelpers.toUint8)([136]),
      CodecID: (0, _byteHelpers.toUint8)([134]),
      CodecPrivate: (0, _byteHelpers.toUint8)([99, 162]),
      VideoTrack: (0, _byteHelpers.toUint8)([224]),
      AudioTrack: (0, _byteHelpers.toUint8)([225]),
      Cluster: (0, _byteHelpers.toUint8)([31, 67, 182, 117]),
      Timestamp: (0, _byteHelpers.toUint8)([231]),
      TimestampScale: (0, _byteHelpers.toUint8)([42, 215, 177]),
      BlockGroup: (0, _byteHelpers.toUint8)([160]),
      BlockDuration: (0, _byteHelpers.toUint8)([155]),
      Block: (0, _byteHelpers.toUint8)([161]),
      SimpleBlock: (0, _byteHelpers.toUint8)([163])
    };
    exports.EBML_TAGS = EBML_TAGS;
    var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];
    var getLength = function getLength2(byte) {
      var len = 1;
      for (var i = 0; i < LENGTH_TABLE.length; i++) {
        if (byte & LENGTH_TABLE[i]) {
          break;
        }
        len++;
      }
      return len;
    };
    var getvint = function getvint2(bytes, offset, removeLength, signed) {
      if (removeLength === void 0) {
        removeLength = true;
      }
      if (signed === void 0) {
        signed = false;
      }
      var length = getLength(bytes[offset]);
      var valueBytes = bytes.subarray(offset, offset + length);
      if (removeLength) {
        valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);
        valueBytes[0] ^= LENGTH_TABLE[length - 1];
      }
      return {
        length,
        value: (0, _byteHelpers.bytesToNumber)(valueBytes, {
          signed
        }),
        bytes: valueBytes
      };
    };
    var normalizePath = function normalizePath2(path) {
      if (typeof path === "string") {
        return path.match(/.{1,2}/g).map(function(p) {
          return normalizePath2(p);
        });
      }
      if (typeof path === "number") {
        return (0, _byteHelpers.numberToBytes)(path);
      }
      return path;
    };
    var normalizePaths = function normalizePaths2(paths) {
      if (!Array.isArray(paths)) {
        return [normalizePath(paths)];
      }
      return paths.map(function(p) {
        return normalizePath(p);
      });
    };
    var getInfinityDataSize = function getInfinityDataSize2(id, bytes, offset) {
      if (offset >= bytes.length) {
        return bytes.length;
      }
      var innerid = getvint(bytes, offset, false);
      if ((0, _byteHelpers.bytesMatch)(id.bytes, innerid.bytes)) {
        return offset;
      }
      var dataHeader = getvint(bytes, offset + innerid.length);
      return getInfinityDataSize2(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);
    };
    var findEbml = function findEbml2(bytes, paths) {
      paths = normalizePaths(paths);
      bytes = (0, _byteHelpers.toUint8)(bytes);
      var results = [];
      if (!paths.length) {
        return results;
      }
      var i = 0;
      while (i < bytes.length) {
        var id = getvint(bytes, i, false);
        var dataHeader = getvint(bytes, i + id.length);
        var dataStart = i + id.length + dataHeader.length;
        if (dataHeader.value === 127) {
          dataHeader.value = getInfinityDataSize(id, bytes, dataStart);
          if (dataHeader.value !== bytes.length) {
            dataHeader.value -= dataStart;
          }
        }
        var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
        var data = bytes.subarray(dataStart, dataEnd);
        if ((0, _byteHelpers.bytesMatch)(paths[0], id.bytes)) {
          if (paths.length === 1) {
            results.push(data);
          } else {
            results = results.concat(findEbml2(data, paths.slice(1)));
          }
        }
        var totalLength = id.length + dataHeader.length + data.length;
        i += totalLength;
      }
      return results;
    };
    exports.findEbml = findEbml;
    var decodeBlock = function decodeBlock2(block, type, timestampScale, clusterTimestamp) {
      var duration;
      if (type === "group") {
        duration = findEbml(block, [EBML_TAGS.BlockDuration])[0];
        if (duration) {
          duration = (0, _byteHelpers.bytesToNumber)(duration);
          duration = 1 / timestampScale * duration * timestampScale / 1e3;
        }
        block = findEbml(block, [EBML_TAGS.Block])[0];
        type = "block";
      }
      var dv = new DataView(block.buffer, block.byteOffset, block.byteLength);
      var trackNumber = getvint(block, 0);
      var timestamp = dv.getInt16(trackNumber.length, false);
      var flags = block[trackNumber.length + 2];
      var data = block.subarray(trackNumber.length + 3);
      var ptsdts = 1 / timestampScale * (clusterTimestamp + timestamp) * timestampScale / 1e3;
      var parsed = {
        duration,
        trackNumber: trackNumber.value,
        keyframe: type === "simple" && flags >> 7 === 1,
        invisible: (flags & 8) >> 3 === 1,
        lacing: (flags & 6) >> 1,
        discardable: type === "simple" && (flags & 1) === 1,
        frames: [],
        pts: ptsdts,
        dts: ptsdts,
        timestamp
      };
      if (!parsed.lacing) {
        parsed.frames.push(data);
        return parsed;
      }
      var numberOfFrames = data[0] + 1;
      var frameSizes = [];
      var offset = 1;
      if (parsed.lacing === 2) {
        var sizeOfFrame = (data.length - offset) / numberOfFrames;
        for (var i = 0; i < numberOfFrames; i++) {
          frameSizes.push(sizeOfFrame);
        }
      }
      if (parsed.lacing === 1) {
        for (var _i = 0; _i < numberOfFrames - 1; _i++) {
          var size = 0;
          do {
            size += data[offset];
            offset++;
          } while (data[offset - 1] === 255);
          frameSizes.push(size);
        }
      }
      if (parsed.lacing === 3) {
        var _size = 0;
        for (var _i2 = 0; _i2 < numberOfFrames - 1; _i2++) {
          var vint = _i2 === 0 ? getvint(data, offset) : getvint(data, offset, true, true);
          _size += vint.value;
          frameSizes.push(_size);
          offset += vint.length;
        }
      }
      frameSizes.forEach(function(size2) {
        parsed.frames.push(data.subarray(offset, offset + size2));
        offset += size2;
      });
      return parsed;
    };
    exports.decodeBlock = decodeBlock;
    var parseVp9Private = function parseVp9Private2(bytes) {
      var i = 0;
      var params = {};
      while (i < bytes.length) {
        var id = bytes[i] & 127;
        var len = bytes[i + 1];
        var val = void 0;
        if (len === 1) {
          val = bytes[i + 2];
        } else {
          val = bytes.subarray(i + 2, i + 2 + len);
        }
        if (id === 1) {
          params.profile = val;
        } else if (id === 2) {
          params.level = val;
        } else if (id === 3) {
          params.bitDepth = val;
        } else if (id === 4) {
          params.chromaSubsampling = val;
        } else {
          params[id] = val;
        }
        i += 2 + len;
      }
      return params;
    };
    var parseTracks = function parseTracks2(bytes) {
      bytes = (0, _byteHelpers.toUint8)(bytes);
      var decodedTracks = [];
      var tracks = findEbml(bytes, [EBML_TAGS.Segment, EBML_TAGS.Tracks, EBML_TAGS.Track]);
      if (!tracks.length) {
        tracks = findEbml(bytes, [EBML_TAGS.Tracks, EBML_TAGS.Track]);
      }
      if (!tracks.length) {
        tracks = findEbml(bytes, [EBML_TAGS.Track]);
      }
      if (!tracks.length) {
        return decodedTracks;
      }
      tracks.forEach(function(track) {
        var trackType = findEbml(track, EBML_TAGS.TrackType)[0];
        if (!trackType || !trackType.length) {
          return;
        }
        if (trackType[0] === 1) {
          trackType = "video";
        } else if (trackType[0] === 2) {
          trackType = "audio";
        } else if (trackType[0] === 17) {
          trackType = "subtitle";
        } else {
          return;
        }
        var decodedTrack = {
          rawCodec: (0, _byteHelpers.bytesToString)(findEbml(track, [EBML_TAGS.CodecID])[0]),
          type: trackType,
          codecPrivate: findEbml(track, [EBML_TAGS.CodecPrivate])[0],
          number: (0, _byteHelpers.bytesToNumber)(findEbml(track, [EBML_TAGS.TrackNumber])[0]),
          defaultDuration: (0, _byteHelpers.bytesToNumber)(findEbml(track, [EBML_TAGS.DefaultDuration])[0]),
          default: findEbml(track, [EBML_TAGS.FlagDefault])[0],
          rawData: track
        };
        var codec = "";
        if (/V_MPEG4\/ISO\/AVC/.test(decodedTrack.rawCodec)) {
          codec = "avc1." + (0, _codecHelpers.getAvcCodec)(decodedTrack.codecPrivate);
        } else if (/V_MPEGH\/ISO\/HEVC/.test(decodedTrack.rawCodec)) {
          codec = "hev1." + (0, _codecHelpers.getHvcCodec)(decodedTrack.codecPrivate);
        } else if (/V_MPEG4\/ISO\/ASP/.test(decodedTrack.rawCodec)) {
          if (decodedTrack.codecPrivate) {
            codec = "mp4v.20." + decodedTrack.codecPrivate[4].toString();
          } else {
            codec = "mp4v.20.9";
          }
        } else if (/^V_THEORA/.test(decodedTrack.rawCodec)) {
          codec = "theora";
        } else if (/^V_VP8/.test(decodedTrack.rawCodec)) {
          codec = "vp8";
        } else if (/^V_VP9/.test(decodedTrack.rawCodec)) {
          if (decodedTrack.codecPrivate) {
            var _parseVp9Private = parseVp9Private(decodedTrack.codecPrivate), profile = _parseVp9Private.profile, level = _parseVp9Private.level, bitDepth = _parseVp9Private.bitDepth, chromaSubsampling = _parseVp9Private.chromaSubsampling;
            codec = "vp09.";
            codec += (0, _byteHelpers.padStart)(profile, 2, "0") + ".";
            codec += (0, _byteHelpers.padStart)(level, 2, "0") + ".";
            codec += (0, _byteHelpers.padStart)(bitDepth, 2, "0") + ".";
            codec += "" + (0, _byteHelpers.padStart)(chromaSubsampling, 2, "0");
            var matrixCoefficients = findEbml(track, [224, [85, 176], [85, 177]])[0] || [];
            var videoFullRangeFlag = findEbml(track, [224, [85, 176], [85, 185]])[0] || [];
            var transferCharacteristics = findEbml(track, [224, [85, 176], [85, 186]])[0] || [];
            var colourPrimaries = findEbml(track, [224, [85, 176], [85, 187]])[0] || [];
            if (matrixCoefficients.length || videoFullRangeFlag.length || transferCharacteristics.length || colourPrimaries.length) {
              codec += "." + (0, _byteHelpers.padStart)(colourPrimaries[0], 2, "0");
              codec += "." + (0, _byteHelpers.padStart)(transferCharacteristics[0], 2, "0");
              codec += "." + (0, _byteHelpers.padStart)(matrixCoefficients[0], 2, "0");
              codec += "." + (0, _byteHelpers.padStart)(videoFullRangeFlag[0], 2, "0");
            }
          } else {
            codec = "vp9";
          }
        } else if (/^V_AV1/.test(decodedTrack.rawCodec)) {
          codec = "av01." + (0, _codecHelpers.getAv1Codec)(decodedTrack.codecPrivate);
        } else if (/A_ALAC/.test(decodedTrack.rawCodec)) {
          codec = "alac";
        } else if (/A_MPEG\/L2/.test(decodedTrack.rawCodec)) {
          codec = "mp2";
        } else if (/A_MPEG\/L3/.test(decodedTrack.rawCodec)) {
          codec = "mp3";
        } else if (/^A_AAC/.test(decodedTrack.rawCodec)) {
          if (decodedTrack.codecPrivate) {
            codec = "mp4a.40." + (decodedTrack.codecPrivate[0] >>> 3).toString();
          } else {
            codec = "mp4a.40.2";
          }
        } else if (/^A_AC3/.test(decodedTrack.rawCodec)) {
          codec = "ac-3";
        } else if (/^A_PCM/.test(decodedTrack.rawCodec)) {
          codec = "pcm";
        } else if (/^A_MS\/ACM/.test(decodedTrack.rawCodec)) {
          codec = "speex";
        } else if (/^A_EAC3/.test(decodedTrack.rawCodec)) {
          codec = "ec-3";
        } else if (/^A_VORBIS/.test(decodedTrack.rawCodec)) {
          codec = "vorbis";
        } else if (/^A_FLAC/.test(decodedTrack.rawCodec)) {
          codec = "flac";
        } else if (/^A_OPUS/.test(decodedTrack.rawCodec)) {
          codec = "opus";
        }
        decodedTrack.codec = codec;
        decodedTracks.push(decodedTrack);
      });
      return decodedTracks.sort(function(a, b) {
        return a.number - b.number;
      });
    };
    exports.parseTracks = parseTracks;
    var parseData = function parseData2(data, tracks) {
      var allBlocks = [];
      var segment = findEbml(data, [EBML_TAGS.Segment])[0];
      var timestampScale = findEbml(segment, [EBML_TAGS.SegmentInfo, EBML_TAGS.TimestampScale])[0];
      if (timestampScale && timestampScale.length) {
        timestampScale = (0, _byteHelpers.bytesToNumber)(timestampScale);
      } else {
        timestampScale = 1e6;
      }
      var clusters = findEbml(segment, [EBML_TAGS.Cluster]);
      if (!tracks) {
        tracks = parseTracks(segment);
      }
      clusters.forEach(function(cluster, ci) {
        var simpleBlocks = findEbml(cluster, [EBML_TAGS.SimpleBlock]).map(function(b) {
          return {
            type: "simple",
            data: b
          };
        });
        var blockGroups = findEbml(cluster, [EBML_TAGS.BlockGroup]).map(function(b) {
          return {
            type: "group",
            data: b
          };
        });
        var timestamp = findEbml(cluster, [EBML_TAGS.Timestamp])[0] || 0;
        if (timestamp && timestamp.length) {
          timestamp = (0, _byteHelpers.bytesToNumber)(timestamp);
        }
        var blocks = simpleBlocks.concat(blockGroups).sort(function(a, b) {
          return a.data.byteOffset - b.data.byteOffset;
        });
        blocks.forEach(function(block, bi) {
          var decoded = decodeBlock(block.data, block.type, timestampScale, timestamp);
          allBlocks.push(decoded);
        });
      });
      return {
        tracks,
        blocks: allBlocks
      };
    };
    exports.parseData = parseData;
  }
});

// node_modules/@videojs/vhs-utils/cjs/nal-helpers.js
var require_nal_helpers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/nal-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findH265Nal = exports.findH264Nal = exports.findNal = exports.discardEmulationPreventionBytes = exports.EMULATION_PREVENTION = exports.NAL_TYPE_TWO = exports.NAL_TYPE_ONE = void 0;
    var _byteHelpers = require_byte_helpers();
    var NAL_TYPE_ONE = (0, _byteHelpers.toUint8)([0, 0, 0, 1]);
    exports.NAL_TYPE_ONE = NAL_TYPE_ONE;
    var NAL_TYPE_TWO = (0, _byteHelpers.toUint8)([0, 0, 1]);
    exports.NAL_TYPE_TWO = NAL_TYPE_TWO;
    var EMULATION_PREVENTION = (0, _byteHelpers.toUint8)([0, 0, 3]);
    exports.EMULATION_PREVENTION = EMULATION_PREVENTION;
    var discardEmulationPreventionBytes = function discardEmulationPreventionBytes2(bytes) {
      var positions = [];
      var i = 1;
      while (i < bytes.length - 2) {
        if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
          positions.push(i + 2);
          i++;
        }
        i++;
      }
      if (positions.length === 0) {
        return bytes;
      }
      var newLength = bytes.length - positions.length;
      var newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === positions[0]) {
          sourceIndex++;
          positions.shift();
        }
        newData[i] = bytes[sourceIndex];
      }
      return newData;
    };
    exports.discardEmulationPreventionBytes = discardEmulationPreventionBytes;
    var findNal = function findNal2(bytes, dataType, types, nalLimit) {
      if (nalLimit === void 0) {
        nalLimit = Infinity;
      }
      bytes = (0, _byteHelpers.toUint8)(bytes);
      types = [].concat(types);
      var i = 0;
      var nalStart;
      var nalsFound = 0;
      while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
        var nalOffset = void 0;
        if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i), NAL_TYPE_ONE)) {
          nalOffset = 4;
        } else if ((0, _byteHelpers.bytesMatch)(bytes.subarray(i), NAL_TYPE_TWO)) {
          nalOffset = 3;
        }
        if (!nalOffset) {
          i++;
          continue;
        }
        nalsFound++;
        if (nalStart) {
          return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
        }
        var nalType = void 0;
        if (dataType === "h264") {
          nalType = bytes[i + nalOffset] & 31;
        } else if (dataType === "h265") {
          nalType = bytes[i + nalOffset] >> 1 & 63;
        }
        if (types.indexOf(nalType) !== -1) {
          nalStart = i + nalOffset;
        }
        i += nalOffset + (dataType === "h264" ? 1 : 2);
      }
      return bytes.subarray(0, 0);
    };
    exports.findNal = findNal;
    var findH264Nal = function findH264Nal2(bytes, type, nalLimit) {
      return findNal(bytes, "h264", type, nalLimit);
    };
    exports.findH264Nal = findH264Nal;
    var findH265Nal = function findH265Nal2(bytes, type, nalLimit) {
      return findNal(bytes, "h265", type, nalLimit);
    };
    exports.findH265Nal = findH265Nal;
  }
});

// node_modules/@videojs/vhs-utils/cjs/containers.js
var require_containers = __commonJS({
  "node_modules/@videojs/vhs-utils/cjs/containers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isLikelyFmp4MediaSegment = exports.detectContainerForBytes = exports.isLikely = void 0;
    var _byteHelpers = require_byte_helpers();
    var _mp4Helpers = require_mp4_helpers();
    var _ebmlHelpers = require_ebml_helpers();
    var _id3Helpers = require_id3_helpers();
    var _nalHelpers = require_nal_helpers();
    var CONSTANTS = {
      "webm": (0, _byteHelpers.toUint8)([119, 101, 98, 109]),
      "matroska": (0, _byteHelpers.toUint8)([109, 97, 116, 114, 111, 115, 107, 97]),
      "flac": (0, _byteHelpers.toUint8)([102, 76, 97, 67]),
      "ogg": (0, _byteHelpers.toUint8)([79, 103, 103, 83]),
      "ac3": (0, _byteHelpers.toUint8)([11, 119]),
      "riff": (0, _byteHelpers.toUint8)([82, 73, 70, 70]),
      "avi": (0, _byteHelpers.toUint8)([65, 86, 73]),
      "wav": (0, _byteHelpers.toUint8)([87, 65, 86, 69]),
      "3gp": (0, _byteHelpers.toUint8)([102, 116, 121, 112, 51, 103]),
      "mp4": (0, _byteHelpers.toUint8)([102, 116, 121, 112]),
      "fmp4": (0, _byteHelpers.toUint8)([115, 116, 121, 112]),
      "mov": (0, _byteHelpers.toUint8)([102, 116, 121, 112, 113, 116]),
      "moov": (0, _byteHelpers.toUint8)([109, 111, 111, 118]),
      "moof": (0, _byteHelpers.toUint8)([109, 111, 111, 102])
    };
    var _isLikely = {
      aac: function aac(bytes) {
        var offset = (0, _id3Helpers.getId3Offset)(bytes);
        return (0, _byteHelpers.bytesMatch)(bytes, [255, 16], {
          offset,
          mask: [255, 22]
        });
      },
      mp3: function mp3(bytes) {
        var offset = (0, _id3Helpers.getId3Offset)(bytes);
        return (0, _byteHelpers.bytesMatch)(bytes, [255, 2], {
          offset,
          mask: [255, 6]
        });
      },
      webm: function webm(bytes) {
        var docType = (0, _ebmlHelpers.findEbml)(bytes, [_ebmlHelpers.EBML_TAGS.EBML, _ebmlHelpers.EBML_TAGS.DocType])[0];
        return (0, _byteHelpers.bytesMatch)(docType, CONSTANTS.webm);
      },
      mkv: function mkv(bytes) {
        var docType = (0, _ebmlHelpers.findEbml)(bytes, [_ebmlHelpers.EBML_TAGS.EBML, _ebmlHelpers.EBML_TAGS.DocType])[0];
        return (0, _byteHelpers.bytesMatch)(docType, CONSTANTS.matroska);
      },
      mp4: function mp4(bytes) {
        if (_isLikely["3gp"](bytes) || _isLikely.mov(bytes)) {
          return false;
        }
        if ((0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.mp4, {
          offset: 4
        }) || (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.fmp4, {
          offset: 4
        })) {
          return true;
        }
        if ((0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.moof, {
          offset: 4
        }) || (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.moov, {
          offset: 4
        })) {
          return true;
        }
      },
      mov: function mov(bytes) {
        return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.mov, {
          offset: 4
        });
      },
      "3gp": function gp(bytes) {
        return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS["3gp"], {
          offset: 4
        });
      },
      ac3: function ac3(bytes) {
        var offset = (0, _id3Helpers.getId3Offset)(bytes);
        return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.ac3, {
          offset
        });
      },
      ts: function ts(bytes) {
        if (bytes.length < 189 && bytes.length >= 1) {
          return bytes[0] === 71;
        }
        var i = 0;
        while (i + 188 < bytes.length && i < 188) {
          if (bytes[i] === 71 && bytes[i + 188] === 71) {
            return true;
          }
          i += 1;
        }
        return false;
      },
      flac: function flac(bytes) {
        var offset = (0, _id3Helpers.getId3Offset)(bytes);
        return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.flac, {
          offset
        });
      },
      ogg: function ogg(bytes) {
        return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.ogg);
      },
      avi: function avi(bytes) {
        return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.riff) && (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.avi, {
          offset: 8
        });
      },
      wav: function wav(bytes) {
        return (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.riff) && (0, _byteHelpers.bytesMatch)(bytes, CONSTANTS.wav, {
          offset: 8
        });
      },
      "h264": function h264(bytes) {
        return (0, _nalHelpers.findH264Nal)(bytes, 7, 3).length;
      },
      "h265": function h265(bytes) {
        return (0, _nalHelpers.findH265Nal)(bytes, [32, 33], 3).length;
      }
    };
    var isLikelyTypes = Object.keys(_isLikely).filter(function(t) {
      return t !== "ts" && t !== "h264" && t !== "h265";
    }).concat(["ts", "h264", "h265"]);
    isLikelyTypes.forEach(function(type) {
      var isLikelyFn = _isLikely[type];
      _isLikely[type] = function(bytes) {
        return isLikelyFn((0, _byteHelpers.toUint8)(bytes));
      };
    });
    var isLikely = _isLikely;
    exports.isLikely = isLikely;
    var detectContainerForBytes = function detectContainerForBytes2(bytes) {
      bytes = (0, _byteHelpers.toUint8)(bytes);
      for (var i = 0; i < isLikelyTypes.length; i++) {
        var type = isLikelyTypes[i];
        if (isLikely[type](bytes)) {
          return type;
        }
      }
      return "";
    };
    exports.detectContainerForBytes = detectContainerForBytes;
    var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment2(bytes) {
      return (0, _mp4Helpers.findBox)(bytes, ["moof"]).length > 0;
    };
    exports.isLikelyFmp4MediaSegment = isLikelyFmp4MediaSegment;
  }
});

// node_modules/mux.js/lib/utils/clock.js
var require_clock = __commonJS({
  "node_modules/mux.js/lib/utils/clock.js"(exports, module) {
    var ONE_SECOND_IN_TS = 9e4;
    var secondsToVideoTs;
    var secondsToAudioTs;
    var videoTsToSeconds;
    var audioTsToSeconds;
    var audioTsToVideoTs;
    var videoTsToAudioTs;
    var metadataTsToSeconds;
    secondsToVideoTs = function(seconds) {
      return seconds * ONE_SECOND_IN_TS;
    };
    secondsToAudioTs = function(seconds, sampleRate) {
      return seconds * sampleRate;
    };
    videoTsToSeconds = function(timestamp) {
      return timestamp / ONE_SECOND_IN_TS;
    };
    audioTsToSeconds = function(timestamp, sampleRate) {
      return timestamp / sampleRate;
    };
    audioTsToVideoTs = function(timestamp, sampleRate) {
      return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
    };
    videoTsToAudioTs = function(timestamp, sampleRate) {
      return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
    };
    metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
      return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
    };
    module.exports = {
      ONE_SECOND_IN_TS,
      secondsToVideoTs,
      secondsToAudioTs,
      videoTsToSeconds,
      audioTsToSeconds,
      audioTsToVideoTs,
      videoTsToAudioTs,
      metadataTsToSeconds
    };
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    function _getPrototypeOf(t) {
      return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/isNativeFunction.js
var require_isNativeFunction = __commonJS({
  "node_modules/@babel/runtime/helpers/isNativeFunction.js"(exports, module) {
    function _isNativeFunction(t) {
      try {
        return Function.toString.call(t).indexOf("[native code]") !== -1;
      } catch (n) {
        return typeof t == "function";
      }
    }
    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/wrapNativeSuper.js
var require_wrapNativeSuper = __commonJS({
  "node_modules/@babel/runtime/helpers/wrapNativeSuper.js"(exports, module) {
    var getPrototypeOf = require_getPrototypeOf();
    var setPrototypeOf = require_setPrototypeOf();
    var isNativeFunction = require_isNativeFunction();
    var construct = require_construct();
    function _wrapNativeSuper(t) {
      var r = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return module.exports = _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (t2 === null || !isNativeFunction(t2))
          return t2;
        if (typeof t2 != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (r !== void 0) {
          if (r.has(t2))
            return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return construct(t2, arguments, getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        }), setPrototypeOf(Wrapper, t2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
    }
    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/video.js/dist/video.cjs.js
var require_video_cjs = __commonJS({
  "node_modules/video.js/dist/video.cjs.js"(exports, module) {
    "use strict";
    var window$1 = require_window();
    var document3 = require_document();
    var _extends = require_extends();
    var keycode = require_keycode();
    var _assertThisInitialized = require_assertThisInitialized();
    var _inheritsLoose2 = require_inheritsLoose();
    var safeParseTuple = require_tuple();
    var XHR = require_lib();
    var vtt = require_browser_index();
    var _construct = require_construct();
    var _inherits = require_inherits();
    var _resolveUrl = require_resolve_url();
    var m3u8Parser = require_m3u8_parser_cjs();
    var codecs_js = require_codecs();
    var mediaTypes_js = require_media_types();
    var byteHelpers = require_byte_helpers();
    var mpdParser = require_mpd_parser_cjs();
    var parseSidx = require_parse_sidx();
    var id3Helpers = require_id3_helpers();
    var containers = require_containers();
    var clock = require_clock();
    var _wrapNativeSuper = require_wrapNativeSuper();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var window__default = /* @__PURE__ */ _interopDefaultLegacy(window$1);
    var document__default = /* @__PURE__ */ _interopDefaultLegacy(document3);
    var _extends__default = /* @__PURE__ */ _interopDefaultLegacy(_extends);
    var keycode__default = /* @__PURE__ */ _interopDefaultLegacy(keycode);
    var _assertThisInitialized__default = /* @__PURE__ */ _interopDefaultLegacy(_assertThisInitialized);
    var _inheritsLoose__default = /* @__PURE__ */ _interopDefaultLegacy(_inheritsLoose2);
    var safeParseTuple__default = /* @__PURE__ */ _interopDefaultLegacy(safeParseTuple);
    var XHR__default = /* @__PURE__ */ _interopDefaultLegacy(XHR);
    var vtt__default = /* @__PURE__ */ _interopDefaultLegacy(vtt);
    var _construct__default = /* @__PURE__ */ _interopDefaultLegacy(_construct);
    var _inherits__default = /* @__PURE__ */ _interopDefaultLegacy(_inherits);
    var _resolveUrl__default = /* @__PURE__ */ _interopDefaultLegacy(_resolveUrl);
    var parseSidx__default = /* @__PURE__ */ _interopDefaultLegacy(parseSidx);
    var _wrapNativeSuper__default = /* @__PURE__ */ _interopDefaultLegacy(_wrapNativeSuper);
    var version$5 = "7.21.6";
    var hooks_ = {};
    var hooks = function hooks2(type, fn) {
      hooks_[type] = hooks_[type] || [];
      if (fn) {
        hooks_[type] = hooks_[type].concat(fn);
      }
      return hooks_[type];
    };
    var hook = function hook2(type, fn) {
      hooks(type, fn);
    };
    var removeHook = function removeHook2(type, fn) {
      var index = hooks(type).indexOf(fn);
      if (index <= -1) {
        return false;
      }
      hooks_[type] = hooks_[type].slice();
      hooks_[type].splice(index, 1);
      return true;
    };
    var hookOnce = function hookOnce2(type, fn) {
      hooks(type, [].concat(fn).map(function(original) {
        var wrapper = function wrapper2() {
          removeHook(type, wrapper2);
          return original.apply(void 0, arguments);
        };
        return wrapper;
      }));
    };
    var FullscreenApi = {
      prefixed: true
    };
    var apiMap = [
      ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
      ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"],
      ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"],
      ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"]
    ];
    var specApi = apiMap[0];
    var browserApi;
    for (i = 0; i < apiMap.length; i++) {
      if (apiMap[i][1] in document__default["default"]) {
        browserApi = apiMap[i];
        break;
      }
    }
    var i;
    if (browserApi) {
      for (_i = 0; _i < browserApi.length; _i++) {
        FullscreenApi[specApi[_i]] = browserApi[_i];
      }
      FullscreenApi.prefixed = browserApi[0] !== specApi[0];
    }
    var _i;
    var history = [];
    var LogByTypeFactory = function LogByTypeFactory2(name, log3) {
      return function(type, level, args) {
        var lvl = log3.levels[level];
        var lvlRegExp = new RegExp("^(" + lvl + ")$");
        if (type !== "log") {
          args.unshift(type.toUpperCase() + ":");
        }
        args.unshift(name + ":");
        if (history) {
          history.push([].concat(args));
          var splice = history.length - 1e3;
          history.splice(0, splice > 0 ? splice : 0);
        }
        if (!window__default["default"].console) {
          return;
        }
        var fn = window__default["default"].console[type];
        if (!fn && type === "debug") {
          fn = window__default["default"].console.info || window__default["default"].console.log;
        }
        if (!fn || !lvl || !lvlRegExp.test(type)) {
          return;
        }
        fn[Array.isArray(args) ? "apply" : "call"](window__default["default"].console, args);
      };
    };
    function createLogger$1(name) {
      var level = "info";
      var logByType;
      var log3 = function log4() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        logByType("log", level, args);
      };
      logByType = LogByTypeFactory(name, log3);
      log3.createLogger = function(subname) {
        return createLogger$1(name + ": " + subname);
      };
      log3.levels = {
        all: "debug|log|warn|error",
        off: "",
        debug: "debug|log|warn|error",
        info: "log|warn|error",
        warn: "warn|error",
        error: "error",
        DEFAULT: level
      };
      log3.level = function(lvl) {
        if (typeof lvl === "string") {
          if (!log3.levels.hasOwnProperty(lvl)) {
            throw new Error('"' + lvl + '" in not a valid log level');
          }
          level = lvl;
        }
        return level;
      };
      log3.history = function() {
        return history ? [].concat(history) : [];
      };
      log3.history.filter = function(fname) {
        return (history || []).filter(function(historyItem) {
          return new RegExp(".*" + fname + ".*").test(historyItem[0]);
        });
      };
      log3.history.clear = function() {
        if (history) {
          history.length = 0;
        }
      };
      log3.history.disable = function() {
        if (history !== null) {
          history.length = 0;
          history = null;
        }
      };
      log3.history.enable = function() {
        if (history === null) {
          history = [];
        }
      };
      log3.error = function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return logByType("error", level, args);
      };
      log3.warn = function() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return logByType("warn", level, args);
      };
      log3.debug = function() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return logByType("debug", level, args);
      };
      return log3;
    }
    var log$1 = createLogger$1("VIDEOJS");
    var createLogger = log$1.createLogger;
    var toString = Object.prototype.toString;
    var keys = function keys2(object) {
      return isObject(object) ? Object.keys(object) : [];
    };
    function each(object, fn) {
      keys(object).forEach(function(key) {
        return fn(object[key], key);
      });
    }
    function reduce(object, fn, initial) {
      if (initial === void 0) {
        initial = 0;
      }
      return keys(object).reduce(function(accum, key) {
        return fn(accum, object[key], key);
      }, initial);
    }
    function assign(target) {
      for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
      }
      if (Object.assign) {
        return _extends__default["default"].apply(void 0, [target].concat(sources));
      }
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        each(source, function(value, key) {
          target[key] = value;
        });
      });
      return target;
    }
    function isObject(value) {
      return !!value && typeof value === "object";
    }
    function isPlain(value) {
      return isObject(value) && toString.call(value) === "[object Object]" && value.constructor === Object;
    }
    function computedStyle(el, prop) {
      if (!el || !prop) {
        return "";
      }
      if (typeof window__default["default"].getComputedStyle === "function") {
        var computedStyleValue;
        try {
          computedStyleValue = window__default["default"].getComputedStyle(el);
        } catch (e) {
          return "";
        }
        return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
      }
      return "";
    }
    var USER_AGENT = window__default["default"].navigator && window__default["default"].navigator.userAgent || "";
    var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
    var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
    var IS_IPOD = /iPod/i.test(USER_AGENT);
    var IOS_VERSION = function() {
      var match = USER_AGENT.match(/OS (\d+)_/i);
      if (match && match[1]) {
        return match[1];
      }
      return null;
    }();
    var IS_ANDROID = /Android/i.test(USER_AGENT);
    var ANDROID_VERSION = function() {
      var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
      if (!match) {
        return null;
      }
      var major = match[1] && parseFloat(match[1]);
      var minor = match[2] && parseFloat(match[2]);
      if (major && minor) {
        return parseFloat(match[1] + "." + match[2]);
      } else if (major) {
        return major;
      }
      return null;
    }();
    var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;
    var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
    var IS_EDGE = /Edg/i.test(USER_AGENT);
    var IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));
    var CHROME_VERSION = function() {
      var match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
      if (match && match[2]) {
        return parseFloat(match[2]);
      }
      return null;
    }();
    var IE_VERSION = function() {
      var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
      var version3 = result && parseFloat(result[1]);
      if (!version3 && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
        version3 = 11;
      }
      return version3;
    }();
    var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
    var IS_WINDOWS = /Windows/i.test(USER_AGENT);
    var TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in window__default["default"] || window__default["default"].navigator.maxTouchPoints || window__default["default"].DocumentTouch && window__default["default"].document instanceof window__default["default"].DocumentTouch));
    var IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
    var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
    var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
    var IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
    var browser = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      IS_IPOD,
      IOS_VERSION,
      IS_ANDROID,
      ANDROID_VERSION,
      IS_NATIVE_ANDROID,
      IS_FIREFOX,
      IS_EDGE,
      IS_CHROME,
      CHROME_VERSION,
      IE_VERSION,
      IS_SAFARI,
      IS_WINDOWS,
      TOUCH_ENABLED,
      IS_IPAD,
      IS_IPHONE,
      IS_IOS,
      IS_ANY_SAFARI
    });
    function isNonBlankString(str) {
      return typeof str === "string" && Boolean(str.trim());
    }
    function throwIfWhitespace(str) {
      if (str.indexOf(" ") >= 0) {
        throw new Error("class has illegal whitespace characters");
      }
    }
    function classRegExp(className) {
      return new RegExp("(^|\\s)" + className + "($|\\s)");
    }
    function isReal() {
      return document__default["default"] === window__default["default"].document;
    }
    function isEl(value) {
      return isObject(value) && value.nodeType === 1;
    }
    function isInFrame() {
      try {
        return window__default["default"].parent !== window__default["default"].self;
      } catch (x) {
        return true;
      }
    }
    function createQuerier(method) {
      return function(selector, context) {
        if (!isNonBlankString(selector)) {
          return document__default["default"][method](null);
        }
        if (isNonBlankString(context)) {
          context = document__default["default"].querySelector(context);
        }
        var ctx = isEl(context) ? context : document__default["default"];
        return ctx[method] && ctx[method](selector);
      };
    }
    function createEl(tagName, properties, attributes, content) {
      if (tagName === void 0) {
        tagName = "div";
      }
      if (properties === void 0) {
        properties = {};
      }
      if (attributes === void 0) {
        attributes = {};
      }
      var el = document__default["default"].createElement(tagName);
      Object.getOwnPropertyNames(properties).forEach(function(propName) {
        var val = properties[propName];
        if (propName.indexOf("aria-") !== -1 || propName === "role" || propName === "type") {
          log$1.warn("Setting attributes in the second argument of createEl()\nhas been deprecated. Use the third argument instead.\n" + ("createEl(type, properties, attributes). Attempting to set " + propName + " to " + val + "."));
          el.setAttribute(propName, val);
        } else if (propName === "textContent") {
          textContent(el, val);
        } else if (el[propName] !== val || propName === "tabIndex") {
          el[propName] = val;
        }
      });
      Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
        el.setAttribute(attrName, attributes[attrName]);
      });
      if (content) {
        appendContent(el, content);
      }
      return el;
    }
    function textContent(el, text) {
      if (typeof el.textContent === "undefined") {
        el.innerText = text;
      } else {
        el.textContent = text;
      }
      return el;
    }
    function prependTo(child, parent) {
      if (parent.firstChild) {
        parent.insertBefore(child, parent.firstChild);
      } else {
        parent.appendChild(child);
      }
    }
    function hasClass(element, classToCheck) {
      throwIfWhitespace(classToCheck);
      if (element.classList) {
        return element.classList.contains(classToCheck);
      }
      return classRegExp(classToCheck).test(element.className);
    }
    function addClass(element, classToAdd) {
      if (element.classList) {
        element.classList.add(classToAdd);
      } else if (!hasClass(element, classToAdd)) {
        element.className = (element.className + " " + classToAdd).trim();
      }
      return element;
    }
    function removeClass(element, classToRemove) {
      if (!element) {
        log$1.warn("removeClass was called with an element that doesn't exist");
        return null;
      }
      if (element.classList) {
        element.classList.remove(classToRemove);
      } else {
        throwIfWhitespace(classToRemove);
        element.className = element.className.split(/\s+/).filter(function(c) {
          return c !== classToRemove;
        }).join(" ");
      }
      return element;
    }
    function toggleClass(element, classToToggle, predicate) {
      var has = hasClass(element, classToToggle);
      if (typeof predicate === "function") {
        predicate = predicate(element, classToToggle);
      }
      if (typeof predicate !== "boolean") {
        predicate = !has;
      }
      if (predicate === has) {
        return;
      }
      if (predicate) {
        addClass(element, classToToggle);
      } else {
        removeClass(element, classToToggle);
      }
      return element;
    }
    function setAttributes(el, attributes) {
      Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
        var attrValue = attributes[attrName];
        if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) {
          el.removeAttribute(attrName);
        } else {
          el.setAttribute(attrName, attrValue === true ? "" : attrValue);
        }
      });
    }
    function getAttributes(tag) {
      var obj2 = {};
      var knownBooleans = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
      if (tag && tag.attributes && tag.attributes.length > 0) {
        var attrs = tag.attributes;
        for (var i2 = attrs.length - 1; i2 >= 0; i2--) {
          var attrName = attrs[i2].name;
          var attrVal = attrs[i2].value;
          if (typeof tag[attrName] === "boolean" || knownBooleans.indexOf("," + attrName + ",") !== -1) {
            attrVal = attrVal !== null ? true : false;
          }
          obj2[attrName] = attrVal;
        }
      }
      return obj2;
    }
    function getAttribute(el, attribute) {
      return el.getAttribute(attribute);
    }
    function setAttribute(el, attribute, value) {
      el.setAttribute(attribute, value);
    }
    function removeAttribute(el, attribute) {
      el.removeAttribute(attribute);
    }
    function blockTextSelection() {
      document__default["default"].body.focus();
      document__default["default"].onselectstart = function() {
        return false;
      };
    }
    function unblockTextSelection() {
      document__default["default"].onselectstart = function() {
        return true;
      };
    }
    function getBoundingClientRect(el) {
      if (el && el.getBoundingClientRect && el.parentNode) {
        var rect = el.getBoundingClientRect();
        var result = {};
        ["bottom", "height", "left", "right", "top", "width"].forEach(function(k) {
          if (rect[k] !== void 0) {
            result[k] = rect[k];
          }
        });
        if (!result.height) {
          result.height = parseFloat(computedStyle(el, "height"));
        }
        if (!result.width) {
          result.width = parseFloat(computedStyle(el, "width"));
        }
        return result;
      }
    }
    function findPosition(el) {
      if (!el || el && !el.offsetParent) {
        return {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        };
      }
      var width = el.offsetWidth;
      var height = el.offsetHeight;
      var left = 0;
      var top = 0;
      while (el.offsetParent && el !== document__default["default"][FullscreenApi.fullscreenElement]) {
        left += el.offsetLeft;
        top += el.offsetTop;
        el = el.offsetParent;
      }
      return {
        left,
        top,
        width,
        height
      };
    }
    function getPointerPosition(el, event2) {
      var translated = {
        x: 0,
        y: 0
      };
      if (IS_IOS) {
        var item = el;
        while (item && item.nodeName.toLowerCase() !== "html") {
          var transform2 = computedStyle(item, "transform");
          if (/^matrix/.test(transform2)) {
            var values = transform2.slice(7, -1).split(/,\s/).map(Number);
            translated.x += values[4];
            translated.y += values[5];
          } else if (/^matrix3d/.test(transform2)) {
            var _values = transform2.slice(9, -1).split(/,\s/).map(Number);
            translated.x += _values[12];
            translated.y += _values[13];
          }
          item = item.parentNode;
        }
      }
      var position = {};
      var boxTarget = findPosition(event2.target);
      var box = findPosition(el);
      var boxW = box.width;
      var boxH = box.height;
      var offsetY = event2.offsetY - (box.top - boxTarget.top);
      var offsetX = event2.offsetX - (box.left - boxTarget.left);
      if (event2.changedTouches) {
        offsetX = event2.changedTouches[0].pageX - box.left;
        offsetY = event2.changedTouches[0].pageY + box.top;
        if (IS_IOS) {
          offsetX -= translated.x;
          offsetY -= translated.y;
        }
      }
      position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
      position.x = Math.max(0, Math.min(1, offsetX / boxW));
      return position;
    }
    function isTextNode(value) {
      return isObject(value) && value.nodeType === 3;
    }
    function emptyEl(el) {
      while (el.firstChild) {
        el.removeChild(el.firstChild);
      }
      return el;
    }
    function normalizeContent(content) {
      if (typeof content === "function") {
        content = content();
      }
      return (Array.isArray(content) ? content : [content]).map(function(value) {
        if (typeof value === "function") {
          value = value();
        }
        if (isEl(value) || isTextNode(value)) {
          return value;
        }
        if (typeof value === "string" && /\S/.test(value)) {
          return document__default["default"].createTextNode(value);
        }
      }).filter(function(value) {
        return value;
      });
    }
    function appendContent(el, content) {
      normalizeContent(content).forEach(function(node) {
        return el.appendChild(node);
      });
      return el;
    }
    function insertContent(el, content) {
      return appendContent(emptyEl(el), content);
    }
    function isSingleLeftClick(event2) {
      if (event2.button === void 0 && event2.buttons === void 0) {
        return true;
      }
      if (event2.button === 0 && event2.buttons === void 0) {
        return true;
      }
      if (event2.type === "mouseup" && event2.button === 0 && event2.buttons === 0) {
        return true;
      }
      if (event2.button !== 0 || event2.buttons !== 1) {
        return false;
      }
      return true;
    }
    var $ = createQuerier("querySelector");
    var $$ = createQuerier("querySelectorAll");
    var Dom = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      isReal,
      isEl,
      isInFrame,
      createEl,
      textContent,
      prependTo,
      hasClass,
      addClass,
      removeClass,
      toggleClass,
      setAttributes,
      getAttributes,
      getAttribute,
      setAttribute,
      removeAttribute,
      blockTextSelection,
      unblockTextSelection,
      getBoundingClientRect,
      findPosition,
      getPointerPosition,
      isTextNode,
      emptyEl,
      normalizeContent,
      appendContent,
      insertContent,
      isSingleLeftClick,
      $,
      $$
    });
    var _windowLoaded = false;
    var videojs$1;
    var autoSetup = function autoSetup2() {
      if (videojs$1.options.autoSetup === false) {
        return;
      }
      var vids = Array.prototype.slice.call(document__default["default"].getElementsByTagName("video"));
      var audios = Array.prototype.slice.call(document__default["default"].getElementsByTagName("audio"));
      var divs = Array.prototype.slice.call(document__default["default"].getElementsByTagName("video-js"));
      var mediaEls = vids.concat(audios, divs);
      if (mediaEls && mediaEls.length > 0) {
        for (var i2 = 0, e = mediaEls.length; i2 < e; i2++) {
          var mediaEl = mediaEls[i2];
          if (mediaEl && mediaEl.getAttribute) {
            if (mediaEl.player === void 0) {
              var options = mediaEl.getAttribute("data-setup");
              if (options !== null) {
                videojs$1(mediaEl);
              }
            }
          } else {
            autoSetupTimeout(1);
            break;
          }
        }
      } else if (!_windowLoaded) {
        autoSetupTimeout(1);
      }
    };
    function autoSetupTimeout(wait, vjs) {
      if (!isReal()) {
        return;
      }
      if (vjs) {
        videojs$1 = vjs;
      }
      window__default["default"].setTimeout(autoSetup, wait);
    }
    function setWindowLoaded() {
      _windowLoaded = true;
      window__default["default"].removeEventListener("load", setWindowLoaded);
    }
    if (isReal()) {
      if (document__default["default"].readyState === "complete") {
        setWindowLoaded();
      } else {
        window__default["default"].addEventListener("load", setWindowLoaded);
      }
    }
    var createStyleElement = function createStyleElement2(className) {
      var style2 = document__default["default"].createElement("style");
      style2.className = className;
      return style2;
    };
    var setTextContent = function setTextContent2(el, content) {
      if (el.styleSheet) {
        el.styleSheet.cssText = content;
      } else {
        el.textContent = content;
      }
    };
    var _initialGuid = 3;
    var _guid = _initialGuid;
    function newGUID() {
      return _guid++;
    }
    var FakeWeakMap;
    if (!window__default["default"].WeakMap) {
      FakeWeakMap = /* @__PURE__ */ function() {
        function FakeWeakMap2() {
          this.vdata = "vdata" + Math.floor(window__default["default"].performance && window__default["default"].performance.now() || Date.now());
          this.data = {};
        }
        var _proto = FakeWeakMap2.prototype;
        _proto.set = function set2(key, value) {
          var access = key[this.vdata] || newGUID();
          if (!key[this.vdata]) {
            key[this.vdata] = access;
          }
          this.data[access] = value;
          return this;
        };
        _proto.get = function get2(key) {
          var access = key[this.vdata];
          if (access) {
            return this.data[access];
          }
          log$1("We have no data for this element", key);
          return void 0;
        };
        _proto.has = function has(key) {
          var access = key[this.vdata];
          return access in this.data;
        };
        _proto["delete"] = function _delete(key) {
          var access = key[this.vdata];
          if (access) {
            delete this.data[access];
            delete key[this.vdata];
          }
        };
        return FakeWeakMap2;
      }();
    }
    var DomData = window__default["default"].WeakMap ? /* @__PURE__ */ new WeakMap() : new FakeWeakMap();
    function _cleanUpEvents(elem, type) {
      if (!DomData.has(elem)) {
        return;
      }
      var data = DomData.get(elem);
      if (data.handlers[type].length === 0) {
        delete data.handlers[type];
        if (elem.removeEventListener) {
          elem.removeEventListener(type, data.dispatcher, false);
        } else if (elem.detachEvent) {
          elem.detachEvent("on" + type, data.dispatcher);
        }
      }
      if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
        delete data.handlers;
        delete data.dispatcher;
        delete data.disabled;
      }
      if (Object.getOwnPropertyNames(data).length === 0) {
        DomData["delete"](elem);
      }
    }
    function _handleMultipleEvents(fn, elem, types, callback) {
      types.forEach(function(type) {
        fn(elem, type, callback);
      });
    }
    function fixEvent(event2) {
      if (event2.fixed_) {
        return event2;
      }
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      if (!event2 || !event2.isPropagationStopped || !event2.isImmediatePropagationStopped) {
        var old = event2 || window__default["default"].event;
        event2 = {};
        for (var key in old) {
          if (key !== "layerX" && key !== "layerY" && key !== "keyLocation" && key !== "webkitMovementX" && key !== "webkitMovementY" && key !== "path") {
            if (!(key === "returnValue" && old.preventDefault)) {
              event2[key] = old[key];
            }
          }
        }
        if (!event2.target) {
          event2.target = event2.srcElement || document__default["default"];
        }
        if (!event2.relatedTarget) {
          event2.relatedTarget = event2.fromElement === event2.target ? event2.toElement : event2.fromElement;
        }
        event2.preventDefault = function() {
          if (old.preventDefault) {
            old.preventDefault();
          }
          event2.returnValue = false;
          old.returnValue = false;
          event2.defaultPrevented = true;
        };
        event2.defaultPrevented = false;
        event2.stopPropagation = function() {
          if (old.stopPropagation) {
            old.stopPropagation();
          }
          event2.cancelBubble = true;
          old.cancelBubble = true;
          event2.isPropagationStopped = returnTrue;
        };
        event2.isPropagationStopped = returnFalse;
        event2.stopImmediatePropagation = function() {
          if (old.stopImmediatePropagation) {
            old.stopImmediatePropagation();
          }
          event2.isImmediatePropagationStopped = returnTrue;
          event2.stopPropagation();
        };
        event2.isImmediatePropagationStopped = returnFalse;
        if (event2.clientX !== null && event2.clientX !== void 0) {
          var doc = document__default["default"].documentElement;
          var body = document__default["default"].body;
          event2.pageX = event2.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event2.pageY = event2.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        event2.which = event2.charCode || event2.keyCode;
        if (event2.button !== null && event2.button !== void 0) {
          event2.button = event2.button & 1 ? 0 : event2.button & 4 ? 1 : event2.button & 2 ? 2 : 0;
        }
      }
      event2.fixed_ = true;
      return event2;
    }
    var _supportsPassive;
    var supportsPassive = function supportsPassive2() {
      if (typeof _supportsPassive !== "boolean") {
        _supportsPassive = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function get2() {
              _supportsPassive = true;
            }
          });
          window__default["default"].addEventListener("test", null, opts);
          window__default["default"].removeEventListener("test", null, opts);
        } catch (e) {
        }
      }
      return _supportsPassive;
    };
    var passiveEvents = ["touchstart", "touchmove"];
    function on(elem, type, fn) {
      if (Array.isArray(type)) {
        return _handleMultipleEvents(on, elem, type, fn);
      }
      if (!DomData.has(elem)) {
        DomData.set(elem, {});
      }
      var data = DomData.get(elem);
      if (!data.handlers) {
        data.handlers = {};
      }
      if (!data.handlers[type]) {
        data.handlers[type] = [];
      }
      if (!fn.guid) {
        fn.guid = newGUID();
      }
      data.handlers[type].push(fn);
      if (!data.dispatcher) {
        data.disabled = false;
        data.dispatcher = function(event2, hash) {
          if (data.disabled) {
            return;
          }
          event2 = fixEvent(event2);
          var handlers = data.handlers[event2.type];
          if (handlers) {
            var handlersCopy = handlers.slice(0);
            for (var m = 0, n = handlersCopy.length; m < n; m++) {
              if (event2.isImmediatePropagationStopped()) {
                break;
              } else {
                try {
                  handlersCopy[m].call(elem, event2, hash);
                } catch (e) {
                  log$1.error(e);
                }
              }
            }
          }
        };
      }
      if (data.handlers[type].length === 1) {
        if (elem.addEventListener) {
          var options = false;
          if (supportsPassive() && passiveEvents.indexOf(type) > -1) {
            options = {
              passive: true
            };
          }
          elem.addEventListener(type, data.dispatcher, options);
        } else if (elem.attachEvent) {
          elem.attachEvent("on" + type, data.dispatcher);
        }
      }
    }
    function off(elem, type, fn) {
      if (!DomData.has(elem)) {
        return;
      }
      var data = DomData.get(elem);
      if (!data.handlers) {
        return;
      }
      if (Array.isArray(type)) {
        return _handleMultipleEvents(off, elem, type, fn);
      }
      var removeType = function removeType2(el, t2) {
        data.handlers[t2] = [];
        _cleanUpEvents(el, t2);
      };
      if (type === void 0) {
        for (var t in data.handlers) {
          if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
            removeType(elem, t);
          }
        }
        return;
      }
      var handlers = data.handlers[type];
      if (!handlers) {
        return;
      }
      if (!fn) {
        removeType(elem, type);
        return;
      }
      if (fn.guid) {
        for (var n = 0; n < handlers.length; n++) {
          if (handlers[n].guid === fn.guid) {
            handlers.splice(n--, 1);
          }
        }
      }
      _cleanUpEvents(elem, type);
    }
    function trigger(elem, event2, hash) {
      var elemData = DomData.has(elem) ? DomData.get(elem) : {};
      var parent = elem.parentNode || elem.ownerDocument;
      if (typeof event2 === "string") {
        event2 = {
          type: event2,
          target: elem
        };
      } else if (!event2.target) {
        event2.target = elem;
      }
      event2 = fixEvent(event2);
      if (elemData.dispatcher) {
        elemData.dispatcher.call(elem, event2, hash);
      }
      if (parent && !event2.isPropagationStopped() && event2.bubbles === true) {
        trigger.call(null, parent, event2, hash);
      } else if (!parent && !event2.defaultPrevented && event2.target && event2.target[event2.type]) {
        if (!DomData.has(event2.target)) {
          DomData.set(event2.target, {});
        }
        var targetData = DomData.get(event2.target);
        if (event2.target[event2.type]) {
          targetData.disabled = true;
          if (typeof event2.target[event2.type] === "function") {
            event2.target[event2.type]();
          }
          targetData.disabled = false;
        }
      }
      return !event2.defaultPrevented;
    }
    function one(elem, type, fn) {
      if (Array.isArray(type)) {
        return _handleMultipleEvents(one, elem, type, fn);
      }
      var func = function func2() {
        off(elem, type, func2);
        fn.apply(this, arguments);
      };
      func.guid = fn.guid = fn.guid || newGUID();
      on(elem, type, func);
    }
    function any(elem, type, fn) {
      var func = function func2() {
        off(elem, type, func2);
        fn.apply(this, arguments);
      };
      func.guid = fn.guid = fn.guid || newGUID();
      on(elem, type, func);
    }
    var Events = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      fixEvent,
      on,
      off,
      trigger,
      one,
      any
    });
    var UPDATE_REFRESH_INTERVAL = 30;
    var bind = function bind2(context, fn, uid) {
      if (!fn.guid) {
        fn.guid = newGUID();
      }
      var bound = fn.bind(context);
      bound.guid = uid ? uid + "_" + fn.guid : fn.guid;
      return bound;
    };
    var throttle = function throttle2(fn, wait) {
      var last = window__default["default"].performance.now();
      var throttled = function throttled2() {
        var now = window__default["default"].performance.now();
        if (now - last >= wait) {
          fn.apply(void 0, arguments);
          last = now;
        }
      };
      return throttled;
    };
    var debounce = function debounce2(func, wait, immediate, context) {
      if (context === void 0) {
        context = window__default["default"];
      }
      var timeout;
      var cancel = function cancel2() {
        context.clearTimeout(timeout);
        timeout = null;
      };
      var debounced = function debounced2() {
        var self2 = this;
        var args = arguments;
        var _later = function later() {
          timeout = null;
          _later = null;
          if (!immediate) {
            func.apply(self2, args);
          }
        };
        if (!timeout && immediate) {
          func.apply(self2, args);
        }
        context.clearTimeout(timeout);
        timeout = context.setTimeout(_later, wait);
      };
      debounced.cancel = cancel;
      return debounced;
    };
    var EventTarget$2 = function EventTarget2() {
    };
    EventTarget$2.prototype.allowedEvents_ = {};
    EventTarget$2.prototype.on = function(type, fn) {
      var ael = this.addEventListener;
      this.addEventListener = function() {
      };
      on(this, type, fn);
      this.addEventListener = ael;
    };
    EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
    EventTarget$2.prototype.off = function(type, fn) {
      off(this, type, fn);
    };
    EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
    EventTarget$2.prototype.one = function(type, fn) {
      var ael = this.addEventListener;
      this.addEventListener = function() {
      };
      one(this, type, fn);
      this.addEventListener = ael;
    };
    EventTarget$2.prototype.any = function(type, fn) {
      var ael = this.addEventListener;
      this.addEventListener = function() {
      };
      any(this, type, fn);
      this.addEventListener = ael;
    };
    EventTarget$2.prototype.trigger = function(event2) {
      var type = event2.type || event2;
      if (typeof event2 === "string") {
        event2 = {
          type
        };
      }
      event2 = fixEvent(event2);
      if (this.allowedEvents_[type] && this["on" + type]) {
        this["on" + type](event2);
      }
      trigger(this, event2);
    };
    EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
    var EVENT_MAP;
    EventTarget$2.prototype.queueTrigger = function(event2) {
      var _this = this;
      if (!EVENT_MAP) {
        EVENT_MAP = /* @__PURE__ */ new Map();
      }
      var type = event2.type || event2;
      var map = EVENT_MAP.get(this);
      if (!map) {
        map = /* @__PURE__ */ new Map();
        EVENT_MAP.set(this, map);
      }
      var oldTimeout = map.get(type);
      map["delete"](type);
      window__default["default"].clearTimeout(oldTimeout);
      var timeout = window__default["default"].setTimeout(function() {
        map["delete"](type);
        if (map.size === 0) {
          map = null;
          EVENT_MAP["delete"](_this);
        }
        _this.trigger(event2);
      }, 0);
      map.set(type, timeout);
    };
    var objName = function objName2(obj2) {
      if (typeof obj2.name === "function") {
        return obj2.name();
      }
      if (typeof obj2.name === "string") {
        return obj2.name;
      }
      if (obj2.name_) {
        return obj2.name_;
      }
      if (obj2.constructor && obj2.constructor.name) {
        return obj2.constructor.name;
      }
      return typeof obj2;
    };
    var isEvented = function isEvented2(object) {
      return object instanceof EventTarget$2 || !!object.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(k) {
        return typeof object[k] === "function";
      });
    };
    var addEventedCallback = function addEventedCallback2(target, callback) {
      if (isEvented(target)) {
        callback();
      } else {
        if (!target.eventedCallbacks) {
          target.eventedCallbacks = [];
        }
        target.eventedCallbacks.push(callback);
      }
    };
    var isValidEventType = function isValidEventType2(type) {
      return typeof type === "string" && /\S/.test(type) || Array.isArray(type) && !!type.length;
    };
    var validateTarget = function validateTarget2(target, obj2, fnName) {
      if (!target || !target.nodeName && !isEvented(target)) {
        throw new Error("Invalid target for " + objName(obj2) + "#" + fnName + "; must be a DOM node or evented object.");
      }
    };
    var validateEventType = function validateEventType2(type, obj2, fnName) {
      if (!isValidEventType(type)) {
        throw new Error("Invalid event type for " + objName(obj2) + "#" + fnName + "; must be a non-empty string or array.");
      }
    };
    var validateListener = function validateListener2(listener, obj2, fnName) {
      if (typeof listener !== "function") {
        throw new Error("Invalid listener for " + objName(obj2) + "#" + fnName + "; must be a function.");
      }
    };
    var normalizeListenArgs = function normalizeListenArgs2(self2, args, fnName) {
      var isTargetingSelf = args.length < 3 || args[0] === self2 || args[0] === self2.eventBusEl_;
      var target;
      var type;
      var listener;
      if (isTargetingSelf) {
        target = self2.eventBusEl_;
        if (args.length >= 3) {
          args.shift();
        }
        type = args[0];
        listener = args[1];
      } else {
        target = args[0];
        type = args[1];
        listener = args[2];
      }
      validateTarget(target, self2, fnName);
      validateEventType(type, self2, fnName);
      validateListener(listener, self2, fnName);
      listener = bind(self2, listener);
      return {
        isTargetingSelf,
        target,
        type,
        listener
      };
    };
    var listen = function listen2(target, method, type, listener) {
      validateTarget(target, target, method);
      if (target.nodeName) {
        Events[method](target, type, listener);
      } else {
        target[method](type, listener);
      }
    };
    var EventedMixin = {
      on: function on2() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var _normalizeListenArgs = normalizeListenArgs(this, args, "on"), isTargetingSelf = _normalizeListenArgs.isTargetingSelf, target = _normalizeListenArgs.target, type = _normalizeListenArgs.type, listener = _normalizeListenArgs.listener;
        listen(target, "on", type, listener);
        if (!isTargetingSelf) {
          var removeListenerOnDispose = function removeListenerOnDispose2() {
            return _this.off(target, type, listener);
          };
          removeListenerOnDispose.guid = listener.guid;
          var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose2() {
            return _this.off("dispose", removeListenerOnDispose);
          };
          removeRemoverOnTargetDispose.guid = listener.guid;
          listen(this, "on", "dispose", removeListenerOnDispose);
          listen(target, "on", "dispose", removeRemoverOnTargetDispose);
        }
      },
      one: function one2() {
        var _this2 = this;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        var _normalizeListenArgs2 = normalizeListenArgs(this, args, "one"), isTargetingSelf = _normalizeListenArgs2.isTargetingSelf, target = _normalizeListenArgs2.target, type = _normalizeListenArgs2.type, listener = _normalizeListenArgs2.listener;
        if (isTargetingSelf) {
          listen(target, "one", type, listener);
        } else {
          var wrapper = function wrapper2() {
            _this2.off(target, type, wrapper2);
            for (var _len3 = arguments.length, largs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              largs[_key3] = arguments[_key3];
            }
            listener.apply(null, largs);
          };
          wrapper.guid = listener.guid;
          listen(target, "one", type, wrapper);
        }
      },
      any: function any2() {
        var _this3 = this;
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        var _normalizeListenArgs3 = normalizeListenArgs(this, args, "any"), isTargetingSelf = _normalizeListenArgs3.isTargetingSelf, target = _normalizeListenArgs3.target, type = _normalizeListenArgs3.type, listener = _normalizeListenArgs3.listener;
        if (isTargetingSelf) {
          listen(target, "any", type, listener);
        } else {
          var wrapper = function wrapper2() {
            _this3.off(target, type, wrapper2);
            for (var _len5 = arguments.length, largs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              largs[_key5] = arguments[_key5];
            }
            listener.apply(null, largs);
          };
          wrapper.guid = listener.guid;
          listen(target, "any", type, wrapper);
        }
      },
      off: function off$1(targetOrType, typeOrListener, listener) {
        if (!targetOrType || isValidEventType(targetOrType)) {
          off(this.eventBusEl_, targetOrType, typeOrListener);
        } else {
          var target = targetOrType;
          var type = typeOrListener;
          validateTarget(target, this, "off");
          validateEventType(type, this, "off");
          validateListener(listener, this, "off");
          listener = bind(this, listener);
          this.off("dispose", listener);
          if (target.nodeName) {
            off(target, type, listener);
            off(target, "dispose", listener);
          } else if (isEvented(target)) {
            target.off(type, listener);
            target.off("dispose", listener);
          }
        }
      },
      trigger: function trigger$1(event2, hash) {
        validateTarget(this.eventBusEl_, this, "trigger");
        var type = event2 && typeof event2 !== "string" ? event2.type : event2;
        if (!isValidEventType(type)) {
          var error = "Invalid event type for " + objName(this) + "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
          if (event2) {
            (this.log || log$1).error(error);
          } else {
            throw new Error(error);
          }
        }
        return trigger(this.eventBusEl_, event2, hash);
      }
    };
    function evented(target, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, eventBusKey = _options.eventBusKey;
      if (eventBusKey) {
        if (!target[eventBusKey].nodeName) {
          throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
        }
        target.eventBusEl_ = target[eventBusKey];
      } else {
        target.eventBusEl_ = createEl("span", {
          className: "vjs-event-bus"
        });
      }
      assign(target, EventedMixin);
      if (target.eventedCallbacks) {
        target.eventedCallbacks.forEach(function(callback) {
          callback();
        });
      }
      target.on("dispose", function() {
        target.off();
        [target, target.el_, target.eventBusEl_].forEach(function(val) {
          if (val && DomData.has(val)) {
            DomData["delete"](val);
          }
        });
        window__default["default"].setTimeout(function() {
          target.eventBusEl_ = null;
        }, 0);
      });
      return target;
    }
    var StatefulMixin = {
      state: {},
      setState: function setState(stateUpdates) {
        var _this = this;
        if (typeof stateUpdates === "function") {
          stateUpdates = stateUpdates();
        }
        var changes;
        each(stateUpdates, function(value, key) {
          if (_this.state[key] !== value) {
            changes = changes || {};
            changes[key] = {
              from: _this.state[key],
              to: value
            };
          }
          _this.state[key] = value;
        });
        if (changes && isEvented(this)) {
          this.trigger({
            changes,
            type: "statechanged"
          });
        }
        return changes;
      }
    };
    function stateful(target, defaultState) {
      assign(target, StatefulMixin);
      target.state = assign({}, target.state, defaultState);
      if (typeof target.handleStateChanged === "function" && isEvented(target)) {
        target.on("statechanged", target.handleStateChanged);
      }
      return target;
    }
    var toLowerCase = function toLowerCase2(string) {
      if (typeof string !== "string") {
        return string;
      }
      return string.replace(/./, function(w) {
        return w.toLowerCase();
      });
    };
    var toTitleCase$1 = function toTitleCase2(string) {
      if (typeof string !== "string") {
        return string;
      }
      return string.replace(/./, function(w) {
        return w.toUpperCase();
      });
    };
    var titleCaseEquals = function titleCaseEquals2(str1, str2) {
      return toTitleCase$1(str1) === toTitleCase$1(str2);
    };
    function mergeOptions$3() {
      var result = {};
      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        each(source, function(value, key) {
          if (!isPlain(value)) {
            result[key] = value;
            return;
          }
          if (!isPlain(result[key])) {
            result[key] = {};
          }
          result[key] = mergeOptions$3(result[key], value);
        });
      });
      return result;
    }
    var MapSham = /* @__PURE__ */ function() {
      function MapSham2() {
        this.map_ = {};
      }
      var _proto = MapSham2.prototype;
      _proto.has = function has(key) {
        return key in this.map_;
      };
      _proto["delete"] = function _delete(key) {
        var has = this.has(key);
        delete this.map_[key];
        return has;
      };
      _proto.set = function set2(key, value) {
        this.map_[key] = value;
        return this;
      };
      _proto.forEach = function forEach(callback, thisArg) {
        for (var key in this.map_) {
          callback.call(thisArg, this.map_[key], key, this);
        }
      };
      return MapSham2;
    }();
    var Map$1 = window__default["default"].Map ? window__default["default"].Map : MapSham;
    var SetSham = /* @__PURE__ */ function() {
      function SetSham2() {
        this.set_ = {};
      }
      var _proto = SetSham2.prototype;
      _proto.has = function has(key) {
        return key in this.set_;
      };
      _proto["delete"] = function _delete(key) {
        var has = this.has(key);
        delete this.set_[key];
        return has;
      };
      _proto.add = function add(key) {
        this.set_[key] = 1;
        return this;
      };
      _proto.forEach = function forEach(callback, thisArg) {
        for (var key in this.set_) {
          callback.call(thisArg, key, key, this);
        }
      };
      return SetSham2;
    }();
    var Set$1 = window__default["default"].Set ? window__default["default"].Set : SetSham;
    var Component$1 = /* @__PURE__ */ function() {
      function Component2(player, options, ready) {
        var _this = this;
        if (!player && this.play) {
          this.player_ = player = this;
        } else {
          this.player_ = player;
        }
        this.isDisposed_ = false;
        this.parentComponent_ = null;
        this.options_ = mergeOptions$3({}, this.options_);
        options = this.options_ = mergeOptions$3(this.options_, options);
        this.id_ = options.id || options.el && options.el.id;
        if (!this.id_) {
          var id = player && player.id && player.id() || "no_player";
          this.id_ = id + "_component_" + newGUID();
        }
        this.name_ = options.name || null;
        if (options.el) {
          this.el_ = options.el;
        } else if (options.createEl !== false) {
          this.el_ = this.createEl();
        }
        if (options.className && this.el_) {
          options.className.split(" ").forEach(function(c) {
            return _this.addClass(c);
          });
        }
        if (options.evented !== false) {
          evented(this, {
            eventBusKey: this.el_ ? "el_" : null
          });
          this.handleLanguagechange = this.handleLanguagechange.bind(this);
          this.on(this.player_, "languagechange", this.handleLanguagechange);
        }
        stateful(this, this.constructor.defaultState);
        this.children_ = [];
        this.childIndex_ = {};
        this.childNameIndex_ = {};
        this.setTimeoutIds_ = new Set$1();
        this.setIntervalIds_ = new Set$1();
        this.rafIds_ = new Set$1();
        this.namedRafs_ = new Map$1();
        this.clearingTimersOnDispose_ = false;
        if (options.initChildren !== false) {
          this.initChildren();
        }
        this.ready(ready);
        if (options.reportTouchActivity !== false) {
          this.enableTouchActivity();
        }
      }
      var _proto = Component2.prototype;
      _proto.dispose = function dispose(options) {
        if (options === void 0) {
          options = {};
        }
        if (this.isDisposed_) {
          return;
        }
        if (this.readyQueue_) {
          this.readyQueue_.length = 0;
        }
        this.trigger({
          type: "dispose",
          bubbles: false
        });
        this.isDisposed_ = true;
        if (this.children_) {
          for (var i2 = this.children_.length - 1; i2 >= 0; i2--) {
            if (this.children_[i2].dispose) {
              this.children_[i2].dispose();
            }
          }
        }
        this.children_ = null;
        this.childIndex_ = null;
        this.childNameIndex_ = null;
        this.parentComponent_ = null;
        if (this.el_) {
          if (this.el_.parentNode) {
            if (options.restoreEl) {
              this.el_.parentNode.replaceChild(options.restoreEl, this.el_);
            } else {
              this.el_.parentNode.removeChild(this.el_);
            }
          }
          this.el_ = null;
        }
        this.player_ = null;
      };
      _proto.isDisposed = function isDisposed() {
        return Boolean(this.isDisposed_);
      };
      _proto.player = function player() {
        return this.player_;
      };
      _proto.options = function options(obj2) {
        if (!obj2) {
          return this.options_;
        }
        this.options_ = mergeOptions$3(this.options_, obj2);
        return this.options_;
      };
      _proto.el = function el() {
        return this.el_;
      };
      _proto.createEl = function createEl$1(tagName, properties, attributes) {
        return createEl(tagName, properties, attributes);
      };
      _proto.localize = function localize(string, tokens, defaultValue) {
        if (defaultValue === void 0) {
          defaultValue = string;
        }
        var code = this.player_.language && this.player_.language();
        var languages = this.player_.languages && this.player_.languages();
        var language = languages && languages[code];
        var primaryCode = code && code.split("-")[0];
        var primaryLang = languages && languages[primaryCode];
        var localizedString = defaultValue;
        if (language && language[string]) {
          localizedString = language[string];
        } else if (primaryLang && primaryLang[string]) {
          localizedString = primaryLang[string];
        }
        if (tokens) {
          localizedString = localizedString.replace(/\{(\d+)\}/g, function(match, index) {
            var value = tokens[index - 1];
            var ret = value;
            if (typeof value === "undefined") {
              ret = match;
            }
            return ret;
          });
        }
        return localizedString;
      };
      _proto.handleLanguagechange = function handleLanguagechange() {
      };
      _proto.contentEl = function contentEl() {
        return this.contentEl_ || this.el_;
      };
      _proto.id = function id() {
        return this.id_;
      };
      _proto.name = function name() {
        return this.name_;
      };
      _proto.children = function children() {
        return this.children_;
      };
      _proto.getChildById = function getChildById(id) {
        return this.childIndex_[id];
      };
      _proto.getChild = function getChild(name) {
        if (!name) {
          return;
        }
        return this.childNameIndex_[name];
      };
      _proto.getDescendant = function getDescendant() {
        for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
          names[_key] = arguments[_key];
        }
        names = names.reduce(function(acc, n) {
          return acc.concat(n);
        }, []);
        var currentChild = this;
        for (var i2 = 0; i2 < names.length; i2++) {
          currentChild = currentChild.getChild(names[i2]);
          if (!currentChild || !currentChild.getChild) {
            return;
          }
        }
        return currentChild;
      };
      _proto.addChild = function addChild(child, options, index) {
        if (options === void 0) {
          options = {};
        }
        if (index === void 0) {
          index = this.children_.length;
        }
        var component;
        var componentName;
        if (typeof child === "string") {
          componentName = toTitleCase$1(child);
          var componentClassName = options.componentClass || componentName;
          options.name = componentName;
          var ComponentClass = Component2.getComponent(componentClassName);
          if (!ComponentClass) {
            throw new Error("Component " + componentClassName + " does not exist");
          }
          if (typeof ComponentClass !== "function") {
            return null;
          }
          component = new ComponentClass(this.player_ || this, options);
        } else {
          component = child;
        }
        if (component.parentComponent_) {
          component.parentComponent_.removeChild(component);
        }
        this.children_.splice(index, 0, component);
        component.parentComponent_ = this;
        if (typeof component.id === "function") {
          this.childIndex_[component.id()] = component;
        }
        componentName = componentName || component.name && toTitleCase$1(component.name());
        if (componentName) {
          this.childNameIndex_[componentName] = component;
          this.childNameIndex_[toLowerCase(componentName)] = component;
        }
        if (typeof component.el === "function" && component.el()) {
          var refNode = null;
          if (this.children_[index + 1]) {
            if (this.children_[index + 1].el_) {
              refNode = this.children_[index + 1].el_;
            } else if (isEl(this.children_[index + 1])) {
              refNode = this.children_[index + 1];
            }
          }
          this.contentEl().insertBefore(component.el(), refNode);
        }
        return component;
      };
      _proto.removeChild = function removeChild(component) {
        if (typeof component === "string") {
          component = this.getChild(component);
        }
        if (!component || !this.children_) {
          return;
        }
        var childFound = false;
        for (var i2 = this.children_.length - 1; i2 >= 0; i2--) {
          if (this.children_[i2] === component) {
            childFound = true;
            this.children_.splice(i2, 1);
            break;
          }
        }
        if (!childFound) {
          return;
        }
        component.parentComponent_ = null;
        this.childIndex_[component.id()] = null;
        this.childNameIndex_[toTitleCase$1(component.name())] = null;
        this.childNameIndex_[toLowerCase(component.name())] = null;
        var compEl = component.el();
        if (compEl && compEl.parentNode === this.contentEl()) {
          this.contentEl().removeChild(component.el());
        }
      };
      _proto.initChildren = function initChildren() {
        var _this2 = this;
        var children = this.options_.children;
        if (children) {
          var parentOptions = this.options_;
          var handleAdd = function handleAdd2(child) {
            var name = child.name;
            var opts = child.opts;
            if (parentOptions[name] !== void 0) {
              opts = parentOptions[name];
            }
            if (opts === false) {
              return;
            }
            if (opts === true) {
              opts = {};
            }
            opts.playerOptions = _this2.options_.playerOptions;
            var newChild = _this2.addChild(name, opts);
            if (newChild) {
              _this2[name] = newChild;
            }
          };
          var workingChildren;
          var Tech2 = Component2.getComponent("Tech");
          if (Array.isArray(children)) {
            workingChildren = children;
          } else {
            workingChildren = Object.keys(children);
          }
          workingChildren.concat(Object.keys(this.options_).filter(function(child) {
            return !workingChildren.some(function(wchild) {
              if (typeof wchild === "string") {
                return child === wchild;
              }
              return child === wchild.name;
            });
          })).map(function(child) {
            var name;
            var opts;
            if (typeof child === "string") {
              name = child;
              opts = children[name] || _this2.options_[name] || {};
            } else {
              name = child.name;
              opts = child;
            }
            return {
              name,
              opts
            };
          }).filter(function(child) {
            var c = Component2.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
            return c && !Tech2.isTech(c);
          }).forEach(handleAdd);
        }
      };
      _proto.buildCSSClass = function buildCSSClass() {
        return "";
      };
      _proto.ready = function ready(fn, sync) {
        if (sync === void 0) {
          sync = false;
        }
        if (!fn) {
          return;
        }
        if (!this.isReady_) {
          this.readyQueue_ = this.readyQueue_ || [];
          this.readyQueue_.push(fn);
          return;
        }
        if (sync) {
          fn.call(this);
        } else {
          this.setTimeout(fn, 1);
        }
      };
      _proto.triggerReady = function triggerReady() {
        this.isReady_ = true;
        this.setTimeout(function() {
          var readyQueue = this.readyQueue_;
          this.readyQueue_ = [];
          if (readyQueue && readyQueue.length > 0) {
            readyQueue.forEach(function(fn) {
              fn.call(this);
            }, this);
          }
          this.trigger("ready");
        }, 1);
      };
      _proto.$ = function $$1(selector, context) {
        return $(selector, context || this.contentEl());
      };
      _proto.$$ = function $$$1(selector, context) {
        return $$(selector, context || this.contentEl());
      };
      _proto.hasClass = function hasClass$1(classToCheck) {
        return hasClass(this.el_, classToCheck);
      };
      _proto.addClass = function addClass$1(classToAdd) {
        addClass(this.el_, classToAdd);
      };
      _proto.removeClass = function removeClass$1(classToRemove) {
        removeClass(this.el_, classToRemove);
      };
      _proto.toggleClass = function toggleClass$1(classToToggle, predicate) {
        toggleClass(this.el_, classToToggle, predicate);
      };
      _proto.show = function show() {
        this.removeClass("vjs-hidden");
      };
      _proto.hide = function hide() {
        this.addClass("vjs-hidden");
      };
      _proto.lockShowing = function lockShowing() {
        this.addClass("vjs-lock-showing");
      };
      _proto.unlockShowing = function unlockShowing() {
        this.removeClass("vjs-lock-showing");
      };
      _proto.getAttribute = function getAttribute$1(attribute) {
        return getAttribute(this.el_, attribute);
      };
      _proto.setAttribute = function setAttribute$1(attribute, value) {
        setAttribute(this.el_, attribute, value);
      };
      _proto.removeAttribute = function removeAttribute$1(attribute) {
        removeAttribute(this.el_, attribute);
      };
      _proto.width = function width(num, skipListeners) {
        return this.dimension("width", num, skipListeners);
      };
      _proto.height = function height(num, skipListeners) {
        return this.dimension("height", num, skipListeners);
      };
      _proto.dimensions = function dimensions(width, height) {
        this.width(width, true);
        this.height(height);
      };
      _proto.dimension = function dimension(widthOrHeight, num, skipListeners) {
        if (num !== void 0) {
          if (num === null || num !== num) {
            num = 0;
          }
          if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) {
            this.el_.style[widthOrHeight] = num;
          } else if (num === "auto") {
            this.el_.style[widthOrHeight] = "";
          } else {
            this.el_.style[widthOrHeight] = num + "px";
          }
          if (!skipListeners) {
            this.trigger("componentresize");
          }
          return;
        }
        if (!this.el_) {
          return 0;
        }
        var val = this.el_.style[widthOrHeight];
        var pxIndex = val.indexOf("px");
        if (pxIndex !== -1) {
          return parseInt(val.slice(0, pxIndex), 10);
        }
        return parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
      };
      _proto.currentDimension = function currentDimension(widthOrHeight) {
        var computedWidthOrHeight = 0;
        if (widthOrHeight !== "width" && widthOrHeight !== "height") {
          throw new Error("currentDimension only accepts width or height value");
        }
        computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
        computedWidthOrHeight = parseFloat(computedWidthOrHeight);
        if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
          var rule = "offset" + toTitleCase$1(widthOrHeight);
          computedWidthOrHeight = this.el_[rule];
        }
        return computedWidthOrHeight;
      };
      _proto.currentDimensions = function currentDimensions() {
        return {
          width: this.currentDimension("width"),
          height: this.currentDimension("height")
        };
      };
      _proto.currentWidth = function currentWidth() {
        return this.currentDimension("width");
      };
      _proto.currentHeight = function currentHeight() {
        return this.currentDimension("height");
      };
      _proto.focus = function focus() {
        this.el_.focus();
      };
      _proto.blur = function blur() {
        this.el_.blur();
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (this.player_) {
          if (!keycode__default["default"].isEventKey(event2, "Tab")) {
            event2.stopPropagation();
          }
          this.player_.handleKeyDown(event2);
        }
      };
      _proto.handleKeyPress = function handleKeyPress(event2) {
        this.handleKeyDown(event2);
      };
      _proto.emitTapEvents = function emitTapEvents() {
        var touchStart = 0;
        var firstTouch = null;
        var tapMovementThreshold = 10;
        var touchTimeThreshold = 200;
        var couldBeTap;
        this.on("touchstart", function(event2) {
          if (event2.touches.length === 1) {
            firstTouch = {
              pageX: event2.touches[0].pageX,
              pageY: event2.touches[0].pageY
            };
            touchStart = window__default["default"].performance.now();
            couldBeTap = true;
          }
        });
        this.on("touchmove", function(event2) {
          if (event2.touches.length > 1) {
            couldBeTap = false;
          } else if (firstTouch) {
            var xdiff = event2.touches[0].pageX - firstTouch.pageX;
            var ydiff = event2.touches[0].pageY - firstTouch.pageY;
            var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
            if (touchDistance > tapMovementThreshold) {
              couldBeTap = false;
            }
          }
        });
        var noTap = function noTap2() {
          couldBeTap = false;
        };
        this.on("touchleave", noTap);
        this.on("touchcancel", noTap);
        this.on("touchend", function(event2) {
          firstTouch = null;
          if (couldBeTap === true) {
            var touchTime = window__default["default"].performance.now() - touchStart;
            if (touchTime < touchTimeThreshold) {
              event2.preventDefault();
              this.trigger("tap");
            }
          }
        });
      };
      _proto.enableTouchActivity = function enableTouchActivity() {
        if (!this.player() || !this.player().reportUserActivity) {
          return;
        }
        var report = bind(this.player(), this.player().reportUserActivity);
        var touchHolding;
        this.on("touchstart", function() {
          report();
          this.clearInterval(touchHolding);
          touchHolding = this.setInterval(report, 250);
        });
        var touchEnd = function touchEnd2(event2) {
          report();
          this.clearInterval(touchHolding);
        };
        this.on("touchmove", report);
        this.on("touchend", touchEnd);
        this.on("touchcancel", touchEnd);
      };
      _proto.setTimeout = function setTimeout2(fn, timeout) {
        var _this3 = this;
        var timeoutId;
        fn = bind(this, fn);
        this.clearTimersOnDispose_();
        timeoutId = window__default["default"].setTimeout(function() {
          if (_this3.setTimeoutIds_.has(timeoutId)) {
            _this3.setTimeoutIds_["delete"](timeoutId);
          }
          fn();
        }, timeout);
        this.setTimeoutIds_.add(timeoutId);
        return timeoutId;
      };
      _proto.clearTimeout = function clearTimeout2(timeoutId) {
        if (this.setTimeoutIds_.has(timeoutId)) {
          this.setTimeoutIds_["delete"](timeoutId);
          window__default["default"].clearTimeout(timeoutId);
        }
        return timeoutId;
      };
      _proto.setInterval = function setInterval(fn, interval) {
        fn = bind(this, fn);
        this.clearTimersOnDispose_();
        var intervalId = window__default["default"].setInterval(fn, interval);
        this.setIntervalIds_.add(intervalId);
        return intervalId;
      };
      _proto.clearInterval = function clearInterval(intervalId) {
        if (this.setIntervalIds_.has(intervalId)) {
          this.setIntervalIds_["delete"](intervalId);
          window__default["default"].clearInterval(intervalId);
        }
        return intervalId;
      };
      _proto.requestAnimationFrame = function requestAnimationFrame(fn) {
        var _this4 = this;
        if (!this.supportsRaf_) {
          return this.setTimeout(fn, 1e3 / 60);
        }
        this.clearTimersOnDispose_();
        var id;
        fn = bind(this, fn);
        id = window__default["default"].requestAnimationFrame(function() {
          if (_this4.rafIds_.has(id)) {
            _this4.rafIds_["delete"](id);
          }
          fn();
        });
        this.rafIds_.add(id);
        return id;
      };
      _proto.requestNamedAnimationFrame = function requestNamedAnimationFrame(name, fn) {
        var _this5 = this;
        if (this.namedRafs_.has(name)) {
          return;
        }
        this.clearTimersOnDispose_();
        fn = bind(this, fn);
        var id = this.requestAnimationFrame(function() {
          fn();
          if (_this5.namedRafs_.has(name)) {
            _this5.namedRafs_["delete"](name);
          }
        });
        this.namedRafs_.set(name, id);
        return name;
      };
      _proto.cancelNamedAnimationFrame = function cancelNamedAnimationFrame(name) {
        if (!this.namedRafs_.has(name)) {
          return;
        }
        this.cancelAnimationFrame(this.namedRafs_.get(name));
        this.namedRafs_["delete"](name);
      };
      _proto.cancelAnimationFrame = function cancelAnimationFrame(id) {
        if (!this.supportsRaf_) {
          return this.clearTimeout(id);
        }
        if (this.rafIds_.has(id)) {
          this.rafIds_["delete"](id);
          window__default["default"].cancelAnimationFrame(id);
        }
        return id;
      };
      _proto.clearTimersOnDispose_ = function clearTimersOnDispose_() {
        var _this6 = this;
        if (this.clearingTimersOnDispose_) {
          return;
        }
        this.clearingTimersOnDispose_ = true;
        this.one("dispose", function() {
          [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(function(_ref) {
            var idName = _ref[0], cancelName = _ref[1];
            _this6[idName].forEach(function(val, key) {
              return _this6[cancelName](key);
            });
          });
          _this6.clearingTimersOnDispose_ = false;
        });
      };
      Component2.registerComponent = function registerComponent(name, ComponentToRegister) {
        if (typeof name !== "string" || !name) {
          throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
        }
        var Tech2 = Component2.getComponent("Tech");
        var isTech = Tech2 && Tech2.isTech(ComponentToRegister);
        var isComp = Component2 === ComponentToRegister || Component2.prototype.isPrototypeOf(ComponentToRegister.prototype);
        if (isTech || !isComp) {
          var reason;
          if (isTech) {
            reason = "techs must be registered using Tech.registerTech()";
          } else {
            reason = "must be a Component subclass";
          }
          throw new Error('Illegal component, "' + name + '"; ' + reason + ".");
        }
        name = toTitleCase$1(name);
        if (!Component2.components_) {
          Component2.components_ = {};
        }
        var Player2 = Component2.getComponent("Player");
        if (name === "Player" && Player2 && Player2.players) {
          var players = Player2.players;
          var playerNames = Object.keys(players);
          if (players && playerNames.length > 0 && playerNames.map(function(pname) {
            return players[pname];
          }).every(Boolean)) {
            throw new Error("Can not register Player component after player has been created.");
          }
        }
        Component2.components_[name] = ComponentToRegister;
        Component2.components_[toLowerCase(name)] = ComponentToRegister;
        return ComponentToRegister;
      };
      Component2.getComponent = function getComponent(name) {
        if (!name || !Component2.components_) {
          return;
        }
        return Component2.components_[name];
      };
      return Component2;
    }();
    Component$1.prototype.supportsRaf_ = typeof window__default["default"].requestAnimationFrame === "function" && typeof window__default["default"].cancelAnimationFrame === "function";
    Component$1.registerComponent("Component", Component$1);
    function rangeCheck(fnName, index, maxIndex) {
      if (typeof index !== "number" || index < 0 || index > maxIndex) {
        throw new Error("Failed to execute '" + fnName + "' on 'TimeRanges': The index provided (" + index + ") is non-numeric or out of bounds (0-" + maxIndex + ").");
      }
    }
    function getRange(fnName, valueIndex, ranges, rangeIndex) {
      rangeCheck(fnName, rangeIndex, ranges.length - 1);
      return ranges[rangeIndex][valueIndex];
    }
    function createTimeRangesObj(ranges) {
      var timeRangesObj;
      if (ranges === void 0 || ranges.length === 0) {
        timeRangesObj = {
          length: 0,
          start: function start2() {
            throw new Error("This TimeRanges object is empty");
          },
          end: function end2() {
            throw new Error("This TimeRanges object is empty");
          }
        };
      } else {
        timeRangesObj = {
          length: ranges.length,
          start: getRange.bind(null, "start", 0, ranges),
          end: getRange.bind(null, "end", 1, ranges)
        };
      }
      if (window__default["default"].Symbol && window__default["default"].Symbol.iterator) {
        timeRangesObj[window__default["default"].Symbol.iterator] = function() {
          return (ranges || []).values();
        };
      }
      return timeRangesObj;
    }
    function createTimeRanges(start2, end2) {
      if (Array.isArray(start2)) {
        return createTimeRangesObj(start2);
      } else if (start2 === void 0 || end2 === void 0) {
        return createTimeRangesObj();
      }
      return createTimeRangesObj([[start2, end2]]);
    }
    function bufferedPercent(buffered, duration2) {
      var bufferedDuration = 0;
      var start2;
      var end2;
      if (!duration2) {
        return 0;
      }
      if (!buffered || !buffered.length) {
        buffered = createTimeRanges(0, 0);
      }
      for (var i2 = 0; i2 < buffered.length; i2++) {
        start2 = buffered.start(i2);
        end2 = buffered.end(i2);
        if (end2 > duration2) {
          end2 = duration2;
        }
        bufferedDuration += end2 - start2;
      }
      return bufferedDuration / duration2;
    }
    function MediaError(value) {
      if (value instanceof MediaError) {
        return value;
      }
      if (typeof value === "number") {
        this.code = value;
      } else if (typeof value === "string") {
        this.message = value;
      } else if (isObject(value)) {
        if (typeof value.code === "number") {
          this.code = value.code;
        }
        assign(this, value);
      }
      if (!this.message) {
        this.message = MediaError.defaultMessages[this.code] || "";
      }
    }
    MediaError.prototype.code = 0;
    MediaError.prototype.message = "";
    MediaError.prototype.status = null;
    MediaError.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
    MediaError.defaultMessages = {
      1: "You aborted the media playback",
      2: "A network error caused the media download to fail part-way.",
      3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
      4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
      5: "The media is encrypted and we do not have the keys to decrypt it."
    };
    for (errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
      MediaError[MediaError.errorTypes[errNum]] = errNum;
      MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
    }
    var errNum;
    function isPromise(value) {
      return value !== void 0 && value !== null && typeof value.then === "function";
    }
    function silencePromise(value) {
      if (isPromise(value)) {
        value.then(null, function(e) {
        });
      }
    }
    var trackToJson_ = function trackToJson_2(track) {
      var ret = ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(function(acc, prop, i2) {
        if (track[prop]) {
          acc[prop] = track[prop];
        }
        return acc;
      }, {
        cues: track.cues && Array.prototype.map.call(track.cues, function(cue) {
          return {
            startTime: cue.startTime,
            endTime: cue.endTime,
            text: cue.text,
            id: cue.id
          };
        })
      });
      return ret;
    };
    var textTracksToJson = function textTracksToJson2(tech) {
      var trackEls = tech.$$("track");
      var trackObjs = Array.prototype.map.call(trackEls, function(t) {
        return t.track;
      });
      var tracks = Array.prototype.map.call(trackEls, function(trackEl) {
        var json = trackToJson_(trackEl.track);
        if (trackEl.src) {
          json.src = trackEl.src;
        }
        return json;
      });
      return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function(track) {
        return trackObjs.indexOf(track) === -1;
      }).map(trackToJson_));
    };
    var jsonToTextTracks = function jsonToTextTracks2(json, tech) {
      json.forEach(function(track) {
        var addedTrack = tech.addRemoteTextTrack(track).track;
        if (!track.src && track.cues) {
          track.cues.forEach(function(cue) {
            return addedTrack.addCue(cue);
          });
        }
      });
      return tech.textTracks();
    };
    var textTrackConverter = {
      textTracksToJson,
      jsonToTextTracks,
      trackToJson_
    };
    var MODAL_CLASS_NAME = "vjs-modal-dialog";
    var ModalDialog = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](ModalDialog2, _Component);
      function ModalDialog2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.handleKeyDown_ = function(e) {
          return _this.handleKeyDown(e);
        };
        _this.close_ = function(e) {
          return _this.close(e);
        };
        _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;
        _this.closeable(!_this.options_.uncloseable);
        _this.content(_this.options_.content);
        _this.contentEl_ = createEl("div", {
          className: MODAL_CLASS_NAME + "-content"
        }, {
          role: "document"
        });
        _this.descEl_ = createEl("p", {
          className: MODAL_CLASS_NAME + "-description vjs-control-text",
          id: _this.el().getAttribute("aria-describedby")
        });
        textContent(_this.descEl_, _this.description());
        _this.el_.appendChild(_this.descEl_);
        _this.el_.appendChild(_this.contentEl_);
        return _this;
      }
      var _proto = ModalDialog2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: this.buildCSSClass(),
          tabIndex: -1
        }, {
          "aria-describedby": this.id() + "_description",
          "aria-hidden": "true",
          "aria-label": this.label(),
          "role": "dialog"
        });
      };
      _proto.dispose = function dispose() {
        this.contentEl_ = null;
        this.descEl_ = null;
        this.previouslyActiveEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      _proto.buildCSSClass = function buildCSSClass() {
        return MODAL_CLASS_NAME + " vjs-hidden " + _Component.prototype.buildCSSClass.call(this);
      };
      _proto.label = function label() {
        return this.localize(this.options_.label || "Modal Window");
      };
      _proto.description = function description() {
        var desc = this.options_.description || this.localize("This is a modal window.");
        if (this.closeable()) {
          desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
        }
        return desc;
      };
      _proto.open = function open() {
        if (!this.opened_) {
          var player = this.player();
          this.trigger("beforemodalopen");
          this.opened_ = true;
          if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
            this.fill();
          }
          this.wasPlaying_ = !player.paused();
          if (this.options_.pauseOnOpen && this.wasPlaying_) {
            player.pause();
          }
          this.on("keydown", this.handleKeyDown_);
          this.hadControls_ = player.controls();
          player.controls(false);
          this.show();
          this.conditionalFocus_();
          this.el().setAttribute("aria-hidden", "false");
          this.trigger("modalopen");
          this.hasBeenOpened_ = true;
        }
      };
      _proto.opened = function opened(value) {
        if (typeof value === "boolean") {
          this[value ? "open" : "close"]();
        }
        return this.opened_;
      };
      _proto.close = function close() {
        if (!this.opened_) {
          return;
        }
        var player = this.player();
        this.trigger("beforemodalclose");
        this.opened_ = false;
        if (this.wasPlaying_ && this.options_.pauseOnOpen) {
          player.play();
        }
        this.off("keydown", this.handleKeyDown_);
        if (this.hadControls_) {
          player.controls(true);
        }
        this.hide();
        this.el().setAttribute("aria-hidden", "true");
        this.trigger("modalclose");
        this.conditionalBlur_();
        if (this.options_.temporary) {
          this.dispose();
        }
      };
      _proto.closeable = function closeable(value) {
        if (typeof value === "boolean") {
          var closeable2 = this.closeable_ = !!value;
          var close = this.getChild("closeButton");
          if (closeable2 && !close) {
            var temp = this.contentEl_;
            this.contentEl_ = this.el_;
            close = this.addChild("closeButton", {
              controlText: "Close Modal Dialog"
            });
            this.contentEl_ = temp;
            this.on(close, "close", this.close_);
          }
          if (!closeable2 && close) {
            this.off(close, "close", this.close_);
            this.removeChild(close);
            close.dispose();
          }
        }
        return this.closeable_;
      };
      _proto.fill = function fill() {
        this.fillWith(this.content());
      };
      _proto.fillWith = function fillWith(content) {
        var contentEl = this.contentEl();
        var parentEl = contentEl.parentNode;
        var nextSiblingEl = contentEl.nextSibling;
        this.trigger("beforemodalfill");
        this.hasBeenFilled_ = true;
        parentEl.removeChild(contentEl);
        this.empty();
        insertContent(contentEl, content);
        this.trigger("modalfill");
        if (nextSiblingEl) {
          parentEl.insertBefore(contentEl, nextSiblingEl);
        } else {
          parentEl.appendChild(contentEl);
        }
        var closeButton = this.getChild("closeButton");
        if (closeButton) {
          parentEl.appendChild(closeButton.el_);
        }
      };
      _proto.empty = function empty() {
        this.trigger("beforemodalempty");
        emptyEl(this.contentEl());
        this.trigger("modalempty");
      };
      _proto.content = function content(value) {
        if (typeof value !== "undefined") {
          this.content_ = value;
        }
        return this.content_;
      };
      _proto.conditionalFocus_ = function conditionalFocus_() {
        var activeEl = document__default["default"].activeElement;
        var playerEl = this.player_.el_;
        this.previouslyActiveEl_ = null;
        if (playerEl.contains(activeEl) || playerEl === activeEl) {
          this.previouslyActiveEl_ = activeEl;
          this.focus();
        }
      };
      _proto.conditionalBlur_ = function conditionalBlur_() {
        if (this.previouslyActiveEl_) {
          this.previouslyActiveEl_.focus();
          this.previouslyActiveEl_ = null;
        }
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        event2.stopPropagation();
        if (keycode__default["default"].isEventKey(event2, "Escape") && this.closeable()) {
          event2.preventDefault();
          this.close();
          return;
        }
        if (!keycode__default["default"].isEventKey(event2, "Tab")) {
          return;
        }
        var focusableEls = this.focusableEls_();
        var activeEl = this.el_.querySelector(":focus");
        var focusIndex;
        for (var i2 = 0; i2 < focusableEls.length; i2++) {
          if (activeEl === focusableEls[i2]) {
            focusIndex = i2;
            break;
          }
        }
        if (document__default["default"].activeElement === this.el_) {
          focusIndex = 0;
        }
        if (event2.shiftKey && focusIndex === 0) {
          focusableEls[focusableEls.length - 1].focus();
          event2.preventDefault();
        } else if (!event2.shiftKey && focusIndex === focusableEls.length - 1) {
          focusableEls[0].focus();
          event2.preventDefault();
        }
      };
      _proto.focusableEls_ = function focusableEls_() {
        var allChildren = this.el_.querySelectorAll("*");
        return Array.prototype.filter.call(allChildren, function(child) {
          return (child instanceof window__default["default"].HTMLAnchorElement || child instanceof window__default["default"].HTMLAreaElement) && child.hasAttribute("href") || (child instanceof window__default["default"].HTMLInputElement || child instanceof window__default["default"].HTMLSelectElement || child instanceof window__default["default"].HTMLTextAreaElement || child instanceof window__default["default"].HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof window__default["default"].HTMLIFrameElement || child instanceof window__default["default"].HTMLObjectElement || child instanceof window__default["default"].HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable");
        });
      };
      return ModalDialog2;
    }(Component$1);
    ModalDialog.prototype.options_ = {
      pauseOnOpen: true,
      temporary: true
    };
    Component$1.registerComponent("ModalDialog", ModalDialog);
    var TrackList = /* @__PURE__ */ function(_EventTarget) {
      _inheritsLoose__default["default"](TrackList2, _EventTarget);
      function TrackList2(tracks) {
        var _this;
        if (tracks === void 0) {
          tracks = [];
        }
        _this = _EventTarget.call(this) || this;
        _this.tracks_ = [];
        Object.defineProperty(_assertThisInitialized__default["default"](_this), "length", {
          get: function get2() {
            return this.tracks_.length;
          }
        });
        for (var i2 = 0; i2 < tracks.length; i2++) {
          _this.addTrack(tracks[i2]);
        }
        return _this;
      }
      var _proto = TrackList2.prototype;
      _proto.addTrack = function addTrack(track) {
        var _this2 = this;
        var index = this.tracks_.length;
        if (!("" + index in this)) {
          Object.defineProperty(this, index, {
            get: function get2() {
              return this.tracks_[index];
            }
          });
        }
        if (this.tracks_.indexOf(track) === -1) {
          this.tracks_.push(track);
          this.trigger({
            track,
            type: "addtrack",
            target: this
          });
        }
        track.labelchange_ = function() {
          _this2.trigger({
            track,
            type: "labelchange",
            target: _this2
          });
        };
        if (isEvented(track)) {
          track.addEventListener("labelchange", track.labelchange_);
        }
      };
      _proto.removeTrack = function removeTrack(rtrack) {
        var track;
        for (var i2 = 0, l = this.length; i2 < l; i2++) {
          if (this[i2] === rtrack) {
            track = this[i2];
            if (track.off) {
              track.off();
            }
            this.tracks_.splice(i2, 1);
            break;
          }
        }
        if (!track) {
          return;
        }
        this.trigger({
          track,
          type: "removetrack",
          target: this
        });
      };
      _proto.getTrackById = function getTrackById(id) {
        var result = null;
        for (var i2 = 0, l = this.length; i2 < l; i2++) {
          var track = this[i2];
          if (track.id === id) {
            result = track;
            break;
          }
        }
        return result;
      };
      return TrackList2;
    }(EventTarget$2);
    TrackList.prototype.allowedEvents_ = {
      change: "change",
      addtrack: "addtrack",
      removetrack: "removetrack",
      labelchange: "labelchange"
    };
    for (event in TrackList.prototype.allowedEvents_) {
      TrackList.prototype["on" + event] = null;
    }
    var event;
    var disableOthers$1 = function disableOthers2(list, track) {
      for (var i2 = 0; i2 < list.length; i2++) {
        if (!Object.keys(list[i2]).length || track.id === list[i2].id) {
          continue;
        }
        list[i2].enabled = false;
      }
    };
    var AudioTrackList = /* @__PURE__ */ function(_TrackList) {
      _inheritsLoose__default["default"](AudioTrackList2, _TrackList);
      function AudioTrackList2(tracks) {
        var _this;
        if (tracks === void 0) {
          tracks = [];
        }
        for (var i2 = tracks.length - 1; i2 >= 0; i2--) {
          if (tracks[i2].enabled) {
            disableOthers$1(tracks, tracks[i2]);
            break;
          }
        }
        _this = _TrackList.call(this, tracks) || this;
        _this.changing_ = false;
        return _this;
      }
      var _proto = AudioTrackList2.prototype;
      _proto.addTrack = function addTrack(track) {
        var _this2 = this;
        if (track.enabled) {
          disableOthers$1(this, track);
        }
        _TrackList.prototype.addTrack.call(this, track);
        if (!track.addEventListener) {
          return;
        }
        track.enabledChange_ = function() {
          if (_this2.changing_) {
            return;
          }
          _this2.changing_ = true;
          disableOthers$1(_this2, track);
          _this2.changing_ = false;
          _this2.trigger("change");
        };
        track.addEventListener("enabledchange", track.enabledChange_);
      };
      _proto.removeTrack = function removeTrack(rtrack) {
        _TrackList.prototype.removeTrack.call(this, rtrack);
        if (rtrack.removeEventListener && rtrack.enabledChange_) {
          rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
          rtrack.enabledChange_ = null;
        }
      };
      return AudioTrackList2;
    }(TrackList);
    var disableOthers = function disableOthers2(list, track) {
      for (var i2 = 0; i2 < list.length; i2++) {
        if (!Object.keys(list[i2]).length || track.id === list[i2].id) {
          continue;
        }
        list[i2].selected = false;
      }
    };
    var VideoTrackList = /* @__PURE__ */ function(_TrackList) {
      _inheritsLoose__default["default"](VideoTrackList2, _TrackList);
      function VideoTrackList2(tracks) {
        var _this;
        if (tracks === void 0) {
          tracks = [];
        }
        for (var i2 = tracks.length - 1; i2 >= 0; i2--) {
          if (tracks[i2].selected) {
            disableOthers(tracks, tracks[i2]);
            break;
          }
        }
        _this = _TrackList.call(this, tracks) || this;
        _this.changing_ = false;
        Object.defineProperty(_assertThisInitialized__default["default"](_this), "selectedIndex", {
          get: function get2() {
            for (var _i2 = 0; _i2 < this.length; _i2++) {
              if (this[_i2].selected) {
                return _i2;
              }
            }
            return -1;
          },
          set: function set2() {
          }
        });
        return _this;
      }
      var _proto = VideoTrackList2.prototype;
      _proto.addTrack = function addTrack(track) {
        var _this2 = this;
        if (track.selected) {
          disableOthers(this, track);
        }
        _TrackList.prototype.addTrack.call(this, track);
        if (!track.addEventListener) {
          return;
        }
        track.selectedChange_ = function() {
          if (_this2.changing_) {
            return;
          }
          _this2.changing_ = true;
          disableOthers(_this2, track);
          _this2.changing_ = false;
          _this2.trigger("change");
        };
        track.addEventListener("selectedchange", track.selectedChange_);
      };
      _proto.removeTrack = function removeTrack(rtrack) {
        _TrackList.prototype.removeTrack.call(this, rtrack);
        if (rtrack.removeEventListener && rtrack.selectedChange_) {
          rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
          rtrack.selectedChange_ = null;
        }
      };
      return VideoTrackList2;
    }(TrackList);
    var TextTrackList = /* @__PURE__ */ function(_TrackList) {
      _inheritsLoose__default["default"](TextTrackList2, _TrackList);
      function TextTrackList2() {
        return _TrackList.apply(this, arguments) || this;
      }
      var _proto = TextTrackList2.prototype;
      _proto.addTrack = function addTrack(track) {
        var _this = this;
        _TrackList.prototype.addTrack.call(this, track);
        if (!this.queueChange_) {
          this.queueChange_ = function() {
            return _this.queueTrigger("change");
          };
        }
        if (!this.triggerSelectedlanguagechange) {
          this.triggerSelectedlanguagechange_ = function() {
            return _this.trigger("selectedlanguagechange");
          };
        }
        track.addEventListener("modechange", this.queueChange_);
        var nonLanguageTextTrackKind = ["metadata", "chapters"];
        if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
          track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
        }
      };
      _proto.removeTrack = function removeTrack(rtrack) {
        _TrackList.prototype.removeTrack.call(this, rtrack);
        if (rtrack.removeEventListener) {
          if (this.queueChange_) {
            rtrack.removeEventListener("modechange", this.queueChange_);
          }
          if (this.selectedlanguagechange_) {
            rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
          }
        }
      };
      return TextTrackList2;
    }(TrackList);
    var HtmlTrackElementList = /* @__PURE__ */ function() {
      function HtmlTrackElementList2(trackElements) {
        if (trackElements === void 0) {
          trackElements = [];
        }
        this.trackElements_ = [];
        Object.defineProperty(this, "length", {
          get: function get2() {
            return this.trackElements_.length;
          }
        });
        for (var i2 = 0, length = trackElements.length; i2 < length; i2++) {
          this.addTrackElement_(trackElements[i2]);
        }
      }
      var _proto = HtmlTrackElementList2.prototype;
      _proto.addTrackElement_ = function addTrackElement_(trackElement) {
        var index = this.trackElements_.length;
        if (!("" + index in this)) {
          Object.defineProperty(this, index, {
            get: function get2() {
              return this.trackElements_[index];
            }
          });
        }
        if (this.trackElements_.indexOf(trackElement) === -1) {
          this.trackElements_.push(trackElement);
        }
      };
      _proto.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
        var trackElement_;
        for (var i2 = 0, length = this.trackElements_.length; i2 < length; i2++) {
          if (track === this.trackElements_[i2].track) {
            trackElement_ = this.trackElements_[i2];
            break;
          }
        }
        return trackElement_;
      };
      _proto.removeTrackElement_ = function removeTrackElement_(trackElement) {
        for (var i2 = 0, length = this.trackElements_.length; i2 < length; i2++) {
          if (trackElement === this.trackElements_[i2]) {
            if (this.trackElements_[i2].track && typeof this.trackElements_[i2].track.off === "function") {
              this.trackElements_[i2].track.off();
            }
            if (typeof this.trackElements_[i2].off === "function") {
              this.trackElements_[i2].off();
            }
            this.trackElements_.splice(i2, 1);
            break;
          }
        }
      };
      return HtmlTrackElementList2;
    }();
    var TextTrackCueList = /* @__PURE__ */ function() {
      function TextTrackCueList2(cues) {
        TextTrackCueList2.prototype.setCues_.call(this, cues);
        Object.defineProperty(this, "length", {
          get: function get2() {
            return this.length_;
          }
        });
      }
      var _proto = TextTrackCueList2.prototype;
      _proto.setCues_ = function setCues_(cues) {
        var oldLength = this.length || 0;
        var i2 = 0;
        var l = cues.length;
        this.cues_ = cues;
        this.length_ = cues.length;
        var defineProp = function defineProp2(index) {
          if (!("" + index in this)) {
            Object.defineProperty(this, "" + index, {
              get: function get2() {
                return this.cues_[index];
              }
            });
          }
        };
        if (oldLength < l) {
          i2 = oldLength;
          for (; i2 < l; i2++) {
            defineProp.call(this, i2);
          }
        }
      };
      _proto.getCueById = function getCueById(id) {
        var result = null;
        for (var i2 = 0, l = this.length; i2 < l; i2++) {
          var cue = this[i2];
          if (cue.id === id) {
            result = cue;
            break;
          }
        }
        return result;
      };
      return TextTrackCueList2;
    }();
    var VideoTrackKind = {
      alternative: "alternative",
      captions: "captions",
      main: "main",
      sign: "sign",
      subtitles: "subtitles",
      commentary: "commentary"
    };
    var AudioTrackKind = {
      "alternative": "alternative",
      "descriptions": "descriptions",
      "main": "main",
      "main-desc": "main-desc",
      "translation": "translation",
      "commentary": "commentary"
    };
    var TextTrackKind = {
      subtitles: "subtitles",
      captions: "captions",
      descriptions: "descriptions",
      chapters: "chapters",
      metadata: "metadata"
    };
    var TextTrackMode = {
      disabled: "disabled",
      hidden: "hidden",
      showing: "showing"
    };
    var Track = /* @__PURE__ */ function(_EventTarget) {
      _inheritsLoose__default["default"](Track2, _EventTarget);
      function Track2(options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _EventTarget.call(this) || this;
        var trackProps = {
          id: options.id || "vjs_track_" + newGUID(),
          kind: options.kind || "",
          language: options.language || ""
        };
        var label = options.label || "";
        var _loop = function _loop2(key2) {
          Object.defineProperty(_assertThisInitialized__default["default"](_this), key2, {
            get: function get2() {
              return trackProps[key2];
            },
            set: function set2() {
            }
          });
        };
        for (var key in trackProps) {
          _loop(key);
        }
        Object.defineProperty(_assertThisInitialized__default["default"](_this), "label", {
          get: function get2() {
            return label;
          },
          set: function set2(newLabel) {
            if (newLabel !== label) {
              label = newLabel;
              this.trigger("labelchange");
            }
          }
        });
        return _this;
      }
      return Track2;
    }(EventTarget$2);
    var parseUrl = function parseUrl2(url) {
      var props = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"];
      var a = document__default["default"].createElement("a");
      a.href = url;
      var details = {};
      for (var i2 = 0; i2 < props.length; i2++) {
        details[props[i2]] = a[props[i2]];
      }
      if (details.protocol === "http:") {
        details.host = details.host.replace(/:80$/, "");
      }
      if (details.protocol === "https:") {
        details.host = details.host.replace(/:443$/, "");
      }
      if (!details.protocol) {
        details.protocol = window__default["default"].location.protocol;
      }
      if (!details.host) {
        details.host = window__default["default"].location.host;
      }
      return details;
    };
    var getAbsoluteURL = function getAbsoluteURL2(url) {
      if (!url.match(/^https?:\/\//)) {
        var a = document__default["default"].createElement("a");
        a.href = url;
        url = a.href;
      }
      return url;
    };
    var getFileExtension = function getFileExtension2(path) {
      if (typeof path === "string") {
        var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
        var pathParts = splitPathRe.exec(path);
        if (pathParts) {
          return pathParts.pop().toLowerCase();
        }
      }
      return "";
    };
    var isCrossOrigin = function isCrossOrigin2(url, winLoc) {
      if (winLoc === void 0) {
        winLoc = window__default["default"].location;
      }
      var urlInfo = parseUrl(url);
      var srcProtocol = urlInfo.protocol === ":" ? winLoc.protocol : urlInfo.protocol;
      var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
      return crossOrigin;
    };
    var Url = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      parseUrl,
      getAbsoluteURL,
      getFileExtension,
      isCrossOrigin
    });
    var parseCues = function parseCues2(srcContent, track) {
      var parser = new window__default["default"].WebVTT.Parser(window__default["default"], window__default["default"].vttjs, window__default["default"].WebVTT.StringDecoder());
      var errors = [];
      parser.oncue = function(cue) {
        track.addCue(cue);
      };
      parser.onparsingerror = function(error) {
        errors.push(error);
      };
      parser.onflush = function() {
        track.trigger({
          type: "loadeddata",
          target: track
        });
      };
      parser.parse(srcContent);
      if (errors.length > 0) {
        if (window__default["default"].console && window__default["default"].console.groupCollapsed) {
          window__default["default"].console.groupCollapsed("Text Track parsing errors for " + track.src);
        }
        errors.forEach(function(error) {
          return log$1.error(error);
        });
        if (window__default["default"].console && window__default["default"].console.groupEnd) {
          window__default["default"].console.groupEnd();
        }
      }
      parser.flush();
    };
    var loadTrack = function loadTrack2(src, track) {
      var opts = {
        uri: src
      };
      var crossOrigin = isCrossOrigin(src);
      if (crossOrigin) {
        opts.cors = crossOrigin;
      }
      var withCredentials = track.tech_.crossOrigin() === "use-credentials";
      if (withCredentials) {
        opts.withCredentials = withCredentials;
      }
      XHR__default["default"](opts, bind(this, function(err, response, responseBody) {
        if (err) {
          return log$1.error(err, response);
        }
        track.loaded_ = true;
        if (typeof window__default["default"].WebVTT !== "function") {
          if (track.tech_) {
            track.tech_.any(["vttjsloaded", "vttjserror"], function(event2) {
              if (event2.type === "vttjserror") {
                log$1.error("vttjs failed to load, stopping trying to process " + track.src);
                return;
              }
              return parseCues(responseBody, track);
            });
          }
        } else {
          parseCues(responseBody, track);
        }
      }));
    };
    var TextTrack = /* @__PURE__ */ function(_Track) {
      _inheritsLoose__default["default"](TextTrack2, _Track);
      function TextTrack2(options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        if (!options.tech) {
          throw new Error("A tech was not provided.");
        }
        var settings2 = mergeOptions$3(options, {
          kind: TextTrackKind[options.kind] || "subtitles",
          language: options.language || options.srclang || ""
        });
        var mode = TextTrackMode[settings2.mode] || "disabled";
        var default_ = settings2["default"];
        if (settings2.kind === "metadata" || settings2.kind === "chapters") {
          mode = "hidden";
        }
        _this = _Track.call(this, settings2) || this;
        _this.tech_ = settings2.tech;
        _this.cues_ = [];
        _this.activeCues_ = [];
        _this.preload_ = _this.tech_.preloadTextTracks !== false;
        var cues = new TextTrackCueList(_this.cues_);
        var activeCues = new TextTrackCueList(_this.activeCues_);
        var changed = false;
        _this.timeupdateHandler = bind(_assertThisInitialized__default["default"](_this), function(event2) {
          if (event2 === void 0) {
            event2 = {};
          }
          if (this.tech_.isDisposed()) {
            return;
          }
          if (!this.tech_.isReady_) {
            if (event2.type !== "timeupdate") {
              this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
            }
            return;
          }
          this.activeCues = this.activeCues;
          if (changed) {
            this.trigger("cuechange");
            changed = false;
          }
          if (event2.type !== "timeupdate") {
            this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
          }
        });
        var disposeHandler = function disposeHandler2() {
          _this.stopTracking();
        };
        _this.tech_.one("dispose", disposeHandler);
        if (mode !== "disabled") {
          _this.startTracking();
        }
        Object.defineProperties(_assertThisInitialized__default["default"](_this), {
          "default": {
            get: function get2() {
              return default_;
            },
            set: function set2() {
            }
          },
          mode: {
            get: function get2() {
              return mode;
            },
            set: function set2(newMode) {
              if (!TextTrackMode[newMode]) {
                return;
              }
              if (mode === newMode) {
                return;
              }
              mode = newMode;
              if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) {
                loadTrack(this.src, this);
              }
              this.stopTracking();
              if (mode !== "disabled") {
                this.startTracking();
              }
              this.trigger("modechange");
            }
          },
          cues: {
            get: function get2() {
              if (!this.loaded_) {
                return null;
              }
              return cues;
            },
            set: function set2() {
            }
          },
          activeCues: {
            get: function get2() {
              if (!this.loaded_) {
                return null;
              }
              if (this.cues.length === 0) {
                return activeCues;
              }
              var ct = this.tech_.currentTime();
              var active = [];
              for (var i2 = 0, l = this.cues.length; i2 < l; i2++) {
                var cue = this.cues[i2];
                if (cue.startTime <= ct && cue.endTime >= ct) {
                  active.push(cue);
                } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
                  active.push(cue);
                }
              }
              changed = false;
              if (active.length !== this.activeCues_.length) {
                changed = true;
              } else {
                for (var _i2 = 0; _i2 < active.length; _i2++) {
                  if (this.activeCues_.indexOf(active[_i2]) === -1) {
                    changed = true;
                  }
                }
              }
              this.activeCues_ = active;
              activeCues.setCues_(this.activeCues_);
              return activeCues;
            },
            set: function set2() {
            }
          }
        });
        if (settings2.src) {
          _this.src = settings2.src;
          if (!_this.preload_) {
            _this.loaded_ = true;
          }
          if (_this.preload_ || settings2.kind !== "subtitles" && settings2.kind !== "captions") {
            loadTrack(_this.src, _assertThisInitialized__default["default"](_this));
          }
        } else {
          _this.loaded_ = true;
        }
        return _this;
      }
      var _proto = TextTrack2.prototype;
      _proto.startTracking = function startTracking() {
        this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
        this.tech_.on("timeupdate", this.timeupdateHandler);
      };
      _proto.stopTracking = function stopTracking() {
        if (this.rvf_) {
          this.tech_.cancelVideoFrameCallback(this.rvf_);
          this.rvf_ = void 0;
        }
        this.tech_.off("timeupdate", this.timeupdateHandler);
      };
      _proto.addCue = function addCue(originalCue) {
        var cue = originalCue;
        if (cue.constructor && cue.constructor.name !== "VTTCue") {
          cue = new window__default["default"].vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
          for (var prop in originalCue) {
            if (!(prop in cue)) {
              cue[prop] = originalCue[prop];
            }
          }
          cue.id = originalCue.id;
          cue.originalCue_ = originalCue;
        }
        var tracks = this.tech_.textTracks();
        for (var i2 = 0; i2 < tracks.length; i2++) {
          if (tracks[i2] !== this) {
            tracks[i2].removeCue(cue);
          }
        }
        this.cues_.push(cue);
        this.cues.setCues_(this.cues_);
      };
      _proto.removeCue = function removeCue(_removeCue) {
        var i2 = this.cues_.length;
        while (i2--) {
          var cue = this.cues_[i2];
          if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
            this.cues_.splice(i2, 1);
            this.cues.setCues_(this.cues_);
            break;
          }
        }
      };
      return TextTrack2;
    }(Track);
    TextTrack.prototype.allowedEvents_ = {
      cuechange: "cuechange"
    };
    var AudioTrack = /* @__PURE__ */ function(_Track) {
      _inheritsLoose__default["default"](AudioTrack2, _Track);
      function AudioTrack2(options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        var settings2 = mergeOptions$3(options, {
          kind: AudioTrackKind[options.kind] || ""
        });
        _this = _Track.call(this, settings2) || this;
        var enabled = false;
        Object.defineProperty(_assertThisInitialized__default["default"](_this), "enabled", {
          get: function get2() {
            return enabled;
          },
          set: function set2(newEnabled) {
            if (typeof newEnabled !== "boolean" || newEnabled === enabled) {
              return;
            }
            enabled = newEnabled;
            this.trigger("enabledchange");
          }
        });
        if (settings2.enabled) {
          _this.enabled = settings2.enabled;
        }
        _this.loaded_ = true;
        return _this;
      }
      return AudioTrack2;
    }(Track);
    var VideoTrack = /* @__PURE__ */ function(_Track) {
      _inheritsLoose__default["default"](VideoTrack2, _Track);
      function VideoTrack2(options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        var settings2 = mergeOptions$3(options, {
          kind: VideoTrackKind[options.kind] || ""
        });
        _this = _Track.call(this, settings2) || this;
        var selected = false;
        Object.defineProperty(_assertThisInitialized__default["default"](_this), "selected", {
          get: function get2() {
            return selected;
          },
          set: function set2(newSelected) {
            if (typeof newSelected !== "boolean" || newSelected === selected) {
              return;
            }
            selected = newSelected;
            this.trigger("selectedchange");
          }
        });
        if (settings2.selected) {
          _this.selected = settings2.selected;
        }
        return _this;
      }
      return VideoTrack2;
    }(Track);
    var NONE = 0;
    var LOADING = 1;
    var LOADED = 2;
    var ERROR = 3;
    var HTMLTrackElement = /* @__PURE__ */ function(_EventTarget) {
      _inheritsLoose__default["default"](HTMLTrackElement2, _EventTarget);
      function HTMLTrackElement2(options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _EventTarget.call(this) || this;
        var readyState;
        var track = new TextTrack(options);
        _this.kind = track.kind;
        _this.src = track.src;
        _this.srclang = track.language;
        _this.label = track.label;
        _this["default"] = track["default"];
        Object.defineProperties(_assertThisInitialized__default["default"](_this), {
          readyState: {
            get: function get2() {
              return readyState;
            }
          },
          track: {
            get: function get2() {
              return track;
            }
          }
        });
        readyState = NONE;
        track.addEventListener("loadeddata", function() {
          readyState = LOADED;
          _this.trigger({
            type: "load",
            target: _assertThisInitialized__default["default"](_this)
          });
        });
        return _this;
      }
      return HTMLTrackElement2;
    }(EventTarget$2);
    HTMLTrackElement.prototype.allowedEvents_ = {
      load: "load"
    };
    HTMLTrackElement.NONE = NONE;
    HTMLTrackElement.LOADING = LOADING;
    HTMLTrackElement.LOADED = LOADED;
    HTMLTrackElement.ERROR = ERROR;
    var NORMAL = {
      audio: {
        ListClass: AudioTrackList,
        TrackClass: AudioTrack,
        capitalName: "Audio"
      },
      video: {
        ListClass: VideoTrackList,
        TrackClass: VideoTrack,
        capitalName: "Video"
      },
      text: {
        ListClass: TextTrackList,
        TrackClass: TextTrack,
        capitalName: "Text"
      }
    };
    Object.keys(NORMAL).forEach(function(type) {
      NORMAL[type].getterName = type + "Tracks";
      NORMAL[type].privateName = type + "Tracks_";
    });
    var REMOTE = {
      remoteText: {
        ListClass: TextTrackList,
        TrackClass: TextTrack,
        capitalName: "RemoteText",
        getterName: "remoteTextTracks",
        privateName: "remoteTextTracks_"
      },
      remoteTextEl: {
        ListClass: HtmlTrackElementList,
        TrackClass: HTMLTrackElement,
        capitalName: "RemoteTextTrackEls",
        getterName: "remoteTextTrackEls",
        privateName: "remoteTextTrackEls_"
      }
    };
    var ALL = _extends__default["default"]({}, NORMAL, REMOTE);
    REMOTE.names = Object.keys(REMOTE);
    NORMAL.names = Object.keys(NORMAL);
    ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
    function createTrackHelper(self2, kind, label, language, options) {
      if (options === void 0) {
        options = {};
      }
      var tracks = self2.textTracks();
      options.kind = kind;
      if (label) {
        options.label = label;
      }
      if (language) {
        options.language = language;
      }
      options.tech = self2;
      var track = new ALL.text.TrackClass(options);
      tracks.addTrack(track);
      return track;
    }
    var Tech = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](Tech2, _Component);
      function Tech2(options, ready) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        if (ready === void 0) {
          ready = function ready2() {
          };
        }
        options.reportTouchActivity = false;
        _this = _Component.call(this, null, options, ready) || this;
        _this.onDurationChange_ = function(e) {
          return _this.onDurationChange(e);
        };
        _this.trackProgress_ = function(e) {
          return _this.trackProgress(e);
        };
        _this.trackCurrentTime_ = function(e) {
          return _this.trackCurrentTime(e);
        };
        _this.stopTrackingCurrentTime_ = function(e) {
          return _this.stopTrackingCurrentTime(e);
        };
        _this.disposeSourceHandler_ = function(e) {
          return _this.disposeSourceHandler(e);
        };
        _this.queuedHanders_ = /* @__PURE__ */ new Set();
        _this.hasStarted_ = false;
        _this.on("playing", function() {
          this.hasStarted_ = true;
        });
        _this.on("loadstart", function() {
          this.hasStarted_ = false;
        });
        ALL.names.forEach(function(name) {
          var props = ALL[name];
          if (options && options[props.getterName]) {
            _this[props.privateName] = options[props.getterName];
          }
        });
        if (!_this.featuresProgressEvents) {
          _this.manualProgressOn();
        }
        if (!_this.featuresTimeupdateEvents) {
          _this.manualTimeUpdatesOn();
        }
        ["Text", "Audio", "Video"].forEach(function(track) {
          if (options["native" + track + "Tracks"] === false) {
            _this["featuresNative" + track + "Tracks"] = false;
          }
        });
        if (options.nativeCaptions === false || options.nativeTextTracks === false) {
          _this.featuresNativeTextTracks = false;
        } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
          _this.featuresNativeTextTracks = true;
        }
        if (!_this.featuresNativeTextTracks) {
          _this.emulateTextTracks();
        }
        _this.preloadTextTracks = options.preloadTextTracks !== false;
        _this.autoRemoteTextTracks_ = new ALL.text.ListClass();
        _this.initTrackListeners();
        if (!options.nativeControlsForTouch) {
          _this.emitTapEvents();
        }
        if (_this.constructor) {
          _this.name_ = _this.constructor.name || "Unknown Tech";
        }
        return _this;
      }
      var _proto = Tech2.prototype;
      _proto.triggerSourceset = function triggerSourceset(src) {
        var _this2 = this;
        if (!this.isReady_) {
          this.one("ready", function() {
            return _this2.setTimeout(function() {
              return _this2.triggerSourceset(src);
            }, 1);
          });
        }
        this.trigger({
          src,
          type: "sourceset"
        });
      };
      _proto.manualProgressOn = function manualProgressOn() {
        this.on("durationchange", this.onDurationChange_);
        this.manualProgress = true;
        this.one("ready", this.trackProgress_);
      };
      _proto.manualProgressOff = function manualProgressOff() {
        this.manualProgress = false;
        this.stopTrackingProgress();
        this.off("durationchange", this.onDurationChange_);
      };
      _proto.trackProgress = function trackProgress(event2) {
        this.stopTrackingProgress();
        this.progressInterval = this.setInterval(bind(this, function() {
          var numBufferedPercent = this.bufferedPercent();
          if (this.bufferedPercent_ !== numBufferedPercent) {
            this.trigger("progress");
          }
          this.bufferedPercent_ = numBufferedPercent;
          if (numBufferedPercent === 1) {
            this.stopTrackingProgress();
          }
        }), 500);
      };
      _proto.onDurationChange = function onDurationChange(event2) {
        this.duration_ = this.duration();
      };
      _proto.buffered = function buffered() {
        return createTimeRanges(0, 0);
      };
      _proto.bufferedPercent = function bufferedPercent$1() {
        return bufferedPercent(this.buffered(), this.duration_);
      };
      _proto.stopTrackingProgress = function stopTrackingProgress() {
        this.clearInterval(this.progressInterval);
      };
      _proto.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
        this.manualTimeUpdates = true;
        this.on("play", this.trackCurrentTime_);
        this.on("pause", this.stopTrackingCurrentTime_);
      };
      _proto.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
        this.manualTimeUpdates = false;
        this.stopTrackingCurrentTime();
        this.off("play", this.trackCurrentTime_);
        this.off("pause", this.stopTrackingCurrentTime_);
      };
      _proto.trackCurrentTime = function trackCurrentTime() {
        if (this.currentTimeInterval) {
          this.stopTrackingCurrentTime();
        }
        this.currentTimeInterval = this.setInterval(function() {
          this.trigger({
            type: "timeupdate",
            target: this,
            manuallyTriggered: true
          });
        }, 250);
      };
      _proto.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
        this.clearInterval(this.currentTimeInterval);
        this.trigger({
          type: "timeupdate",
          target: this,
          manuallyTriggered: true
        });
      };
      _proto.dispose = function dispose() {
        this.clearTracks(NORMAL.names);
        if (this.manualProgress) {
          this.manualProgressOff();
        }
        if (this.manualTimeUpdates) {
          this.manualTimeUpdatesOff();
        }
        _Component.prototype.dispose.call(this);
      };
      _proto.clearTracks = function clearTracks(types) {
        var _this3 = this;
        types = [].concat(types);
        types.forEach(function(type) {
          var list = _this3[type + "Tracks"]() || [];
          var i2 = list.length;
          while (i2--) {
            var track = list[i2];
            if (type === "text") {
              _this3.removeRemoteTextTrack(track);
            }
            list.removeTrack(track);
          }
        });
      };
      _proto.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
        var list = this.autoRemoteTextTracks_ || [];
        var i2 = list.length;
        while (i2--) {
          var track = list[i2];
          this.removeRemoteTextTrack(track);
        }
      };
      _proto.reset = function reset2() {
      };
      _proto.crossOrigin = function crossOrigin() {
      };
      _proto.setCrossOrigin = function setCrossOrigin() {
      };
      _proto.error = function error(err) {
        if (err !== void 0) {
          this.error_ = new MediaError(err);
          this.trigger("error");
        }
        return this.error_;
      };
      _proto.played = function played() {
        if (this.hasStarted_) {
          return createTimeRanges(0, 0);
        }
        return createTimeRanges();
      };
      _proto.play = function play() {
      };
      _proto.setScrubbing = function setScrubbing() {
      };
      _proto.scrubbing = function scrubbing() {
      };
      _proto.setCurrentTime = function setCurrentTime() {
        if (this.manualTimeUpdates) {
          this.trigger({
            type: "timeupdate",
            target: this,
            manuallyTriggered: true
          });
        }
      };
      _proto.initTrackListeners = function initTrackListeners() {
        var _this4 = this;
        NORMAL.names.forEach(function(name) {
          var props = NORMAL[name];
          var trackListChanges = function trackListChanges2() {
            _this4.trigger(name + "trackchange");
          };
          var tracks = _this4[props.getterName]();
          tracks.addEventListener("removetrack", trackListChanges);
          tracks.addEventListener("addtrack", trackListChanges);
          _this4.on("dispose", function() {
            tracks.removeEventListener("removetrack", trackListChanges);
            tracks.removeEventListener("addtrack", trackListChanges);
          });
        });
      };
      _proto.addWebVttScript_ = function addWebVttScript_() {
        var _this5 = this;
        if (window__default["default"].WebVTT) {
          return;
        }
        if (document__default["default"].body.contains(this.el())) {
          if (!this.options_["vtt.js"] && isPlain(vtt__default["default"]) && Object.keys(vtt__default["default"]).length > 0) {
            this.trigger("vttjsloaded");
            return;
          }
          var script = document__default["default"].createElement("script");
          script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js";
          script.onload = function() {
            _this5.trigger("vttjsloaded");
          };
          script.onerror = function() {
            _this5.trigger("vttjserror");
          };
          this.on("dispose", function() {
            script.onload = null;
            script.onerror = null;
          });
          window__default["default"].WebVTT = true;
          this.el().parentNode.appendChild(script);
        } else {
          this.ready(this.addWebVttScript_);
        }
      };
      _proto.emulateTextTracks = function emulateTextTracks() {
        var _this6 = this;
        var tracks = this.textTracks();
        var remoteTracks = this.remoteTextTracks();
        var handleAddTrack = function handleAddTrack2(e) {
          return tracks.addTrack(e.track);
        };
        var handleRemoveTrack = function handleRemoveTrack2(e) {
          return tracks.removeTrack(e.track);
        };
        remoteTracks.on("addtrack", handleAddTrack);
        remoteTracks.on("removetrack", handleRemoveTrack);
        this.addWebVttScript_();
        var updateDisplay = function updateDisplay2() {
          return _this6.trigger("texttrackchange");
        };
        var textTracksChanges = function textTracksChanges2() {
          updateDisplay();
          for (var i2 = 0; i2 < tracks.length; i2++) {
            var track = tracks[i2];
            track.removeEventListener("cuechange", updateDisplay);
            if (track.mode === "showing") {
              track.addEventListener("cuechange", updateDisplay);
            }
          }
        };
        textTracksChanges();
        tracks.addEventListener("change", textTracksChanges);
        tracks.addEventListener("addtrack", textTracksChanges);
        tracks.addEventListener("removetrack", textTracksChanges);
        this.on("dispose", function() {
          remoteTracks.off("addtrack", handleAddTrack);
          remoteTracks.off("removetrack", handleRemoveTrack);
          tracks.removeEventListener("change", textTracksChanges);
          tracks.removeEventListener("addtrack", textTracksChanges);
          tracks.removeEventListener("removetrack", textTracksChanges);
          for (var i2 = 0; i2 < tracks.length; i2++) {
            var track = tracks[i2];
            track.removeEventListener("cuechange", updateDisplay);
          }
        });
      };
      _proto.addTextTrack = function addTextTrack(kind, label, language) {
        if (!kind) {
          throw new Error("TextTrack kind is required but was not provided");
        }
        return createTrackHelper(this, kind, label, language);
      };
      _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
        var track = mergeOptions$3(options, {
          tech: this
        });
        return new REMOTE.remoteTextEl.TrackClass(track);
      };
      _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
        var _this7 = this;
        if (options === void 0) {
          options = {};
        }
        var htmlTrackElement = this.createRemoteTextTrack(options);
        if (manualCleanup !== true && manualCleanup !== false) {
          log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
          manualCleanup = true;
        }
        this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
        this.remoteTextTracks().addTrack(htmlTrackElement.track);
        if (manualCleanup !== true) {
          this.ready(function() {
            return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
          });
        }
        return htmlTrackElement;
      };
      _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
        var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
        this.remoteTextTrackEls().removeTrackElement_(trackElement);
        this.remoteTextTracks().removeTrack(track);
        this.autoRemoteTextTracks_.removeTrack(track);
      };
      _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
        return {};
      };
      _proto.requestPictureInPicture = function requestPictureInPicture() {
        var PromiseClass = this.options_.Promise || window__default["default"].Promise;
        if (PromiseClass) {
          return PromiseClass.reject();
        }
      };
      _proto.disablePictureInPicture = function disablePictureInPicture() {
        return true;
      };
      _proto.setDisablePictureInPicture = function setDisablePictureInPicture() {
      };
      _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {
        var _this8 = this;
        var id = newGUID();
        if (!this.isReady_ || this.paused()) {
          this.queuedHanders_.add(id);
          this.one("playing", function() {
            if (_this8.queuedHanders_.has(id)) {
              _this8.queuedHanders_["delete"](id);
              cb();
            }
          });
        } else {
          this.requestNamedAnimationFrame(id, cb);
        }
        return id;
      };
      _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {
        if (this.queuedHanders_.has(id)) {
          this.queuedHanders_["delete"](id);
        } else {
          this.cancelNamedAnimationFrame(id);
        }
      };
      _proto.setPoster = function setPoster() {
      };
      _proto.playsinline = function playsinline() {
      };
      _proto.setPlaysinline = function setPlaysinline() {
      };
      _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks() {
      };
      _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks() {
      };
      _proto.canPlayType = function canPlayType2() {
        return "";
      };
      Tech2.canPlayType = function canPlayType2() {
        return "";
      };
      Tech2.canPlaySource = function canPlaySource(srcObj, options) {
        return Tech2.canPlayType(srcObj.type);
      };
      Tech2.isTech = function isTech(component) {
        return component.prototype instanceof Tech2 || component instanceof Tech2 || component === Tech2;
      };
      Tech2.registerTech = function registerTech(name, tech) {
        if (!Tech2.techs_) {
          Tech2.techs_ = {};
        }
        if (!Tech2.isTech(tech)) {
          throw new Error("Tech " + name + " must be a Tech");
        }
        if (!Tech2.canPlayType) {
          throw new Error("Techs must have a static canPlayType method on them");
        }
        if (!Tech2.canPlaySource) {
          throw new Error("Techs must have a static canPlaySource method on them");
        }
        name = toTitleCase$1(name);
        Tech2.techs_[name] = tech;
        Tech2.techs_[toLowerCase(name)] = tech;
        if (name !== "Tech") {
          Tech2.defaultTechOrder_.push(name);
        }
        return tech;
      };
      Tech2.getTech = function getTech(name) {
        if (!name) {
          return;
        }
        if (Tech2.techs_ && Tech2.techs_[name]) {
          return Tech2.techs_[name];
        }
        name = toTitleCase$1(name);
        if (window__default["default"] && window__default["default"].videojs && window__default["default"].videojs[name]) {
          log$1.warn("The " + name + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)");
          return window__default["default"].videojs[name];
        }
      };
      return Tech2;
    }(Component$1);
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      Tech.prototype[props.getterName] = function() {
        this[props.privateName] = this[props.privateName] || new props.ListClass();
        return this[props.privateName];
      };
    });
    Tech.prototype.featuresVolumeControl = true;
    Tech.prototype.featuresMuteControl = true;
    Tech.prototype.featuresFullscreenResize = false;
    Tech.prototype.featuresPlaybackRate = false;
    Tech.prototype.featuresProgressEvents = false;
    Tech.prototype.featuresSourceset = false;
    Tech.prototype.featuresTimeupdateEvents = false;
    Tech.prototype.featuresNativeTextTracks = false;
    Tech.prototype.featuresVideoFrameCallback = false;
    Tech.withSourceHandlers = function(_Tech) {
      _Tech.registerSourceHandler = function(handler, index) {
        var handlers = _Tech.sourceHandlers;
        if (!handlers) {
          handlers = _Tech.sourceHandlers = [];
        }
        if (index === void 0) {
          index = handlers.length;
        }
        handlers.splice(index, 0, handler);
      };
      _Tech.canPlayType = function(type) {
        var handlers = _Tech.sourceHandlers || [];
        var can;
        for (var i2 = 0; i2 < handlers.length; i2++) {
          can = handlers[i2].canPlayType(type);
          if (can) {
            return can;
          }
        }
        return "";
      };
      _Tech.selectSourceHandler = function(source, options) {
        var handlers = _Tech.sourceHandlers || [];
        var can;
        for (var i2 = 0; i2 < handlers.length; i2++) {
          can = handlers[i2].canHandleSource(source, options);
          if (can) {
            return handlers[i2];
          }
        }
        return null;
      };
      _Tech.canPlaySource = function(srcObj, options) {
        var sh = _Tech.selectSourceHandler(srcObj, options);
        if (sh) {
          return sh.canHandleSource(srcObj, options);
        }
        return "";
      };
      var deferrable = ["seekable", "seeking", "duration"];
      deferrable.forEach(function(fnName) {
        var originalFn = this[fnName];
        if (typeof originalFn !== "function") {
          return;
        }
        this[fnName] = function() {
          if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
            return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
          }
          return originalFn.apply(this, arguments);
        };
      }, _Tech.prototype);
      _Tech.prototype.setSource = function(source) {
        var sh = _Tech.selectSourceHandler(source, this.options_);
        if (!sh) {
          if (_Tech.nativeSourceHandler) {
            sh = _Tech.nativeSourceHandler;
          } else {
            log$1.error("No source handler found for the current source.");
          }
        }
        this.disposeSourceHandler();
        this.off("dispose", this.disposeSourceHandler_);
        if (sh !== _Tech.nativeSourceHandler) {
          this.currentSource_ = source;
        }
        this.sourceHandler_ = sh.handleSource(source, this, this.options_);
        this.one("dispose", this.disposeSourceHandler_);
      };
      _Tech.prototype.disposeSourceHandler = function() {
        if (this.currentSource_) {
          this.clearTracks(["audio", "video"]);
          this.currentSource_ = null;
        }
        this.cleanupAutoTextTracks();
        if (this.sourceHandler_) {
          if (this.sourceHandler_.dispose) {
            this.sourceHandler_.dispose();
          }
          this.sourceHandler_ = null;
        }
      };
    };
    Component$1.registerComponent("Tech", Tech);
    Tech.registerTech("Tech", Tech);
    Tech.defaultTechOrder_ = [];
    var middlewares = {};
    var middlewareInstances = {};
    var TERMINATOR = {};
    function use(type, middleware) {
      middlewares[type] = middlewares[type] || [];
      middlewares[type].push(middleware);
    }
    function setSource(player, src, next) {
      player.setTimeout(function() {
        return setSourceHelper(src, middlewares[src.type], next, player);
      }, 1);
    }
    function setTech(middleware, tech) {
      middleware.forEach(function(mw) {
        return mw.setTech && mw.setTech(tech);
      });
    }
    function get(middleware, tech, method) {
      return middleware.reduceRight(middlewareIterator(method), tech[method]());
    }
    function set(middleware, tech, method, arg) {
      return tech[method](middleware.reduce(middlewareIterator(method), arg));
    }
    function mediate(middleware, tech, method, arg) {
      if (arg === void 0) {
        arg = null;
      }
      var callMethod = "call" + toTitleCase$1(method);
      var middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
      var terminated = middlewareValue === TERMINATOR;
      var returnValue = terminated ? null : tech[method](middlewareValue);
      executeRight(middleware, method, returnValue, terminated);
      return returnValue;
    }
    var allowedGetters = {
      buffered: 1,
      currentTime: 1,
      duration: 1,
      muted: 1,
      played: 1,
      paused: 1,
      seekable: 1,
      volume: 1,
      ended: 1
    };
    var allowedSetters = {
      setCurrentTime: 1,
      setMuted: 1,
      setVolume: 1
    };
    var allowedMediators = {
      play: 1,
      pause: 1
    };
    function middlewareIterator(method) {
      return function(value, mw) {
        if (value === TERMINATOR) {
          return TERMINATOR;
        }
        if (mw[method]) {
          return mw[method](value);
        }
        return value;
      };
    }
    function executeRight(mws, method, value, terminated) {
      for (var i2 = mws.length - 1; i2 >= 0; i2--) {
        var mw = mws[i2];
        if (mw[method]) {
          mw[method](terminated, value);
        }
      }
    }
    function clearCacheForPlayer(player) {
      middlewareInstances[player.id()] = null;
    }
    function getOrCreateFactory(player, mwFactory) {
      var mws = middlewareInstances[player.id()];
      var mw = null;
      if (mws === void 0 || mws === null) {
        mw = mwFactory(player);
        middlewareInstances[player.id()] = [[mwFactory, mw]];
        return mw;
      }
      for (var i2 = 0; i2 < mws.length; i2++) {
        var _mws$i = mws[i2], mwf = _mws$i[0], mwi = _mws$i[1];
        if (mwf !== mwFactory) {
          continue;
        }
        mw = mwi;
      }
      if (mw === null) {
        mw = mwFactory(player);
        mws.push([mwFactory, mw]);
      }
      return mw;
    }
    function setSourceHelper(src, middleware, next, player, acc, lastRun) {
      if (src === void 0) {
        src = {};
      }
      if (middleware === void 0) {
        middleware = [];
      }
      if (acc === void 0) {
        acc = [];
      }
      if (lastRun === void 0) {
        lastRun = false;
      }
      var _middleware = middleware, mwFactory = _middleware[0], mwrest = _middleware.slice(1);
      if (typeof mwFactory === "string") {
        setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
      } else if (mwFactory) {
        var mw = getOrCreateFactory(player, mwFactory);
        if (!mw.setSource) {
          acc.push(mw);
          return setSourceHelper(src, mwrest, next, player, acc, lastRun);
        }
        mw.setSource(assign({}, src), function(err, _src) {
          if (err) {
            return setSourceHelper(src, mwrest, next, player, acc, lastRun);
          }
          acc.push(mw);
          setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
        });
      } else if (mwrest.length) {
        setSourceHelper(src, mwrest, next, player, acc, lastRun);
      } else if (lastRun) {
        next(src, acc);
      } else {
        setSourceHelper(src, middlewares["*"], next, player, acc, true);
      }
    }
    var MimetypesKind = {
      opus: "video/ogg",
      ogv: "video/ogg",
      mp4: "video/mp4",
      mov: "video/mp4",
      m4v: "video/mp4",
      mkv: "video/x-matroska",
      m4a: "audio/mp4",
      mp3: "audio/mpeg",
      aac: "audio/aac",
      caf: "audio/x-caf",
      flac: "audio/flac",
      oga: "audio/ogg",
      wav: "audio/wav",
      m3u8: "application/x-mpegURL",
      mpd: "application/dash+xml",
      jpg: "image/jpeg",
      jpeg: "image/jpeg",
      gif: "image/gif",
      png: "image/png",
      svg: "image/svg+xml",
      webp: "image/webp"
    };
    var getMimetype = function getMimetype2(src) {
      if (src === void 0) {
        src = "";
      }
      var ext = getFileExtension(src);
      var mimetype = MimetypesKind[ext.toLowerCase()];
      return mimetype || "";
    };
    var findMimetype = function findMimetype2(player, src) {
      if (!src) {
        return "";
      }
      if (player.cache_.source.src === src && player.cache_.source.type) {
        return player.cache_.source.type;
      }
      var matchingSources = player.cache_.sources.filter(function(s2) {
        return s2.src === src;
      });
      if (matchingSources.length) {
        return matchingSources[0].type;
      }
      var sources = player.$$("source");
      for (var i2 = 0; i2 < sources.length; i2++) {
        var s = sources[i2];
        if (s.type && s.src && s.src === src) {
          return s.type;
        }
      }
      return getMimetype(src);
    };
    var filterSource = function filterSource2(src) {
      if (Array.isArray(src)) {
        var newsrc = [];
        src.forEach(function(srcobj) {
          srcobj = filterSource2(srcobj);
          if (Array.isArray(srcobj)) {
            newsrc = newsrc.concat(srcobj);
          } else if (isObject(srcobj)) {
            newsrc.push(srcobj);
          }
        });
        src = newsrc;
      } else if (typeof src === "string" && src.trim()) {
        src = [fixSource({
          src
        })];
      } else if (isObject(src) && typeof src.src === "string" && src.src && src.src.trim()) {
        src = [fixSource(src)];
      } else {
        src = [];
      }
      return src;
    };
    function fixSource(src) {
      if (!src.type) {
        var mimetype = getMimetype(src.src);
        if (mimetype) {
          src.type = mimetype;
        }
      }
      return src;
    }
    var MediaLoader = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](MediaLoader2, _Component);
      function MediaLoader2(player, options, ready) {
        var _this;
        var options_ = mergeOptions$3({
          createEl: false
        }, options);
        _this = _Component.call(this, player, options_, ready) || this;
        if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
          for (var i2 = 0, j = options.playerOptions.techOrder; i2 < j.length; i2++) {
            var techName = toTitleCase$1(j[i2]);
            var tech = Tech.getTech(techName);
            if (!techName) {
              tech = Component$1.getComponent(techName);
            }
            if (tech && tech.isSupported()) {
              player.loadTech_(techName);
              break;
            }
          }
        } else {
          player.src(options.playerOptions.sources);
        }
        return _this;
      }
      return MediaLoader2;
    }(Component$1);
    Component$1.registerComponent("MediaLoader", MediaLoader);
    var ClickableComponent = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](ClickableComponent2, _Component);
      function ClickableComponent2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        if (_this.options_.controlText) {
          _this.controlText(_this.options_.controlText);
        }
        _this.handleMouseOver_ = function(e) {
          return _this.handleMouseOver(e);
        };
        _this.handleMouseOut_ = function(e) {
          return _this.handleMouseOut(e);
        };
        _this.handleClick_ = function(e) {
          return _this.handleClick(e);
        };
        _this.handleKeyDown_ = function(e) {
          return _this.handleKeyDown(e);
        };
        _this.emitTapEvents();
        _this.enable();
        return _this;
      }
      var _proto = ClickableComponent2.prototype;
      _proto.createEl = function createEl$1(tag, props, attributes) {
        if (tag === void 0) {
          tag = "div";
        }
        if (props === void 0) {
          props = {};
        }
        if (attributes === void 0) {
          attributes = {};
        }
        props = assign({
          className: this.buildCSSClass(),
          tabIndex: 0
        }, props);
        if (tag === "button") {
          log$1.error("Creating a ClickableComponent with an HTML element of " + tag + " is not supported; use a Button instead.");
        }
        attributes = assign({
          role: "button"
        }, attributes);
        this.tabIndex_ = props.tabIndex;
        var el = createEl(tag, props, attributes);
        el.appendChild(createEl("span", {
          className: "vjs-icon-placeholder"
        }, {
          "aria-hidden": true
        }));
        this.createControlTextEl(el);
        return el;
      };
      _proto.dispose = function dispose() {
        this.controlTextEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      _proto.createControlTextEl = function createControlTextEl(el) {
        this.controlTextEl_ = createEl("span", {
          className: "vjs-control-text"
        }, {
          "aria-live": "polite"
        });
        if (el) {
          el.appendChild(this.controlTextEl_);
        }
        this.controlText(this.controlText_, el);
        return this.controlTextEl_;
      };
      _proto.controlText = function controlText(text, el) {
        if (el === void 0) {
          el = this.el();
        }
        if (text === void 0) {
          return this.controlText_ || "Need Text";
        }
        var localizedText = this.localize(text);
        this.controlText_ = text;
        textContent(this.controlTextEl_, localizedText);
        if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
          el.setAttribute("title", localizedText);
        }
      };
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-control vjs-button " + _Component.prototype.buildCSSClass.call(this);
      };
      _proto.enable = function enable() {
        if (!this.enabled_) {
          this.enabled_ = true;
          this.removeClass("vjs-disabled");
          this.el_.setAttribute("aria-disabled", "false");
          if (typeof this.tabIndex_ !== "undefined") {
            this.el_.setAttribute("tabIndex", this.tabIndex_);
          }
          this.on(["tap", "click"], this.handleClick_);
          this.on("keydown", this.handleKeyDown_);
        }
      };
      _proto.disable = function disable() {
        this.enabled_ = false;
        this.addClass("vjs-disabled");
        this.el_.setAttribute("aria-disabled", "true");
        if (typeof this.tabIndex_ !== "undefined") {
          this.el_.removeAttribute("tabIndex");
        }
        this.off("mouseover", this.handleMouseOver_);
        this.off("mouseout", this.handleMouseOut_);
        this.off(["tap", "click"], this.handleClick_);
        this.off("keydown", this.handleKeyDown_);
      };
      _proto.handleLanguagechange = function handleLanguagechange() {
        this.controlText(this.controlText_);
      };
      _proto.handleClick = function handleClick(event2) {
        if (this.options_.clickHandler) {
          this.options_.clickHandler.call(this, arguments);
        }
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (keycode__default["default"].isEventKey(event2, "Space") || keycode__default["default"].isEventKey(event2, "Enter")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.trigger("click");
        } else {
          _Component.prototype.handleKeyDown.call(this, event2);
        }
      };
      return ClickableComponent2;
    }(Component$1);
    Component$1.registerComponent("ClickableComponent", ClickableComponent);
    var PosterImage = /* @__PURE__ */ function(_ClickableComponent) {
      _inheritsLoose__default["default"](PosterImage2, _ClickableComponent);
      function PosterImage2(player, options) {
        var _this;
        _this = _ClickableComponent.call(this, player, options) || this;
        _this.update();
        _this.update_ = function(e) {
          return _this.update(e);
        };
        player.on("posterchange", _this.update_);
        return _this;
      }
      var _proto = PosterImage2.prototype;
      _proto.dispose = function dispose() {
        this.player().off("posterchange", this.update_);
        _ClickableComponent.prototype.dispose.call(this);
      };
      _proto.createEl = function createEl$1() {
        var el = createEl("div", {
          className: "vjs-poster",
          tabIndex: -1
        });
        return el;
      };
      _proto.update = function update(event2) {
        var url = this.player().poster();
        this.setSrc(url);
        if (url) {
          this.show();
        } else {
          this.hide();
        }
      };
      _proto.setSrc = function setSrc(url) {
        var backgroundImage = "";
        if (url) {
          backgroundImage = 'url("' + url + '")';
        }
        this.el_.style.backgroundImage = backgroundImage;
      };
      _proto.handleClick = function handleClick(event2) {
        if (!this.player_.controls()) {
          return;
        }
        var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
        if (this.player_.tech(true) && !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
          this.player_.tech(true).focus();
        }
        if (this.player_.paused()) {
          silencePromise(this.player_.play());
        } else {
          this.player_.pause();
        }
      };
      return PosterImage2;
    }(ClickableComponent);
    Component$1.registerComponent("PosterImage", PosterImage);
    var darkGray = "#222";
    var lightGray = "#ccc";
    var fontMap = {
      monospace: "monospace",
      sansSerif: "sans-serif",
      serif: "serif",
      monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
      monospaceSerif: '"Courier New", monospace',
      proportionalSansSerif: "sans-serif",
      proportionalSerif: "serif",
      casual: '"Comic Sans MS", Impact, fantasy',
      script: '"Monotype Corsiva", cursive',
      smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
    };
    function constructColor(color, opacity) {
      var hex;
      if (color.length === 4) {
        hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
      } else if (color.length === 7) {
        hex = color.slice(1);
      } else {
        throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
      }
      return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
    }
    function tryUpdateStyle(el, style2, rule) {
      try {
        el.style[style2] = rule;
      } catch (e) {
        return;
      }
    }
    var TextTrackDisplay = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](TextTrackDisplay2, _Component);
      function TextTrackDisplay2(player, options, ready) {
        var _this;
        _this = _Component.call(this, player, options, ready) || this;
        var updateDisplayHandler = function updateDisplayHandler2(e) {
          return _this.updateDisplay(e);
        };
        player.on("loadstart", function(e) {
          return _this.toggleDisplay(e);
        });
        player.on("texttrackchange", updateDisplayHandler);
        player.on("loadedmetadata", function(e) {
          return _this.preselectTrack(e);
        });
        player.ready(bind(_assertThisInitialized__default["default"](_this), function() {
          if (player.tech_ && player.tech_.featuresNativeTextTracks) {
            this.hide();
            return;
          }
          player.on("fullscreenchange", updateDisplayHandler);
          player.on("playerresize", updateDisplayHandler);
          window__default["default"].addEventListener("orientationchange", updateDisplayHandler);
          player.on("dispose", function() {
            return window__default["default"].removeEventListener("orientationchange", updateDisplayHandler);
          });
          var tracks = this.options_.playerOptions.tracks || [];
          for (var i2 = 0; i2 < tracks.length; i2++) {
            this.player_.addRemoteTextTrack(tracks[i2], true);
          }
          this.preselectTrack();
        }));
        return _this;
      }
      var _proto = TextTrackDisplay2.prototype;
      _proto.preselectTrack = function preselectTrack() {
        var modes = {
          captions: 1,
          subtitles: 1
        };
        var trackList = this.player_.textTracks();
        var userPref = this.player_.cache_.selectedLanguage;
        var firstDesc;
        var firstCaptions;
        var preferredTrack;
        for (var i2 = 0; i2 < trackList.length; i2++) {
          var track = trackList[i2];
          if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
            if (track.kind === userPref.kind) {
              preferredTrack = track;
            } else if (!preferredTrack) {
              preferredTrack = track;
            }
          } else if (userPref && !userPref.enabled) {
            preferredTrack = null;
            firstDesc = null;
            firstCaptions = null;
          } else if (track["default"]) {
            if (track.kind === "descriptions" && !firstDesc) {
              firstDesc = track;
            } else if (track.kind in modes && !firstCaptions) {
              firstCaptions = track;
            }
          }
        }
        if (preferredTrack) {
          preferredTrack.mode = "showing";
        } else if (firstCaptions) {
          firstCaptions.mode = "showing";
        } else if (firstDesc) {
          firstDesc.mode = "showing";
        }
      };
      _proto.toggleDisplay = function toggleDisplay() {
        if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
          this.hide();
        } else {
          this.show();
        }
      };
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-text-track-display"
        }, {
          "translate": "yes",
          "aria-live": "off",
          "aria-atomic": "true"
        });
      };
      _proto.clearDisplay = function clearDisplay() {
        if (typeof window__default["default"].WebVTT === "function") {
          window__default["default"].WebVTT.processCues(window__default["default"], [], this.el_);
        }
      };
      _proto.updateDisplay = function updateDisplay() {
        var tracks = this.player_.textTracks();
        var allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
        this.clearDisplay();
        if (allowMultipleShowingTracks) {
          var showingTracks = [];
          for (var _i2 = 0; _i2 < tracks.length; ++_i2) {
            var track = tracks[_i2];
            if (track.mode !== "showing") {
              continue;
            }
            showingTracks.push(track);
          }
          this.updateForTrack(showingTracks);
          return;
        }
        var descriptionsTrack = null;
        var captionsSubtitlesTrack = null;
        var i2 = tracks.length;
        while (i2--) {
          var _track = tracks[i2];
          if (_track.mode === "showing") {
            if (_track.kind === "descriptions") {
              descriptionsTrack = _track;
            } else {
              captionsSubtitlesTrack = _track;
            }
          }
        }
        if (captionsSubtitlesTrack) {
          if (this.getAttribute("aria-live") !== "off") {
            this.setAttribute("aria-live", "off");
          }
          this.updateForTrack(captionsSubtitlesTrack);
        } else if (descriptionsTrack) {
          if (this.getAttribute("aria-live") !== "assertive") {
            this.setAttribute("aria-live", "assertive");
          }
          this.updateForTrack(descriptionsTrack);
        }
      };
      _proto.updateDisplayState = function updateDisplayState(track) {
        var overrides = this.player_.textTrackSettings.getValues();
        var cues = track.activeCues;
        var i2 = cues.length;
        while (i2--) {
          var cue = cues[i2];
          if (!cue) {
            continue;
          }
          var cueDiv = cue.displayState;
          if (overrides.color) {
            cueDiv.firstChild.style.color = overrides.color;
          }
          if (overrides.textOpacity) {
            tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
          }
          if (overrides.backgroundColor) {
            cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
          }
          if (overrides.backgroundOpacity) {
            tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
          }
          if (overrides.windowColor) {
            if (overrides.windowOpacity) {
              tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity));
            } else {
              cueDiv.style.backgroundColor = overrides.windowColor;
            }
          }
          if (overrides.edgeStyle) {
            if (overrides.edgeStyle === "dropshadow") {
              cueDiv.firstChild.style.textShadow = "2px 2px 3px " + darkGray + ", 2px 2px 4px " + darkGray + ", 2px 2px 5px " + darkGray;
            } else if (overrides.edgeStyle === "raised") {
              cueDiv.firstChild.style.textShadow = "1px 1px " + darkGray + ", 2px 2px " + darkGray + ", 3px 3px " + darkGray;
            } else if (overrides.edgeStyle === "depressed") {
              cueDiv.firstChild.style.textShadow = "1px 1px " + lightGray + ", 0 1px " + lightGray + ", -1px -1px " + darkGray + ", 0 -1px " + darkGray;
            } else if (overrides.edgeStyle === "uniform") {
              cueDiv.firstChild.style.textShadow = "0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray;
            }
          }
          if (overrides.fontPercent && overrides.fontPercent !== 1) {
            var fontSize = window__default["default"].parseFloat(cueDiv.style.fontSize);
            cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
            cueDiv.style.height = "auto";
            cueDiv.style.top = "auto";
          }
          if (overrides.fontFamily && overrides.fontFamily !== "default") {
            if (overrides.fontFamily === "small-caps") {
              cueDiv.firstChild.style.fontVariant = "small-caps";
            } else {
              cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
            }
          }
        }
      };
      _proto.updateForTrack = function updateForTrack(tracks) {
        if (!Array.isArray(tracks)) {
          tracks = [tracks];
        }
        if (typeof window__default["default"].WebVTT !== "function" || tracks.every(function(track2) {
          return !track2.activeCues;
        })) {
          return;
        }
        var cues = [];
        for (var i2 = 0; i2 < tracks.length; ++i2) {
          var track = tracks[i2];
          for (var j = 0; j < track.activeCues.length; ++j) {
            cues.push(track.activeCues[j]);
          }
        }
        window__default["default"].WebVTT.processCues(window__default["default"], cues, this.el_);
        for (var _i2 = 0; _i2 < tracks.length; ++_i2) {
          var _track2 = tracks[_i2];
          for (var _j = 0; _j < _track2.activeCues.length; ++_j) {
            var cueEl = _track2.activeCues[_j].displayState;
            addClass(cueEl, "vjs-text-track-cue");
            addClass(cueEl, "vjs-text-track-cue-" + (_track2.language ? _track2.language : _i2));
            if (_track2.language) {
              setAttribute(cueEl, "lang", _track2.language);
            }
          }
          if (this.player_.textTrackSettings) {
            this.updateDisplayState(_track2);
          }
        }
      };
      return TextTrackDisplay2;
    }(Component$1);
    Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
    var LoadingSpinner = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](LoadingSpinner2, _Component);
      function LoadingSpinner2() {
        return _Component.apply(this, arguments) || this;
      }
      var _proto = LoadingSpinner2.prototype;
      _proto.createEl = function createEl$1() {
        var isAudio = this.player_.isAudio();
        var playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
        var controlText = createEl("span", {
          className: "vjs-control-text",
          textContent: this.localize("{1} is loading.", [playerType])
        });
        var el = _Component.prototype.createEl.call(this, "div", {
          className: "vjs-loading-spinner",
          dir: "ltr"
        });
        el.appendChild(controlText);
        return el;
      };
      return LoadingSpinner2;
    }(Component$1);
    Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
    var Button = /* @__PURE__ */ function(_ClickableComponent) {
      _inheritsLoose__default["default"](Button2, _ClickableComponent);
      function Button2() {
        return _ClickableComponent.apply(this, arguments) || this;
      }
      var _proto = Button2.prototype;
      _proto.createEl = function createEl$1(tag, props, attributes) {
        if (props === void 0) {
          props = {};
        }
        if (attributes === void 0) {
          attributes = {};
        }
        tag = "button";
        props = assign({
          className: this.buildCSSClass()
        }, props);
        attributes = assign({
          type: "button"
        }, attributes);
        var el = createEl(tag, props, attributes);
        el.appendChild(createEl("span", {
          className: "vjs-icon-placeholder"
        }, {
          "aria-hidden": true
        }));
        this.createControlTextEl(el);
        return el;
      };
      _proto.addChild = function addChild(child, options) {
        if (options === void 0) {
          options = {};
        }
        var className = this.constructor.name;
        log$1.warn("Adding an actionable (user controllable) child to a Button (" + className + ") is not supported; use a ClickableComponent instead.");
        return Component$1.prototype.addChild.call(this, child, options);
      };
      _proto.enable = function enable() {
        _ClickableComponent.prototype.enable.call(this);
        this.el_.removeAttribute("disabled");
      };
      _proto.disable = function disable() {
        _ClickableComponent.prototype.disable.call(this);
        this.el_.setAttribute("disabled", "disabled");
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (keycode__default["default"].isEventKey(event2, "Space") || keycode__default["default"].isEventKey(event2, "Enter")) {
          event2.stopPropagation();
          return;
        }
        _ClickableComponent.prototype.handleKeyDown.call(this, event2);
      };
      return Button2;
    }(ClickableComponent);
    Component$1.registerComponent("Button", Button);
    var BigPlayButton = /* @__PURE__ */ function(_Button) {
      _inheritsLoose__default["default"](BigPlayButton2, _Button);
      function BigPlayButton2(player, options) {
        var _this;
        _this = _Button.call(this, player, options) || this;
        _this.mouseused_ = false;
        _this.on("mousedown", function(e) {
          return _this.handleMouseDown(e);
        });
        return _this;
      }
      var _proto = BigPlayButton2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-big-play-button";
      };
      _proto.handleClick = function handleClick(event2) {
        var playPromise = this.player_.play();
        if (this.mouseused_ && event2.clientX && event2.clientY) {
          var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
          silencePromise(playPromise);
          if (this.player_.tech(true) && !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
            this.player_.tech(true).focus();
          }
          return;
        }
        var cb = this.player_.getChild("controlBar");
        var playToggle = cb && cb.getChild("playToggle");
        if (!playToggle) {
          this.player_.tech(true).focus();
          return;
        }
        var playFocus = function playFocus2() {
          return playToggle.focus();
        };
        if (isPromise(playPromise)) {
          playPromise.then(playFocus, function() {
          });
        } else {
          this.setTimeout(playFocus, 1);
        }
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        this.mouseused_ = false;
        _Button.prototype.handleKeyDown.call(this, event2);
      };
      _proto.handleMouseDown = function handleMouseDown(event2) {
        this.mouseused_ = true;
      };
      return BigPlayButton2;
    }(Button);
    BigPlayButton.prototype.controlText_ = "Play Video";
    Component$1.registerComponent("BigPlayButton", BigPlayButton);
    var CloseButton = /* @__PURE__ */ function(_Button) {
      _inheritsLoose__default["default"](CloseButton2, _Button);
      function CloseButton2(player, options) {
        var _this;
        _this = _Button.call(this, player, options) || this;
        _this.controlText(options && options.controlText || _this.localize("Close"));
        return _this;
      }
      var _proto = CloseButton2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-close-button " + _Button.prototype.buildCSSClass.call(this);
      };
      _proto.handleClick = function handleClick(event2) {
        this.trigger({
          type: "close",
          bubbles: false
        });
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (keycode__default["default"].isEventKey(event2, "Esc")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.trigger("click");
        } else {
          _Button.prototype.handleKeyDown.call(this, event2);
        }
      };
      return CloseButton2;
    }(Button);
    Component$1.registerComponent("CloseButton", CloseButton);
    var PlayToggle = /* @__PURE__ */ function(_Button) {
      _inheritsLoose__default["default"](PlayToggle2, _Button);
      function PlayToggle2(player, options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _Button.call(this, player, options) || this;
        options.replay = options.replay === void 0 || options.replay;
        _this.on(player, "play", function(e) {
          return _this.handlePlay(e);
        });
        _this.on(player, "pause", function(e) {
          return _this.handlePause(e);
        });
        if (options.replay) {
          _this.on(player, "ended", function(e) {
            return _this.handleEnded(e);
          });
        }
        return _this;
      }
      var _proto = PlayToggle2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-play-control " + _Button.prototype.buildCSSClass.call(this);
      };
      _proto.handleClick = function handleClick(event2) {
        if (this.player_.paused()) {
          silencePromise(this.player_.play());
        } else {
          this.player_.pause();
        }
      };
      _proto.handleSeeked = function handleSeeked(event2) {
        this.removeClass("vjs-ended");
        if (this.player_.paused()) {
          this.handlePause(event2);
        } else {
          this.handlePlay(event2);
        }
      };
      _proto.handlePlay = function handlePlay3(event2) {
        this.removeClass("vjs-ended");
        this.removeClass("vjs-paused");
        this.addClass("vjs-playing");
        this.controlText("Pause");
      };
      _proto.handlePause = function handlePause(event2) {
        this.removeClass("vjs-playing");
        this.addClass("vjs-paused");
        this.controlText("Play");
      };
      _proto.handleEnded = function handleEnded3(event2) {
        var _this2 = this;
        this.removeClass("vjs-playing");
        this.addClass("vjs-ended");
        this.controlText("Replay");
        this.one(this.player_, "seeked", function(e) {
          return _this2.handleSeeked(e);
        });
      };
      return PlayToggle2;
    }(Button);
    PlayToggle.prototype.controlText_ = "Play";
    Component$1.registerComponent("PlayToggle", PlayToggle);
    var defaultImplementation = function defaultImplementation2(seconds, guide) {
      seconds = seconds < 0 ? 0 : seconds;
      var s = Math.floor(seconds % 60);
      var m = Math.floor(seconds / 60 % 60);
      var h = Math.floor(seconds / 3600);
      var gm = Math.floor(guide / 60 % 60);
      var gh = Math.floor(guide / 3600);
      if (isNaN(seconds) || seconds === Infinity) {
        h = m = s = "-";
      }
      h = h > 0 || gh > 0 ? h + ":" : "";
      m = ((h || gm >= 10) && m < 10 ? "0" + m : m) + ":";
      s = s < 10 ? "0" + s : s;
      return h + m + s;
    };
    var implementation = defaultImplementation;
    function setFormatTime(customImplementation) {
      implementation = customImplementation;
    }
    function resetFormatTime() {
      implementation = defaultImplementation;
    }
    function formatTime(seconds, guide) {
      if (guide === void 0) {
        guide = seconds;
      }
      return implementation(seconds, guide);
    }
    var TimeDisplay = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](TimeDisplay2, _Component);
      function TimeDisplay2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.on(player, ["timeupdate", "ended"], function(e) {
          return _this.updateContent(e);
        });
        _this.updateTextNode_();
        return _this;
      }
      var _proto = TimeDisplay2.prototype;
      _proto.createEl = function createEl$1() {
        var className = this.buildCSSClass();
        var el = _Component.prototype.createEl.call(this, "div", {
          className: className + " vjs-time-control vjs-control"
        });
        var span = createEl("span", {
          className: "vjs-control-text",
          textContent: this.localize(this.labelText_) + "\xA0"
        }, {
          role: "presentation"
        });
        el.appendChild(span);
        this.contentEl_ = createEl("span", {
          className: className + "-display"
        }, {
          "aria-live": "off",
          "role": "presentation"
        });
        el.appendChild(this.contentEl_);
        return el;
      };
      _proto.dispose = function dispose() {
        this.contentEl_ = null;
        this.textNode_ = null;
        _Component.prototype.dispose.call(this);
      };
      _proto.updateTextNode_ = function updateTextNode_(time) {
        var _this2 = this;
        if (time === void 0) {
          time = 0;
        }
        time = formatTime(time);
        if (this.formattedTime_ === time) {
          return;
        }
        this.formattedTime_ = time;
        this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", function() {
          if (!_this2.contentEl_) {
            return;
          }
          var oldNode = _this2.textNode_;
          if (oldNode && _this2.contentEl_.firstChild !== oldNode) {
            oldNode = null;
            log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
          }
          _this2.textNode_ = document__default["default"].createTextNode(_this2.formattedTime_);
          if (!_this2.textNode_) {
            return;
          }
          if (oldNode) {
            _this2.contentEl_.replaceChild(_this2.textNode_, oldNode);
          } else {
            _this2.contentEl_.appendChild(_this2.textNode_);
          }
        });
      };
      _proto.updateContent = function updateContent(event2) {
      };
      return TimeDisplay2;
    }(Component$1);
    TimeDisplay.prototype.labelText_ = "Time";
    TimeDisplay.prototype.controlText_ = "Time";
    Component$1.registerComponent("TimeDisplay", TimeDisplay);
    var CurrentTimeDisplay = /* @__PURE__ */ function(_TimeDisplay) {
      _inheritsLoose__default["default"](CurrentTimeDisplay2, _TimeDisplay);
      function CurrentTimeDisplay2() {
        return _TimeDisplay.apply(this, arguments) || this;
      }
      var _proto = CurrentTimeDisplay2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-current-time";
      };
      _proto.updateContent = function updateContent(event2) {
        var time;
        if (this.player_.ended()) {
          time = this.player_.duration();
        } else {
          time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
        }
        this.updateTextNode_(time);
      };
      return CurrentTimeDisplay2;
    }(TimeDisplay);
    CurrentTimeDisplay.prototype.labelText_ = "Current Time";
    CurrentTimeDisplay.prototype.controlText_ = "Current Time";
    Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
    var DurationDisplay = /* @__PURE__ */ function(_TimeDisplay) {
      _inheritsLoose__default["default"](DurationDisplay2, _TimeDisplay);
      function DurationDisplay2(player, options) {
        var _this;
        _this = _TimeDisplay.call(this, player, options) || this;
        var updateContent = function updateContent2(e) {
          return _this.updateContent(e);
        };
        _this.on(player, "durationchange", updateContent);
        _this.on(player, "loadstart", updateContent);
        _this.on(player, "loadedmetadata", updateContent);
        return _this;
      }
      var _proto = DurationDisplay2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-duration";
      };
      _proto.updateContent = function updateContent(event2) {
        var duration2 = this.player_.duration();
        this.updateTextNode_(duration2);
      };
      return DurationDisplay2;
    }(TimeDisplay);
    DurationDisplay.prototype.labelText_ = "Duration";
    DurationDisplay.prototype.controlText_ = "Duration";
    Component$1.registerComponent("DurationDisplay", DurationDisplay);
    var TimeDivider = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](TimeDivider2, _Component);
      function TimeDivider2() {
        return _Component.apply(this, arguments) || this;
      }
      var _proto = TimeDivider2.prototype;
      _proto.createEl = function createEl2() {
        var el = _Component.prototype.createEl.call(this, "div", {
          className: "vjs-time-control vjs-time-divider"
        }, {
          "aria-hidden": true
        });
        var div = _Component.prototype.createEl.call(this, "div");
        var span = _Component.prototype.createEl.call(this, "span", {
          textContent: "/"
        });
        div.appendChild(span);
        el.appendChild(div);
        return el;
      };
      return TimeDivider2;
    }(Component$1);
    Component$1.registerComponent("TimeDivider", TimeDivider);
    var RemainingTimeDisplay = /* @__PURE__ */ function(_TimeDisplay) {
      _inheritsLoose__default["default"](RemainingTimeDisplay2, _TimeDisplay);
      function RemainingTimeDisplay2(player, options) {
        var _this;
        _this = _TimeDisplay.call(this, player, options) || this;
        _this.on(player, "durationchange", function(e) {
          return _this.updateContent(e);
        });
        return _this;
      }
      var _proto = RemainingTimeDisplay2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-remaining-time";
      };
      _proto.createEl = function createEl$1() {
        var el = _TimeDisplay.prototype.createEl.call(this);
        if (this.options_.displayNegative !== false) {
          el.insertBefore(createEl("span", {}, {
            "aria-hidden": true
          }, "-"), this.contentEl_);
        }
        return el;
      };
      _proto.updateContent = function updateContent(event2) {
        if (typeof this.player_.duration() !== "number") {
          return;
        }
        var time;
        if (this.player_.ended()) {
          time = 0;
        } else if (this.player_.remainingTimeDisplay) {
          time = this.player_.remainingTimeDisplay();
        } else {
          time = this.player_.remainingTime();
        }
        this.updateTextNode_(time);
      };
      return RemainingTimeDisplay2;
    }(TimeDisplay);
    RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
    RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
    Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
    var LiveDisplay = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](LiveDisplay2, _Component);
      function LiveDisplay2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.updateShowing();
        _this.on(_this.player(), "durationchange", function(e) {
          return _this.updateShowing(e);
        });
        return _this;
      }
      var _proto = LiveDisplay2.prototype;
      _proto.createEl = function createEl$1() {
        var el = _Component.prototype.createEl.call(this, "div", {
          className: "vjs-live-control vjs-control"
        });
        this.contentEl_ = createEl("div", {
          className: "vjs-live-display"
        }, {
          "aria-live": "off"
        });
        this.contentEl_.appendChild(createEl("span", {
          className: "vjs-control-text",
          textContent: this.localize("Stream Type") + "\xA0"
        }));
        this.contentEl_.appendChild(document__default["default"].createTextNode(this.localize("LIVE")));
        el.appendChild(this.contentEl_);
        return el;
      };
      _proto.dispose = function dispose() {
        this.contentEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      _proto.updateShowing = function updateShowing(event2) {
        if (this.player().duration() === Infinity) {
          this.show();
        } else {
          this.hide();
        }
      };
      return LiveDisplay2;
    }(Component$1);
    Component$1.registerComponent("LiveDisplay", LiveDisplay);
    var SeekToLive = /* @__PURE__ */ function(_Button) {
      _inheritsLoose__default["default"](SeekToLive2, _Button);
      function SeekToLive2(player, options) {
        var _this;
        _this = _Button.call(this, player, options) || this;
        _this.updateLiveEdgeStatus();
        if (_this.player_.liveTracker) {
          _this.updateLiveEdgeStatusHandler_ = function(e) {
            return _this.updateLiveEdgeStatus(e);
          };
          _this.on(_this.player_.liveTracker, "liveedgechange", _this.updateLiveEdgeStatusHandler_);
        }
        return _this;
      }
      var _proto = SeekToLive2.prototype;
      _proto.createEl = function createEl$1() {
        var el = _Button.prototype.createEl.call(this, "button", {
          className: "vjs-seek-to-live-control vjs-control"
        });
        this.textEl_ = createEl("span", {
          className: "vjs-seek-to-live-text",
          textContent: this.localize("LIVE")
        }, {
          "aria-hidden": "true"
        });
        el.appendChild(this.textEl_);
        return el;
      };
      _proto.updateLiveEdgeStatus = function updateLiveEdgeStatus() {
        if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
          this.setAttribute("aria-disabled", true);
          this.addClass("vjs-at-live-edge");
          this.controlText("Seek to live, currently playing live");
        } else {
          this.setAttribute("aria-disabled", false);
          this.removeClass("vjs-at-live-edge");
          this.controlText("Seek to live, currently behind live");
        }
      };
      _proto.handleClick = function handleClick() {
        this.player_.liveTracker.seekToLiveEdge();
      };
      _proto.dispose = function dispose() {
        if (this.player_.liveTracker) {
          this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
        }
        this.textEl_ = null;
        _Button.prototype.dispose.call(this);
      };
      return SeekToLive2;
    }(Button);
    SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
    Component$1.registerComponent("SeekToLive", SeekToLive);
    var clamp = function clamp2(number, min, max) {
      number = Number(number);
      return Math.min(max, Math.max(min, isNaN(number) ? min : number));
    };
    var Slider = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](Slider2, _Component);
      function Slider2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.handleMouseDown_ = function(e) {
          return _this.handleMouseDown(e);
        };
        _this.handleMouseUp_ = function(e) {
          return _this.handleMouseUp(e);
        };
        _this.handleKeyDown_ = function(e) {
          return _this.handleKeyDown(e);
        };
        _this.handleClick_ = function(e) {
          return _this.handleClick(e);
        };
        _this.handleMouseMove_ = function(e) {
          return _this.handleMouseMove(e);
        };
        _this.update_ = function(e) {
          return _this.update(e);
        };
        _this.bar = _this.getChild(_this.options_.barName);
        _this.vertical(!!_this.options_.vertical);
        _this.enable();
        return _this;
      }
      var _proto = Slider2.prototype;
      _proto.enabled = function enabled() {
        return this.enabled_;
      };
      _proto.enable = function enable() {
        if (this.enabled()) {
          return;
        }
        this.on("mousedown", this.handleMouseDown_);
        this.on("touchstart", this.handleMouseDown_);
        this.on("keydown", this.handleKeyDown_);
        this.on("click", this.handleClick_);
        this.on(this.player_, "controlsvisible", this.update);
        if (this.playerEvent) {
          this.on(this.player_, this.playerEvent, this.update);
        }
        this.removeClass("disabled");
        this.setAttribute("tabindex", 0);
        this.enabled_ = true;
      };
      _proto.disable = function disable() {
        if (!this.enabled()) {
          return;
        }
        var doc = this.bar.el_.ownerDocument;
        this.off("mousedown", this.handleMouseDown_);
        this.off("touchstart", this.handleMouseDown_);
        this.off("keydown", this.handleKeyDown_);
        this.off("click", this.handleClick_);
        this.off(this.player_, "controlsvisible", this.update_);
        this.off(doc, "mousemove", this.handleMouseMove_);
        this.off(doc, "mouseup", this.handleMouseUp_);
        this.off(doc, "touchmove", this.handleMouseMove_);
        this.off(doc, "touchend", this.handleMouseUp_);
        this.removeAttribute("tabindex");
        this.addClass("disabled");
        if (this.playerEvent) {
          this.off(this.player_, this.playerEvent, this.update);
        }
        this.enabled_ = false;
      };
      _proto.createEl = function createEl2(type, props, attributes) {
        if (props === void 0) {
          props = {};
        }
        if (attributes === void 0) {
          attributes = {};
        }
        props.className = props.className + " vjs-slider";
        props = assign({
          tabIndex: 0
        }, props);
        attributes = assign({
          "role": "slider",
          "aria-valuenow": 0,
          "aria-valuemin": 0,
          "aria-valuemax": 100,
          "tabIndex": 0
        }, attributes);
        return _Component.prototype.createEl.call(this, type, props, attributes);
      };
      _proto.handleMouseDown = function handleMouseDown(event2) {
        var doc = this.bar.el_.ownerDocument;
        if (event2.type === "mousedown") {
          event2.preventDefault();
        }
        if (event2.type === "touchstart" && !IS_CHROME) {
          event2.preventDefault();
        }
        blockTextSelection();
        this.addClass("vjs-sliding");
        this.trigger("slideractive");
        this.on(doc, "mousemove", this.handleMouseMove_);
        this.on(doc, "mouseup", this.handleMouseUp_);
        this.on(doc, "touchmove", this.handleMouseMove_);
        this.on(doc, "touchend", this.handleMouseUp_);
        this.handleMouseMove(event2, true);
      };
      _proto.handleMouseMove = function handleMouseMove(event2) {
      };
      _proto.handleMouseUp = function handleMouseUp() {
        var doc = this.bar.el_.ownerDocument;
        unblockTextSelection();
        this.removeClass("vjs-sliding");
        this.trigger("sliderinactive");
        this.off(doc, "mousemove", this.handleMouseMove_);
        this.off(doc, "mouseup", this.handleMouseUp_);
        this.off(doc, "touchmove", this.handleMouseMove_);
        this.off(doc, "touchend", this.handleMouseUp_);
        this.update();
      };
      _proto.update = function update() {
        var _this2 = this;
        if (!this.el_ || !this.bar) {
          return;
        }
        var progress = this.getProgress();
        if (progress === this.progress_) {
          return progress;
        }
        this.progress_ = progress;
        this.requestNamedAnimationFrame("Slider#update", function() {
          var sizeKey = _this2.vertical() ? "height" : "width";
          _this2.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
        });
        return progress;
      };
      _proto.getProgress = function getProgress() {
        return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
      };
      _proto.calculateDistance = function calculateDistance(event2) {
        var position = getPointerPosition(this.el_, event2);
        if (this.vertical()) {
          return position.y;
        }
        return position.x;
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (keycode__default["default"].isEventKey(event2, "Left") || keycode__default["default"].isEventKey(event2, "Down")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.stepBack();
        } else if (keycode__default["default"].isEventKey(event2, "Right") || keycode__default["default"].isEventKey(event2, "Up")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.stepForward();
        } else {
          _Component.prototype.handleKeyDown.call(this, event2);
        }
      };
      _proto.handleClick = function handleClick(event2) {
        event2.stopPropagation();
        event2.preventDefault();
      };
      _proto.vertical = function vertical(bool) {
        if (bool === void 0) {
          return this.vertical_ || false;
        }
        this.vertical_ = !!bool;
        if (this.vertical_) {
          this.addClass("vjs-slider-vertical");
        } else {
          this.addClass("vjs-slider-horizontal");
        }
      };
      return Slider2;
    }(Component$1);
    Component$1.registerComponent("Slider", Slider);
    var percentify = function percentify2(time, end2) {
      return clamp(time / end2 * 100, 0, 100).toFixed(2) + "%";
    };
    var LoadProgressBar = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](LoadProgressBar2, _Component);
      function LoadProgressBar2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.partEls_ = [];
        _this.on(player, "progress", function(e) {
          return _this.update(e);
        });
        return _this;
      }
      var _proto = LoadProgressBar2.prototype;
      _proto.createEl = function createEl$1() {
        var el = _Component.prototype.createEl.call(this, "div", {
          className: "vjs-load-progress"
        });
        var wrapper = createEl("span", {
          className: "vjs-control-text"
        });
        var loadedText = createEl("span", {
          textContent: this.localize("Loaded")
        });
        var separator = document__default["default"].createTextNode(": ");
        this.percentageEl_ = createEl("span", {
          className: "vjs-control-text-loaded-percentage",
          textContent: "0%"
        });
        el.appendChild(wrapper);
        wrapper.appendChild(loadedText);
        wrapper.appendChild(separator);
        wrapper.appendChild(this.percentageEl_);
        return el;
      };
      _proto.dispose = function dispose() {
        this.partEls_ = null;
        this.percentageEl_ = null;
        _Component.prototype.dispose.call(this);
      };
      _proto.update = function update(event2) {
        var _this2 = this;
        this.requestNamedAnimationFrame("LoadProgressBar#update", function() {
          var liveTracker = _this2.player_.liveTracker;
          var buffered = _this2.player_.buffered();
          var duration2 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration();
          var bufferedEnd = _this2.player_.bufferedEnd();
          var children = _this2.partEls_;
          var percent = percentify(bufferedEnd, duration2);
          if (_this2.percent_ !== percent) {
            _this2.el_.style.width = percent;
            textContent(_this2.percentageEl_, percent);
            _this2.percent_ = percent;
          }
          for (var i2 = 0; i2 < buffered.length; i2++) {
            var start2 = buffered.start(i2);
            var end2 = buffered.end(i2);
            var part = children[i2];
            if (!part) {
              part = _this2.el_.appendChild(createEl());
              children[i2] = part;
            }
            if (part.dataset.start === start2 && part.dataset.end === end2) {
              continue;
            }
            part.dataset.start = start2;
            part.dataset.end = end2;
            part.style.left = percentify(start2, bufferedEnd);
            part.style.width = percentify(end2 - start2, bufferedEnd);
          }
          for (var _i2 = children.length; _i2 > buffered.length; _i2--) {
            _this2.el_.removeChild(children[_i2 - 1]);
          }
          children.length = buffered.length;
        });
      };
      return LoadProgressBar2;
    }(Component$1);
    Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
    var TimeTooltip = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](TimeTooltip2, _Component);
      function TimeTooltip2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.update = throttle(bind(_assertThisInitialized__default["default"](_this), _this.update), UPDATE_REFRESH_INTERVAL);
        return _this;
      }
      var _proto = TimeTooltip2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-time-tooltip"
        }, {
          "aria-hidden": "true"
        });
      };
      _proto.update = function update(seekBarRect, seekBarPoint, content) {
        var tooltipRect = findPosition(this.el_);
        var playerRect = getBoundingClientRect(this.player_.el());
        var seekBarPointPx = seekBarRect.width * seekBarPoint;
        if (!playerRect || !tooltipRect) {
          return;
        }
        var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
        var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
        var pullTooltipBy = tooltipRect.width / 2;
        if (spaceLeftOfPoint < pullTooltipBy) {
          pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
        } else if (spaceRightOfPoint < pullTooltipBy) {
          pullTooltipBy = spaceRightOfPoint;
        }
        if (pullTooltipBy < 0) {
          pullTooltipBy = 0;
        } else if (pullTooltipBy > tooltipRect.width) {
          pullTooltipBy = tooltipRect.width;
        }
        pullTooltipBy = Math.round(pullTooltipBy);
        this.el_.style.right = "-" + pullTooltipBy + "px";
        this.write(content);
      };
      _proto.write = function write(content) {
        textContent(this.el_, content);
      };
      _proto.updateTime = function updateTime(seekBarRect, seekBarPoint, time, cb) {
        var _this2 = this;
        this.requestNamedAnimationFrame("TimeTooltip#updateTime", function() {
          var content;
          var duration2 = _this2.player_.duration();
          if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {
            var liveWindow = _this2.player_.liveTracker.liveWindow();
            var secondsBehind = liveWindow - seekBarPoint * liveWindow;
            content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
          } else {
            content = formatTime(time, duration2);
          }
          _this2.update(seekBarRect, seekBarPoint, content);
          if (cb) {
            cb();
          }
        });
      };
      return TimeTooltip2;
    }(Component$1);
    Component$1.registerComponent("TimeTooltip", TimeTooltip);
    var PlayProgressBar = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](PlayProgressBar2, _Component);
      function PlayProgressBar2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.update = throttle(bind(_assertThisInitialized__default["default"](_this), _this.update), UPDATE_REFRESH_INTERVAL);
        return _this;
      }
      var _proto = PlayProgressBar2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-play-progress vjs-slider-bar"
        }, {
          "aria-hidden": "true"
        });
      };
      _proto.update = function update(seekBarRect, seekBarPoint) {
        var timeTooltip = this.getChild("timeTooltip");
        if (!timeTooltip) {
          return;
        }
        var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
        timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
      };
      return PlayProgressBar2;
    }(Component$1);
    PlayProgressBar.prototype.options_ = {
      children: []
    };
    if (!IS_IOS && !IS_ANDROID) {
      PlayProgressBar.prototype.options_.children.push("timeTooltip");
    }
    Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
    var MouseTimeDisplay = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](MouseTimeDisplay2, _Component);
      function MouseTimeDisplay2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.update = throttle(bind(_assertThisInitialized__default["default"](_this), _this.update), UPDATE_REFRESH_INTERVAL);
        return _this;
      }
      var _proto = MouseTimeDisplay2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-mouse-display"
        });
      };
      _proto.update = function update(seekBarRect, seekBarPoint) {
        var _this2 = this;
        var time = seekBarPoint * this.player_.duration();
        this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, function() {
          _this2.el_.style.left = seekBarRect.width * seekBarPoint + "px";
        });
      };
      return MouseTimeDisplay2;
    }(Component$1);
    MouseTimeDisplay.prototype.options_ = {
      children: ["timeTooltip"]
    };
    Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
    var STEP_SECONDS = 5;
    var PAGE_KEY_MULTIPLIER = 12;
    var SeekBar = /* @__PURE__ */ function(_Slider) {
      _inheritsLoose__default["default"](SeekBar2, _Slider);
      function SeekBar2(player, options) {
        var _this;
        _this = _Slider.call(this, player, options) || this;
        _this.setEventHandlers_();
        return _this;
      }
      var _proto = SeekBar2.prototype;
      _proto.setEventHandlers_ = function setEventHandlers_() {
        var _this2 = this;
        this.update_ = bind(this, this.update);
        this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
        this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
        if (this.player_.liveTracker) {
          this.on(this.player_.liveTracker, "liveedgechange", this.update);
        }
        this.updateInterval = null;
        this.enableIntervalHandler_ = function(e) {
          return _this2.enableInterval_(e);
        };
        this.disableIntervalHandler_ = function(e) {
          return _this2.disableInterval_(e);
        };
        this.on(this.player_, ["playing"], this.enableIntervalHandler_);
        this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
        if ("hidden" in document__default["default"] && "visibilityState" in document__default["default"]) {
          this.on(document__default["default"], "visibilitychange", this.toggleVisibility_);
        }
      };
      _proto.toggleVisibility_ = function toggleVisibility_(e) {
        if (document__default["default"].visibilityState === "hidden") {
          this.cancelNamedAnimationFrame("SeekBar#update");
          this.cancelNamedAnimationFrame("Slider#update");
          this.disableInterval_(e);
        } else {
          if (!this.player_.ended() && !this.player_.paused()) {
            this.enableInterval_();
          }
          this.update();
        }
      };
      _proto.enableInterval_ = function enableInterval_() {
        if (this.updateInterval) {
          return;
        }
        this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
      };
      _proto.disableInterval_ = function disableInterval_(e) {
        if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended") {
          return;
        }
        if (!this.updateInterval) {
          return;
        }
        this.clearInterval(this.updateInterval);
        this.updateInterval = null;
      };
      _proto.createEl = function createEl2() {
        return _Slider.prototype.createEl.call(this, "div", {
          className: "vjs-progress-holder"
        }, {
          "aria-label": this.localize("Progress Bar")
        });
      };
      _proto.update = function update(event2) {
        var _this3 = this;
        if (document__default["default"].visibilityState === "hidden") {
          return;
        }
        var percent = _Slider.prototype.update.call(this);
        this.requestNamedAnimationFrame("SeekBar#update", function() {
          var currentTime = _this3.player_.ended() ? _this3.player_.duration() : _this3.getCurrentTime_();
          var liveTracker = _this3.player_.liveTracker;
          var duration2 = _this3.player_.duration();
          if (liveTracker && liveTracker.isLive()) {
            duration2 = _this3.player_.liveTracker.liveCurrentTime();
          }
          if (_this3.percent_ !== percent) {
            _this3.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
            _this3.percent_ = percent;
          }
          if (_this3.currentTime_ !== currentTime || _this3.duration_ !== duration2) {
            _this3.el_.setAttribute("aria-valuetext", _this3.localize("progress bar timing: currentTime={1} duration={2}", [formatTime(currentTime, duration2), formatTime(duration2, duration2)], "{1} of {2}"));
            _this3.currentTime_ = currentTime;
            _this3.duration_ = duration2;
          }
          if (_this3.bar) {
            _this3.bar.update(getBoundingClientRect(_this3.el()), _this3.getProgress());
          }
        });
        return percent;
      };
      _proto.userSeek_ = function userSeek_(ct) {
        if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
          this.player_.liveTracker.nextSeekedFromUser();
        }
        this.player_.currentTime(ct);
      };
      _proto.getCurrentTime_ = function getCurrentTime_() {
        return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
      };
      _proto.getPercent = function getPercent() {
        var currentTime = this.getCurrentTime_();
        var percent;
        var liveTracker = this.player_.liveTracker;
        if (liveTracker && liveTracker.isLive()) {
          percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
          if (liveTracker.atLiveEdge()) {
            percent = 1;
          }
        } else {
          percent = currentTime / this.player_.duration();
        }
        return percent;
      };
      _proto.handleMouseDown = function handleMouseDown(event2) {
        if (!isSingleLeftClick(event2)) {
          return;
        }
        event2.stopPropagation();
        this.videoWasPlaying = !this.player_.paused();
        this.player_.pause();
        _Slider.prototype.handleMouseDown.call(this, event2);
      };
      _proto.handleMouseMove = function handleMouseMove(event2, mouseDown) {
        if (mouseDown === void 0) {
          mouseDown = false;
        }
        if (!isSingleLeftClick(event2)) {
          return;
        }
        if (!mouseDown && !this.player_.scrubbing()) {
          this.player_.scrubbing(true);
        }
        var newTime;
        var distance = this.calculateDistance(event2);
        var liveTracker = this.player_.liveTracker;
        if (!liveTracker || !liveTracker.isLive()) {
          newTime = distance * this.player_.duration();
          if (newTime === this.player_.duration()) {
            newTime = newTime - 0.1;
          }
        } else {
          if (distance >= 0.99) {
            liveTracker.seekToLiveEdge();
            return;
          }
          var seekableStart = liveTracker.seekableStart();
          var seekableEnd = liveTracker.liveCurrentTime();
          newTime = seekableStart + distance * liveTracker.liveWindow();
          if (newTime >= seekableEnd) {
            newTime = seekableEnd;
          }
          if (newTime <= seekableStart) {
            newTime = seekableStart + 0.1;
          }
          if (newTime === Infinity) {
            return;
          }
        }
        this.userSeek_(newTime);
      };
      _proto.enable = function enable() {
        _Slider.prototype.enable.call(this);
        var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
        if (!mouseTimeDisplay) {
          return;
        }
        mouseTimeDisplay.show();
      };
      _proto.disable = function disable() {
        _Slider.prototype.disable.call(this);
        var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
        if (!mouseTimeDisplay) {
          return;
        }
        mouseTimeDisplay.hide();
      };
      _proto.handleMouseUp = function handleMouseUp(event2) {
        _Slider.prototype.handleMouseUp.call(this, event2);
        if (event2) {
          event2.stopPropagation();
        }
        this.player_.scrubbing(false);
        this.player_.trigger({
          type: "timeupdate",
          target: this,
          manuallyTriggered: true
        });
        if (this.videoWasPlaying) {
          silencePromise(this.player_.play());
        } else {
          this.update_();
        }
      };
      _proto.stepForward = function stepForward() {
        this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
      };
      _proto.stepBack = function stepBack() {
        this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
      };
      _proto.handleAction = function handleAction(event2) {
        if (this.player_.paused()) {
          this.player_.play();
        } else {
          this.player_.pause();
        }
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        var liveTracker = this.player_.liveTracker;
        if (keycode__default["default"].isEventKey(event2, "Space") || keycode__default["default"].isEventKey(event2, "Enter")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.handleAction(event2);
        } else if (keycode__default["default"].isEventKey(event2, "Home")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.userSeek_(0);
        } else if (keycode__default["default"].isEventKey(event2, "End")) {
          event2.preventDefault();
          event2.stopPropagation();
          if (liveTracker && liveTracker.isLive()) {
            this.userSeek_(liveTracker.liveCurrentTime());
          } else {
            this.userSeek_(this.player_.duration());
          }
        } else if (/^[0-9]$/.test(keycode__default["default"](event2))) {
          event2.preventDefault();
          event2.stopPropagation();
          var gotoFraction = (keycode__default["default"].codes[keycode__default["default"](event2)] - keycode__default["default"].codes["0"]) * 10 / 100;
          if (liveTracker && liveTracker.isLive()) {
            this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
          } else {
            this.userSeek_(this.player_.duration() * gotoFraction);
          }
        } else if (keycode__default["default"].isEventKey(event2, "PgDn")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
        } else if (keycode__default["default"].isEventKey(event2, "PgUp")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
        } else {
          _Slider.prototype.handleKeyDown.call(this, event2);
        }
      };
      _proto.dispose = function dispose() {
        this.disableInterval_();
        this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
        if (this.player_.liveTracker) {
          this.off(this.player_.liveTracker, "liveedgechange", this.update);
        }
        this.off(this.player_, ["playing"], this.enableIntervalHandler_);
        this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
        if ("hidden" in document__default["default"] && "visibilityState" in document__default["default"]) {
          this.off(document__default["default"], "visibilitychange", this.toggleVisibility_);
        }
        _Slider.prototype.dispose.call(this);
      };
      return SeekBar2;
    }(Slider);
    SeekBar.prototype.options_ = {
      children: ["loadProgressBar", "playProgressBar"],
      barName: "playProgressBar"
    };
    if (!IS_IOS && !IS_ANDROID) {
      SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
    }
    Component$1.registerComponent("SeekBar", SeekBar);
    var ProgressControl = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](ProgressControl2, _Component);
      function ProgressControl2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.handleMouseMove = throttle(bind(_assertThisInitialized__default["default"](_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
        _this.throttledHandleMouseSeek = throttle(bind(_assertThisInitialized__default["default"](_this), _this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
        _this.handleMouseUpHandler_ = function(e) {
          return _this.handleMouseUp(e);
        };
        _this.handleMouseDownHandler_ = function(e) {
          return _this.handleMouseDown(e);
        };
        _this.enable();
        return _this;
      }
      var _proto = ProgressControl2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-progress-control vjs-control"
        });
      };
      _proto.handleMouseMove = function handleMouseMove(event2) {
        var seekBar = this.getChild("seekBar");
        if (!seekBar) {
          return;
        }
        var playProgressBar = seekBar.getChild("playProgressBar");
        var mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
        if (!playProgressBar && !mouseTimeDisplay) {
          return;
        }
        var seekBarEl = seekBar.el();
        var seekBarRect = findPosition(seekBarEl);
        var seekBarPoint = getPointerPosition(seekBarEl, event2).x;
        seekBarPoint = clamp(seekBarPoint, 0, 1);
        if (mouseTimeDisplay) {
          mouseTimeDisplay.update(seekBarRect, seekBarPoint);
        }
        if (playProgressBar) {
          playProgressBar.update(seekBarRect, seekBar.getProgress());
        }
      };
      _proto.handleMouseSeek = function handleMouseSeek(event2) {
        var seekBar = this.getChild("seekBar");
        if (seekBar) {
          seekBar.handleMouseMove(event2);
        }
      };
      _proto.enabled = function enabled() {
        return this.enabled_;
      };
      _proto.disable = function disable() {
        this.children().forEach(function(child) {
          return child.disable && child.disable();
        });
        if (!this.enabled()) {
          return;
        }
        this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_);
        this.off(this.el_, "mousemove", this.handleMouseMove);
        this.removeListenersAddedOnMousedownAndTouchstart();
        this.addClass("disabled");
        this.enabled_ = false;
        if (this.player_.scrubbing()) {
          var seekBar = this.getChild("seekBar");
          this.player_.scrubbing(false);
          if (seekBar.videoWasPlaying) {
            silencePromise(this.player_.play());
          }
        }
      };
      _proto.enable = function enable() {
        this.children().forEach(function(child) {
          return child.enable && child.enable();
        });
        if (this.enabled()) {
          return;
        }
        this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_);
        this.on(this.el_, "mousemove", this.handleMouseMove);
        this.removeClass("disabled");
        this.enabled_ = true;
      };
      _proto.removeListenersAddedOnMousedownAndTouchstart = function removeListenersAddedOnMousedownAndTouchstart() {
        var doc = this.el_.ownerDocument;
        this.off(doc, "mousemove", this.throttledHandleMouseSeek);
        this.off(doc, "touchmove", this.throttledHandleMouseSeek);
        this.off(doc, "mouseup", this.handleMouseUpHandler_);
        this.off(doc, "touchend", this.handleMouseUpHandler_);
      };
      _proto.handleMouseDown = function handleMouseDown(event2) {
        var doc = this.el_.ownerDocument;
        var seekBar = this.getChild("seekBar");
        if (seekBar) {
          seekBar.handleMouseDown(event2);
        }
        this.on(doc, "mousemove", this.throttledHandleMouseSeek);
        this.on(doc, "touchmove", this.throttledHandleMouseSeek);
        this.on(doc, "mouseup", this.handleMouseUpHandler_);
        this.on(doc, "touchend", this.handleMouseUpHandler_);
      };
      _proto.handleMouseUp = function handleMouseUp(event2) {
        var seekBar = this.getChild("seekBar");
        if (seekBar) {
          seekBar.handleMouseUp(event2);
        }
        this.removeListenersAddedOnMousedownAndTouchstart();
      };
      return ProgressControl2;
    }(Component$1);
    ProgressControl.prototype.options_ = {
      children: ["seekBar"]
    };
    Component$1.registerComponent("ProgressControl", ProgressControl);
    var PictureInPictureToggle = /* @__PURE__ */ function(_Button) {
      _inheritsLoose__default["default"](PictureInPictureToggle2, _Button);
      function PictureInPictureToggle2(player, options) {
        var _this;
        _this = _Button.call(this, player, options) || this;
        _this.on(player, ["enterpictureinpicture", "leavepictureinpicture"], function(e) {
          return _this.handlePictureInPictureChange(e);
        });
        _this.on(player, ["disablepictureinpicturechanged", "loadedmetadata"], function(e) {
          return _this.handlePictureInPictureEnabledChange(e);
        });
        _this.on(player, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], function() {
          var isSourceAudio = player.currentType().substring(0, 5) === "audio";
          if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {
            if (player.isInPictureInPicture()) {
              player.exitPictureInPicture();
            }
            _this.hide();
          } else {
            _this.show();
          }
        });
        _this.disable();
        return _this;
      }
      var _proto = PictureInPictureToggle2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-picture-in-picture-control " + _Button.prototype.buildCSSClass.call(this);
      };
      _proto.handlePictureInPictureEnabledChange = function handlePictureInPictureEnabledChange() {
        if (document__default["default"].pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {
          this.enable();
        } else {
          this.disable();
        }
      };
      _proto.handlePictureInPictureChange = function handlePictureInPictureChange(event2) {
        if (this.player_.isInPictureInPicture()) {
          this.controlText("Exit Picture-in-Picture");
        } else {
          this.controlText("Picture-in-Picture");
        }
        this.handlePictureInPictureEnabledChange();
      };
      _proto.handleClick = function handleClick(event2) {
        if (!this.player_.isInPictureInPicture()) {
          this.player_.requestPictureInPicture();
        } else {
          this.player_.exitPictureInPicture();
        }
      };
      return PictureInPictureToggle2;
    }(Button);
    PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
    Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
    var FullscreenToggle = /* @__PURE__ */ function(_Button) {
      _inheritsLoose__default["default"](FullscreenToggle2, _Button);
      function FullscreenToggle2(player, options) {
        var _this;
        _this = _Button.call(this, player, options) || this;
        _this.on(player, "fullscreenchange", function(e) {
          return _this.handleFullscreenChange(e);
        });
        if (document__default["default"][player.fsApi_.fullscreenEnabled] === false) {
          _this.disable();
        }
        return _this;
      }
      var _proto = FullscreenToggle2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-fullscreen-control " + _Button.prototype.buildCSSClass.call(this);
      };
      _proto.handleFullscreenChange = function handleFullscreenChange(event2) {
        if (this.player_.isFullscreen()) {
          this.controlText("Non-Fullscreen");
        } else {
          this.controlText("Fullscreen");
        }
      };
      _proto.handleClick = function handleClick(event2) {
        if (!this.player_.isFullscreen()) {
          this.player_.requestFullscreen();
        } else {
          this.player_.exitFullscreen();
        }
      };
      return FullscreenToggle2;
    }(Button);
    FullscreenToggle.prototype.controlText_ = "Fullscreen";
    Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
    var checkVolumeSupport = function checkVolumeSupport2(self2, player) {
      if (player.tech_ && !player.tech_.featuresVolumeControl) {
        self2.addClass("vjs-hidden");
      }
      self2.on(player, "loadstart", function() {
        if (!player.tech_.featuresVolumeControl) {
          self2.addClass("vjs-hidden");
        } else {
          self2.removeClass("vjs-hidden");
        }
      });
    };
    var VolumeLevel = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](VolumeLevel2, _Component);
      function VolumeLevel2() {
        return _Component.apply(this, arguments) || this;
      }
      var _proto = VolumeLevel2.prototype;
      _proto.createEl = function createEl2() {
        var el = _Component.prototype.createEl.call(this, "div", {
          className: "vjs-volume-level"
        });
        el.appendChild(_Component.prototype.createEl.call(this, "span", {
          className: "vjs-control-text"
        }));
        return el;
      };
      return VolumeLevel2;
    }(Component$1);
    Component$1.registerComponent("VolumeLevel", VolumeLevel);
    var VolumeLevelTooltip = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](VolumeLevelTooltip2, _Component);
      function VolumeLevelTooltip2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.update = throttle(bind(_assertThisInitialized__default["default"](_this), _this.update), UPDATE_REFRESH_INTERVAL);
        return _this;
      }
      var _proto = VolumeLevelTooltip2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-volume-tooltip"
        }, {
          "aria-hidden": "true"
        });
      };
      _proto.update = function update(rangeBarRect, rangeBarPoint, vertical, content) {
        if (!vertical) {
          var tooltipRect = getBoundingClientRect(this.el_);
          var playerRect = getBoundingClientRect(this.player_.el());
          var volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
          if (!playerRect || !tooltipRect) {
            return;
          }
          var spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
          var spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
          var pullTooltipBy = tooltipRect.width / 2;
          if (spaceLeftOfPoint < pullTooltipBy) {
            pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
          } else if (spaceRightOfPoint < pullTooltipBy) {
            pullTooltipBy = spaceRightOfPoint;
          }
          if (pullTooltipBy < 0) {
            pullTooltipBy = 0;
          } else if (pullTooltipBy > tooltipRect.width) {
            pullTooltipBy = tooltipRect.width;
          }
          this.el_.style.right = "-" + pullTooltipBy + "px";
        }
        this.write(content + "%");
      };
      _proto.write = function write(content) {
        textContent(this.el_, content);
      };
      _proto.updateVolume = function updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
        var _this2 = this;
        this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", function() {
          _this2.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
          if (cb) {
            cb();
          }
        });
      };
      return VolumeLevelTooltip2;
    }(Component$1);
    Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
    var MouseVolumeLevelDisplay = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](MouseVolumeLevelDisplay2, _Component);
      function MouseVolumeLevelDisplay2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        _this.update = throttle(bind(_assertThisInitialized__default["default"](_this), _this.update), UPDATE_REFRESH_INTERVAL);
        return _this;
      }
      var _proto = MouseVolumeLevelDisplay2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-mouse-display"
        });
      };
      _proto.update = function update(rangeBarRect, rangeBarPoint, vertical) {
        var _this2 = this;
        var volume = 100 * rangeBarPoint;
        this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, function() {
          if (vertical) {
            _this2.el_.style.bottom = rangeBarRect.height * rangeBarPoint + "px";
          } else {
            _this2.el_.style.left = rangeBarRect.width * rangeBarPoint + "px";
          }
        });
      };
      return MouseVolumeLevelDisplay2;
    }(Component$1);
    MouseVolumeLevelDisplay.prototype.options_ = {
      children: ["volumeLevelTooltip"]
    };
    Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
    var VolumeBar = /* @__PURE__ */ function(_Slider) {
      _inheritsLoose__default["default"](VolumeBar2, _Slider);
      function VolumeBar2(player, options) {
        var _this;
        _this = _Slider.call(this, player, options) || this;
        _this.on("slideractive", function(e) {
          return _this.updateLastVolume_(e);
        });
        _this.on(player, "volumechange", function(e) {
          return _this.updateARIAAttributes(e);
        });
        player.ready(function() {
          return _this.updateARIAAttributes();
        });
        return _this;
      }
      var _proto = VolumeBar2.prototype;
      _proto.createEl = function createEl2() {
        return _Slider.prototype.createEl.call(this, "div", {
          className: "vjs-volume-bar vjs-slider-bar"
        }, {
          "aria-label": this.localize("Volume Level"),
          "aria-live": "polite"
        });
      };
      _proto.handleMouseDown = function handleMouseDown(event2) {
        if (!isSingleLeftClick(event2)) {
          return;
        }
        _Slider.prototype.handleMouseDown.call(this, event2);
      };
      _proto.handleMouseMove = function handleMouseMove(event2) {
        var mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
        if (mouseVolumeLevelDisplay) {
          var volumeBarEl = this.el();
          var volumeBarRect = getBoundingClientRect(volumeBarEl);
          var vertical = this.vertical();
          var volumeBarPoint = getPointerPosition(volumeBarEl, event2);
          volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
          volumeBarPoint = clamp(volumeBarPoint, 0, 1);
          mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
        }
        if (!isSingleLeftClick(event2)) {
          return;
        }
        this.checkMuted();
        this.player_.volume(this.calculateDistance(event2));
      };
      _proto.checkMuted = function checkMuted() {
        if (this.player_.muted()) {
          this.player_.muted(false);
        }
      };
      _proto.getPercent = function getPercent() {
        if (this.player_.muted()) {
          return 0;
        }
        return this.player_.volume();
      };
      _proto.stepForward = function stepForward() {
        this.checkMuted();
        this.player_.volume(this.player_.volume() + 0.1);
      };
      _proto.stepBack = function stepBack() {
        this.checkMuted();
        this.player_.volume(this.player_.volume() - 0.1);
      };
      _proto.updateARIAAttributes = function updateARIAAttributes(event2) {
        var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
        this.el_.setAttribute("aria-valuenow", ariaValue);
        this.el_.setAttribute("aria-valuetext", ariaValue + "%");
      };
      _proto.volumeAsPercentage_ = function volumeAsPercentage_() {
        return Math.round(this.player_.volume() * 100);
      };
      _proto.updateLastVolume_ = function updateLastVolume_() {
        var _this2 = this;
        var volumeBeforeDrag = this.player_.volume();
        this.one("sliderinactive", function() {
          if (_this2.player_.volume() === 0) {
            _this2.player_.lastVolume_(volumeBeforeDrag);
          }
        });
      };
      return VolumeBar2;
    }(Slider);
    VolumeBar.prototype.options_ = {
      children: ["volumeLevel"],
      barName: "volumeLevel"
    };
    if (!IS_IOS && !IS_ANDROID) {
      VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
    }
    VolumeBar.prototype.playerEvent = "volumechange";
    Component$1.registerComponent("VolumeBar", VolumeBar);
    var VolumeControl = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](VolumeControl2, _Component);
      function VolumeControl2(player, options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        options.vertical = options.vertical || false;
        if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
          options.volumeBar = options.volumeBar || {};
          options.volumeBar.vertical = options.vertical;
        }
        _this = _Component.call(this, player, options) || this;
        checkVolumeSupport(_assertThisInitialized__default["default"](_this), player);
        _this.throttledHandleMouseMove = throttle(bind(_assertThisInitialized__default["default"](_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
        _this.handleMouseUpHandler_ = function(e) {
          return _this.handleMouseUp(e);
        };
        _this.on("mousedown", function(e) {
          return _this.handleMouseDown(e);
        });
        _this.on("touchstart", function(e) {
          return _this.handleMouseDown(e);
        });
        _this.on("mousemove", function(e) {
          return _this.handleMouseMove(e);
        });
        _this.on(_this.volumeBar, ["focus", "slideractive"], function() {
          _this.volumeBar.addClass("vjs-slider-active");
          _this.addClass("vjs-slider-active");
          _this.trigger("slideractive");
        });
        _this.on(_this.volumeBar, ["blur", "sliderinactive"], function() {
          _this.volumeBar.removeClass("vjs-slider-active");
          _this.removeClass("vjs-slider-active");
          _this.trigger("sliderinactive");
        });
        return _this;
      }
      var _proto = VolumeControl2.prototype;
      _proto.createEl = function createEl2() {
        var orientationClass = "vjs-volume-horizontal";
        if (this.options_.vertical) {
          orientationClass = "vjs-volume-vertical";
        }
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-volume-control vjs-control " + orientationClass
        });
      };
      _proto.handleMouseDown = function handleMouseDown(event2) {
        var doc = this.el_.ownerDocument;
        this.on(doc, "mousemove", this.throttledHandleMouseMove);
        this.on(doc, "touchmove", this.throttledHandleMouseMove);
        this.on(doc, "mouseup", this.handleMouseUpHandler_);
        this.on(doc, "touchend", this.handleMouseUpHandler_);
      };
      _proto.handleMouseUp = function handleMouseUp(event2) {
        var doc = this.el_.ownerDocument;
        this.off(doc, "mousemove", this.throttledHandleMouseMove);
        this.off(doc, "touchmove", this.throttledHandleMouseMove);
        this.off(doc, "mouseup", this.handleMouseUpHandler_);
        this.off(doc, "touchend", this.handleMouseUpHandler_);
      };
      _proto.handleMouseMove = function handleMouseMove(event2) {
        this.volumeBar.handleMouseMove(event2);
      };
      return VolumeControl2;
    }(Component$1);
    VolumeControl.prototype.options_ = {
      children: ["volumeBar"]
    };
    Component$1.registerComponent("VolumeControl", VolumeControl);
    var checkMuteSupport = function checkMuteSupport2(self2, player) {
      if (player.tech_ && !player.tech_.featuresMuteControl) {
        self2.addClass("vjs-hidden");
      }
      self2.on(player, "loadstart", function() {
        if (!player.tech_.featuresMuteControl) {
          self2.addClass("vjs-hidden");
        } else {
          self2.removeClass("vjs-hidden");
        }
      });
    };
    var MuteToggle = /* @__PURE__ */ function(_Button) {
      _inheritsLoose__default["default"](MuteToggle2, _Button);
      function MuteToggle2(player, options) {
        var _this;
        _this = _Button.call(this, player, options) || this;
        checkMuteSupport(_assertThisInitialized__default["default"](_this), player);
        _this.on(player, ["loadstart", "volumechange"], function(e) {
          return _this.update(e);
        });
        return _this;
      }
      var _proto = MuteToggle2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-mute-control " + _Button.prototype.buildCSSClass.call(this);
      };
      _proto.handleClick = function handleClick(event2) {
        var vol = this.player_.volume();
        var lastVolume = this.player_.lastVolume_();
        if (vol === 0) {
          var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
          this.player_.volume(volumeToSet);
          this.player_.muted(false);
        } else {
          this.player_.muted(this.player_.muted() ? false : true);
        }
      };
      _proto.update = function update(event2) {
        this.updateIcon_();
        this.updateControlText_();
      };
      _proto.updateIcon_ = function updateIcon_() {
        var vol = this.player_.volume();
        var level = 3;
        if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
          this.player_.muted(this.player_.tech_.el_.muted);
        }
        if (vol === 0 || this.player_.muted()) {
          level = 0;
        } else if (vol < 0.33) {
          level = 1;
        } else if (vol < 0.67) {
          level = 2;
        }
        for (var i2 = 0; i2 < 4; i2++) {
          removeClass(this.el_, "vjs-vol-" + i2);
        }
        addClass(this.el_, "vjs-vol-" + level);
      };
      _proto.updateControlText_ = function updateControlText_() {
        var soundOff = this.player_.muted() || this.player_.volume() === 0;
        var text = soundOff ? "Unmute" : "Mute";
        if (this.controlText() !== text) {
          this.controlText(text);
        }
      };
      return MuteToggle2;
    }(Button);
    MuteToggle.prototype.controlText_ = "Mute";
    Component$1.registerComponent("MuteToggle", MuteToggle);
    var VolumePanel = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](VolumePanel2, _Component);
      function VolumePanel2(player, options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        if (typeof options.inline !== "undefined") {
          options.inline = options.inline;
        } else {
          options.inline = true;
        }
        if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
          options.volumeControl = options.volumeControl || {};
          options.volumeControl.vertical = !options.inline;
        }
        _this = _Component.call(this, player, options) || this;
        _this.handleKeyPressHandler_ = function(e) {
          return _this.handleKeyPress(e);
        };
        _this.on(player, ["loadstart"], function(e) {
          return _this.volumePanelState_(e);
        });
        _this.on(_this.muteToggle, "keyup", function(e) {
          return _this.handleKeyPress(e);
        });
        _this.on(_this.volumeControl, "keyup", function(e) {
          return _this.handleVolumeControlKeyUp(e);
        });
        _this.on("keydown", function(e) {
          return _this.handleKeyPress(e);
        });
        _this.on("mouseover", function(e) {
          return _this.handleMouseOver(e);
        });
        _this.on("mouseout", function(e) {
          return _this.handleMouseOut(e);
        });
        _this.on(_this.volumeControl, ["slideractive"], _this.sliderActive_);
        _this.on(_this.volumeControl, ["sliderinactive"], _this.sliderInactive_);
        return _this;
      }
      var _proto = VolumePanel2.prototype;
      _proto.sliderActive_ = function sliderActive_() {
        this.addClass("vjs-slider-active");
      };
      _proto.sliderInactive_ = function sliderInactive_() {
        this.removeClass("vjs-slider-active");
      };
      _proto.volumePanelState_ = function volumePanelState_() {
        if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) {
          this.addClass("vjs-hidden");
        }
        if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) {
          this.addClass("vjs-mute-toggle-only");
        }
      };
      _proto.createEl = function createEl2() {
        var orientationClass = "vjs-volume-panel-horizontal";
        if (!this.options_.inline) {
          orientationClass = "vjs-volume-panel-vertical";
        }
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-volume-panel vjs-control " + orientationClass
        });
      };
      _proto.dispose = function dispose() {
        this.handleMouseOut();
        _Component.prototype.dispose.call(this);
      };
      _proto.handleVolumeControlKeyUp = function handleVolumeControlKeyUp(event2) {
        if (keycode__default["default"].isEventKey(event2, "Esc")) {
          this.muteToggle.focus();
        }
      };
      _proto.handleMouseOver = function handleMouseOver(event2) {
        this.addClass("vjs-hover");
        on(document__default["default"], "keyup", this.handleKeyPressHandler_);
      };
      _proto.handleMouseOut = function handleMouseOut(event2) {
        this.removeClass("vjs-hover");
        off(document__default["default"], "keyup", this.handleKeyPressHandler_);
      };
      _proto.handleKeyPress = function handleKeyPress(event2) {
        if (keycode__default["default"].isEventKey(event2, "Esc")) {
          this.handleMouseOut();
        }
      };
      return VolumePanel2;
    }(Component$1);
    VolumePanel.prototype.options_ = {
      children: ["muteToggle", "volumeControl"]
    };
    Component$1.registerComponent("VolumePanel", VolumePanel);
    var Menu = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](Menu2, _Component);
      function Menu2(player, options) {
        var _this;
        _this = _Component.call(this, player, options) || this;
        if (options) {
          _this.menuButton_ = options.menuButton;
        }
        _this.focusedChild_ = -1;
        _this.on("keydown", function(e) {
          return _this.handleKeyDown(e);
        });
        _this.boundHandleBlur_ = function(e) {
          return _this.handleBlur(e);
        };
        _this.boundHandleTapClick_ = function(e) {
          return _this.handleTapClick(e);
        };
        return _this;
      }
      var _proto = Menu2.prototype;
      _proto.addEventListenerForItem = function addEventListenerForItem(component) {
        if (!(component instanceof Component$1)) {
          return;
        }
        this.on(component, "blur", this.boundHandleBlur_);
        this.on(component, ["tap", "click"], this.boundHandleTapClick_);
      };
      _proto.removeEventListenerForItem = function removeEventListenerForItem(component) {
        if (!(component instanceof Component$1)) {
          return;
        }
        this.off(component, "blur", this.boundHandleBlur_);
        this.off(component, ["tap", "click"], this.boundHandleTapClick_);
      };
      _proto.removeChild = function removeChild(component) {
        if (typeof component === "string") {
          component = this.getChild(component);
        }
        this.removeEventListenerForItem(component);
        _Component.prototype.removeChild.call(this, component);
      };
      _proto.addItem = function addItem(component) {
        var childComponent = this.addChild(component);
        if (childComponent) {
          this.addEventListenerForItem(childComponent);
        }
      };
      _proto.createEl = function createEl$1() {
        var contentElType = this.options_.contentElType || "ul";
        this.contentEl_ = createEl(contentElType, {
          className: "vjs-menu-content"
        });
        this.contentEl_.setAttribute("role", "menu");
        var el = _Component.prototype.createEl.call(this, "div", {
          append: this.contentEl_,
          className: "vjs-menu"
        });
        el.appendChild(this.contentEl_);
        on(el, "click", function(event2) {
          event2.preventDefault();
          event2.stopImmediatePropagation();
        });
        return el;
      };
      _proto.dispose = function dispose() {
        this.contentEl_ = null;
        this.boundHandleBlur_ = null;
        this.boundHandleTapClick_ = null;
        _Component.prototype.dispose.call(this);
      };
      _proto.handleBlur = function handleBlur(event2) {
        var relatedTarget = event2.relatedTarget || document__default["default"].activeElement;
        if (!this.children().some(function(element) {
          return element.el() === relatedTarget;
        })) {
          var btn = this.menuButton_;
          if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
            btn.unpressButton();
          }
        }
      };
      _proto.handleTapClick = function handleTapClick(event2) {
        if (this.menuButton_) {
          this.menuButton_.unpressButton();
          var childComponents = this.children();
          if (!Array.isArray(childComponents)) {
            return;
          }
          var foundComponent = childComponents.filter(function(component) {
            return component.el() === event2.target;
          })[0];
          if (!foundComponent) {
            return;
          }
          if (foundComponent.name() !== "CaptionSettingsMenuItem") {
            this.menuButton_.focus();
          }
        }
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (keycode__default["default"].isEventKey(event2, "Left") || keycode__default["default"].isEventKey(event2, "Down")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.stepForward();
        } else if (keycode__default["default"].isEventKey(event2, "Right") || keycode__default["default"].isEventKey(event2, "Up")) {
          event2.preventDefault();
          event2.stopPropagation();
          this.stepBack();
        }
      };
      _proto.stepForward = function stepForward() {
        var stepChild = 0;
        if (this.focusedChild_ !== void 0) {
          stepChild = this.focusedChild_ + 1;
        }
        this.focus(stepChild);
      };
      _proto.stepBack = function stepBack() {
        var stepChild = 0;
        if (this.focusedChild_ !== void 0) {
          stepChild = this.focusedChild_ - 1;
        }
        this.focus(stepChild);
      };
      _proto.focus = function focus(item) {
        if (item === void 0) {
          item = 0;
        }
        var children = this.children().slice();
        var haveTitle = children.length && children[0].hasClass("vjs-menu-title");
        if (haveTitle) {
          children.shift();
        }
        if (children.length > 0) {
          if (item < 0) {
            item = 0;
          } else if (item >= children.length) {
            item = children.length - 1;
          }
          this.focusedChild_ = item;
          children[item].el_.focus();
        }
      };
      return Menu2;
    }(Component$1);
    Component$1.registerComponent("Menu", Menu);
    var MenuButton = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](MenuButton2, _Component);
      function MenuButton2(player, options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _Component.call(this, player, options) || this;
        _this.menuButton_ = new Button(player, options);
        _this.menuButton_.controlText(_this.controlText_);
        _this.menuButton_.el_.setAttribute("aria-haspopup", "true");
        var buttonClass = Button.prototype.buildCSSClass();
        _this.menuButton_.el_.className = _this.buildCSSClass() + " " + buttonClass;
        _this.menuButton_.removeClass("vjs-control");
        _this.addChild(_this.menuButton_);
        _this.update();
        _this.enabled_ = true;
        var handleClick = function handleClick2(e) {
          return _this.handleClick(e);
        };
        _this.handleMenuKeyUp_ = function(e) {
          return _this.handleMenuKeyUp(e);
        };
        _this.on(_this.menuButton_, "tap", handleClick);
        _this.on(_this.menuButton_, "click", handleClick);
        _this.on(_this.menuButton_, "keydown", function(e) {
          return _this.handleKeyDown(e);
        });
        _this.on(_this.menuButton_, "mouseenter", function() {
          _this.addClass("vjs-hover");
          _this.menu.show();
          on(document__default["default"], "keyup", _this.handleMenuKeyUp_);
        });
        _this.on("mouseleave", function(e) {
          return _this.handleMouseLeave(e);
        });
        _this.on("keydown", function(e) {
          return _this.handleSubmenuKeyDown(e);
        });
        return _this;
      }
      var _proto = MenuButton2.prototype;
      _proto.update = function update() {
        var menu = this.createMenu();
        if (this.menu) {
          this.menu.dispose();
          this.removeChild(this.menu);
        }
        this.menu = menu;
        this.addChild(menu);
        this.buttonPressed_ = false;
        this.menuButton_.el_.setAttribute("aria-expanded", "false");
        if (this.items && this.items.length <= this.hideThreshold_) {
          this.hide();
          this.menu.contentEl_.removeAttribute("role");
        } else {
          this.show();
          this.menu.contentEl_.setAttribute("role", "menu");
        }
      };
      _proto.createMenu = function createMenu() {
        var menu = new Menu(this.player_, {
          menuButton: this
        });
        this.hideThreshold_ = 0;
        if (this.options_.title) {
          var titleEl = createEl("li", {
            className: "vjs-menu-title",
            textContent: toTitleCase$1(this.options_.title),
            tabIndex: -1
          });
          var titleComponent = new Component$1(this.player_, {
            el: titleEl
          });
          menu.addItem(titleComponent);
        }
        this.items = this.createItems();
        if (this.items) {
          for (var i2 = 0; i2 < this.items.length; i2++) {
            menu.addItem(this.items[i2]);
          }
        }
        return menu;
      };
      _proto.createItems = function createItems() {
      };
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: this.buildWrapperCSSClass()
        }, {});
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        var menuButtonClass = "vjs-menu-button";
        if (this.options_.inline === true) {
          menuButtonClass += "-inline";
        } else {
          menuButtonClass += "-popup";
        }
        var buttonClass = Button.prototype.buildCSSClass();
        return "vjs-menu-button " + menuButtonClass + " " + buttonClass + " " + _Component.prototype.buildCSSClass.call(this);
      };
      _proto.buildCSSClass = function buildCSSClass() {
        var menuButtonClass = "vjs-menu-button";
        if (this.options_.inline === true) {
          menuButtonClass += "-inline";
        } else {
          menuButtonClass += "-popup";
        }
        return "vjs-menu-button " + menuButtonClass + " " + _Component.prototype.buildCSSClass.call(this);
      };
      _proto.controlText = function controlText(text, el) {
        if (el === void 0) {
          el = this.menuButton_.el();
        }
        return this.menuButton_.controlText(text, el);
      };
      _proto.dispose = function dispose() {
        this.handleMouseLeave();
        _Component.prototype.dispose.call(this);
      };
      _proto.handleClick = function handleClick(event2) {
        if (this.buttonPressed_) {
          this.unpressButton();
        } else {
          this.pressButton();
        }
      };
      _proto.handleMouseLeave = function handleMouseLeave(event2) {
        this.removeClass("vjs-hover");
        off(document__default["default"], "keyup", this.handleMenuKeyUp_);
      };
      _proto.focus = function focus() {
        this.menuButton_.focus();
      };
      _proto.blur = function blur() {
        this.menuButton_.blur();
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (keycode__default["default"].isEventKey(event2, "Esc") || keycode__default["default"].isEventKey(event2, "Tab")) {
          if (this.buttonPressed_) {
            this.unpressButton();
          }
          if (!keycode__default["default"].isEventKey(event2, "Tab")) {
            event2.preventDefault();
            this.menuButton_.focus();
          }
        } else if (keycode__default["default"].isEventKey(event2, "Up") || keycode__default["default"].isEventKey(event2, "Down")) {
          if (!this.buttonPressed_) {
            event2.preventDefault();
            this.pressButton();
          }
        }
      };
      _proto.handleMenuKeyUp = function handleMenuKeyUp(event2) {
        if (keycode__default["default"].isEventKey(event2, "Esc") || keycode__default["default"].isEventKey(event2, "Tab")) {
          this.removeClass("vjs-hover");
        }
      };
      _proto.handleSubmenuKeyPress = function handleSubmenuKeyPress(event2) {
        this.handleSubmenuKeyDown(event2);
      };
      _proto.handleSubmenuKeyDown = function handleSubmenuKeyDown(event2) {
        if (keycode__default["default"].isEventKey(event2, "Esc") || keycode__default["default"].isEventKey(event2, "Tab")) {
          if (this.buttonPressed_) {
            this.unpressButton();
          }
          if (!keycode__default["default"].isEventKey(event2, "Tab")) {
            event2.preventDefault();
            this.menuButton_.focus();
          }
        }
      };
      _proto.pressButton = function pressButton() {
        if (this.enabled_) {
          this.buttonPressed_ = true;
          this.menu.show();
          this.menu.lockShowing();
          this.menuButton_.el_.setAttribute("aria-expanded", "true");
          if (IS_IOS && isInFrame()) {
            return;
          }
          this.menu.focus();
        }
      };
      _proto.unpressButton = function unpressButton() {
        if (this.enabled_) {
          this.buttonPressed_ = false;
          this.menu.unlockShowing();
          this.menu.hide();
          this.menuButton_.el_.setAttribute("aria-expanded", "false");
        }
      };
      _proto.disable = function disable() {
        this.unpressButton();
        this.enabled_ = false;
        this.addClass("vjs-disabled");
        this.menuButton_.disable();
      };
      _proto.enable = function enable() {
        this.enabled_ = true;
        this.removeClass("vjs-disabled");
        this.menuButton_.enable();
      };
      return MenuButton2;
    }(Component$1);
    Component$1.registerComponent("MenuButton", MenuButton);
    var TrackButton = /* @__PURE__ */ function(_MenuButton) {
      _inheritsLoose__default["default"](TrackButton2, _MenuButton);
      function TrackButton2(player, options) {
        var _this;
        var tracks = options.tracks;
        _this = _MenuButton.call(this, player, options) || this;
        if (_this.items.length <= 1) {
          _this.hide();
        }
        if (!tracks) {
          return _assertThisInitialized__default["default"](_this);
        }
        var updateHandler = bind(_assertThisInitialized__default["default"](_this), _this.update);
        tracks.addEventListener("removetrack", updateHandler);
        tracks.addEventListener("addtrack", updateHandler);
        tracks.addEventListener("labelchange", updateHandler);
        _this.player_.on("ready", updateHandler);
        _this.player_.on("dispose", function() {
          tracks.removeEventListener("removetrack", updateHandler);
          tracks.removeEventListener("addtrack", updateHandler);
          tracks.removeEventListener("labelchange", updateHandler);
        });
        return _this;
      }
      return TrackButton2;
    }(MenuButton);
    Component$1.registerComponent("TrackButton", TrackButton);
    var MenuKeys = ["Tab", "Esc", "Up", "Down", "Right", "Left"];
    var MenuItem = /* @__PURE__ */ function(_ClickableComponent) {
      _inheritsLoose__default["default"](MenuItem2, _ClickableComponent);
      function MenuItem2(player, options) {
        var _this;
        _this = _ClickableComponent.call(this, player, options) || this;
        _this.selectable = options.selectable;
        _this.isSelected_ = options.selected || false;
        _this.multiSelectable = options.multiSelectable;
        _this.selected(_this.isSelected_);
        if (_this.selectable) {
          if (_this.multiSelectable) {
            _this.el_.setAttribute("role", "menuitemcheckbox");
          } else {
            _this.el_.setAttribute("role", "menuitemradio");
          }
        } else {
          _this.el_.setAttribute("role", "menuitem");
        }
        return _this;
      }
      var _proto = MenuItem2.prototype;
      _proto.createEl = function createEl$1(type, props, attrs) {
        this.nonIconControl = true;
        var el = _ClickableComponent.prototype.createEl.call(this, "li", assign({
          className: "vjs-menu-item",
          tabIndex: -1
        }, props), attrs);
        el.replaceChild(createEl("span", {
          className: "vjs-menu-item-text",
          textContent: this.localize(this.options_.label)
        }), el.querySelector(".vjs-icon-placeholder"));
        return el;
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        if (!MenuKeys.some(function(key) {
          return keycode__default["default"].isEventKey(event2, key);
        })) {
          _ClickableComponent.prototype.handleKeyDown.call(this, event2);
        }
      };
      _proto.handleClick = function handleClick(event2) {
        this.selected(true);
      };
      _proto.selected = function selected(_selected) {
        if (this.selectable) {
          if (_selected) {
            this.addClass("vjs-selected");
            this.el_.setAttribute("aria-checked", "true");
            this.controlText(", selected");
            this.isSelected_ = true;
          } else {
            this.removeClass("vjs-selected");
            this.el_.setAttribute("aria-checked", "false");
            this.controlText("");
            this.isSelected_ = false;
          }
        }
      };
      return MenuItem2;
    }(ClickableComponent);
    Component$1.registerComponent("MenuItem", MenuItem);
    var TextTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
      _inheritsLoose__default["default"](TextTrackMenuItem2, _MenuItem);
      function TextTrackMenuItem2(player, options) {
        var _this;
        var track = options.track;
        var tracks = player.textTracks();
        options.label = track.label || track.language || "Unknown";
        options.selected = track.mode === "showing";
        _this = _MenuItem.call(this, player, options) || this;
        _this.track = track;
        _this.kinds = (options.kinds || [options.kind || _this.track.kind]).filter(Boolean);
        var changeHandler = function changeHandler2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this.handleTracksChange.apply(_assertThisInitialized__default["default"](_this), args);
        };
        var selectedLanguageChangeHandler = function selectedLanguageChangeHandler2() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          _this.handleSelectedLanguageChange.apply(_assertThisInitialized__default["default"](_this), args);
        };
        player.on(["loadstart", "texttrackchange"], changeHandler);
        tracks.addEventListener("change", changeHandler);
        tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
        _this.on("dispose", function() {
          player.off(["loadstart", "texttrackchange"], changeHandler);
          tracks.removeEventListener("change", changeHandler);
          tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
        });
        if (tracks.onchange === void 0) {
          var event2;
          _this.on(["tap", "click"], function() {
            if (typeof window__default["default"].Event !== "object") {
              try {
                event2 = new window__default["default"].Event("change");
              } catch (err) {
              }
            }
            if (!event2) {
              event2 = document__default["default"].createEvent("Event");
              event2.initEvent("change", true, true);
            }
            tracks.dispatchEvent(event2);
          });
        }
        _this.handleTracksChange();
        return _this;
      }
      var _proto = TextTrackMenuItem2.prototype;
      _proto.handleClick = function handleClick(event2) {
        var referenceTrack = this.track;
        var tracks = this.player_.textTracks();
        _MenuItem.prototype.handleClick.call(this, event2);
        if (!tracks) {
          return;
        }
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track = tracks[i2];
          if (this.kinds.indexOf(track.kind) === -1) {
            continue;
          }
          if (track === referenceTrack) {
            if (track.mode !== "showing") {
              track.mode = "showing";
            }
          } else if (track.mode !== "disabled") {
            track.mode = "disabled";
          }
        }
      };
      _proto.handleTracksChange = function handleTracksChange(event2) {
        var shouldBeSelected = this.track.mode === "showing";
        if (shouldBeSelected !== this.isSelected_) {
          this.selected(shouldBeSelected);
        }
      };
      _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event2) {
        if (this.track.mode === "showing") {
          var selectedLanguage = this.player_.cache_.selectedLanguage;
          if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
            return;
          }
          this.player_.cache_.selectedLanguage = {
            enabled: true,
            language: this.track.language,
            kind: this.track.kind
          };
        }
      };
      _proto.dispose = function dispose() {
        this.track = null;
        _MenuItem.prototype.dispose.call(this);
      };
      return TextTrackMenuItem2;
    }(MenuItem);
    Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
    var OffTextTrackMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
      _inheritsLoose__default["default"](OffTextTrackMenuItem2, _TextTrackMenuItem);
      function OffTextTrackMenuItem2(player, options) {
        options.track = {
          player,
          kind: options.kind,
          kinds: options.kinds,
          "default": false,
          mode: "disabled"
        };
        if (!options.kinds) {
          options.kinds = [options.kind];
        }
        if (options.label) {
          options.track.label = options.label;
        } else {
          options.track.label = options.kinds.join(" and ") + " off";
        }
        options.selectable = true;
        options.multiSelectable = false;
        return _TextTrackMenuItem.call(this, player, options) || this;
      }
      var _proto = OffTextTrackMenuItem2.prototype;
      _proto.handleTracksChange = function handleTracksChange(event2) {
        var tracks = this.player().textTracks();
        var shouldBeSelected = true;
        for (var i2 = 0, l = tracks.length; i2 < l; i2++) {
          var track = tracks[i2];
          if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
            shouldBeSelected = false;
            break;
          }
        }
        if (shouldBeSelected !== this.isSelected_) {
          this.selected(shouldBeSelected);
        }
      };
      _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event2) {
        var tracks = this.player().textTracks();
        var allHidden = true;
        for (var i2 = 0, l = tracks.length; i2 < l; i2++) {
          var track = tracks[i2];
          if (["captions", "descriptions", "subtitles"].indexOf(track.kind) > -1 && track.mode === "showing") {
            allHidden = false;
            break;
          }
        }
        if (allHidden) {
          this.player_.cache_.selectedLanguage = {
            enabled: false
          };
        }
      };
      return OffTextTrackMenuItem2;
    }(TextTrackMenuItem);
    Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
    var TextTrackButton = /* @__PURE__ */ function(_TrackButton) {
      _inheritsLoose__default["default"](TextTrackButton2, _TrackButton);
      function TextTrackButton2(player, options) {
        if (options === void 0) {
          options = {};
        }
        options.tracks = player.textTracks();
        return _TrackButton.call(this, player, options) || this;
      }
      var _proto = TextTrackButton2.prototype;
      _proto.createItems = function createItems(items, TrackMenuItem) {
        if (items === void 0) {
          items = [];
        }
        if (TrackMenuItem === void 0) {
          TrackMenuItem = TextTrackMenuItem;
        }
        var label;
        if (this.label_) {
          label = this.label_ + " off";
        }
        items.push(new OffTextTrackMenuItem(this.player_, {
          kinds: this.kinds_,
          kind: this.kind_,
          label
        }));
        this.hideThreshold_ += 1;
        var tracks = this.player_.textTracks();
        if (!Array.isArray(this.kinds_)) {
          this.kinds_ = [this.kind_];
        }
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track = tracks[i2];
          if (this.kinds_.indexOf(track.kind) > -1) {
            var item = new TrackMenuItem(this.player_, {
              track,
              kinds: this.kinds_,
              kind: this.kind_,
              selectable: true,
              multiSelectable: false
            });
            item.addClass("vjs-" + track.kind + "-menu-item");
            items.push(item);
          }
        }
        return items;
      };
      return TextTrackButton2;
    }(TrackButton);
    Component$1.registerComponent("TextTrackButton", TextTrackButton);
    var ChaptersTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
      _inheritsLoose__default["default"](ChaptersTrackMenuItem2, _MenuItem);
      function ChaptersTrackMenuItem2(player, options) {
        var _this;
        var track = options.track;
        var cue = options.cue;
        var currentTime = player.currentTime();
        options.selectable = true;
        options.multiSelectable = false;
        options.label = cue.text;
        options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
        _this = _MenuItem.call(this, player, options) || this;
        _this.track = track;
        _this.cue = cue;
        return _this;
      }
      var _proto = ChaptersTrackMenuItem2.prototype;
      _proto.handleClick = function handleClick(event2) {
        _MenuItem.prototype.handleClick.call(this);
        this.player_.currentTime(this.cue.startTime);
      };
      return ChaptersTrackMenuItem2;
    }(MenuItem);
    Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
    var ChaptersButton = /* @__PURE__ */ function(_TextTrackButton) {
      _inheritsLoose__default["default"](ChaptersButton2, _TextTrackButton);
      function ChaptersButton2(player, options, ready) {
        var _this;
        _this = _TextTrackButton.call(this, player, options, ready) || this;
        _this.selectCurrentItem_ = function() {
          _this.items.forEach(function(item) {
            item.selected(_this.track_.activeCues[0] === item.cue);
          });
        };
        return _this;
      }
      var _proto = ChaptersButton2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-chapters-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-chapters-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      _proto.update = function update(event2) {
        if (event2 && event2.track && event2.track.kind !== "chapters") {
          return;
        }
        var track = this.findChaptersTrack();
        if (track !== this.track_) {
          this.setTrack(track);
          _TextTrackButton.prototype.update.call(this);
        } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {
          _TextTrackButton.prototype.update.call(this);
        }
      };
      _proto.setTrack = function setTrack(track) {
        if (this.track_ === track) {
          return;
        }
        if (!this.updateHandler_) {
          this.updateHandler_ = this.update.bind(this);
        }
        if (this.track_) {
          var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
          if (remoteTextTrackEl) {
            remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
          }
          this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
          this.track_ = null;
        }
        this.track_ = track;
        if (this.track_) {
          this.track_.mode = "hidden";
          var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
          if (_remoteTextTrackEl) {
            _remoteTextTrackEl.addEventListener("load", this.updateHandler_);
          }
          this.track_.addEventListener("cuechange", this.selectCurrentItem_);
        }
      };
      _proto.findChaptersTrack = function findChaptersTrack() {
        var tracks = this.player_.textTracks() || [];
        for (var i2 = tracks.length - 1; i2 >= 0; i2--) {
          var track = tracks[i2];
          if (track.kind === this.kind_) {
            return track;
          }
        }
      };
      _proto.getMenuCaption = function getMenuCaption() {
        if (this.track_ && this.track_.label) {
          return this.track_.label;
        }
        return this.localize(toTitleCase$1(this.kind_));
      };
      _proto.createMenu = function createMenu() {
        this.options_.title = this.getMenuCaption();
        return _TextTrackButton.prototype.createMenu.call(this);
      };
      _proto.createItems = function createItems() {
        var items = [];
        if (!this.track_) {
          return items;
        }
        var cues = this.track_.cues;
        if (!cues) {
          return items;
        }
        for (var i2 = 0, l = cues.length; i2 < l; i2++) {
          var cue = cues[i2];
          var mi = new ChaptersTrackMenuItem(this.player_, {
            track: this.track_,
            cue
          });
          items.push(mi);
        }
        return items;
      };
      return ChaptersButton2;
    }(TextTrackButton);
    ChaptersButton.prototype.kind_ = "chapters";
    ChaptersButton.prototype.controlText_ = "Chapters";
    Component$1.registerComponent("ChaptersButton", ChaptersButton);
    var DescriptionsButton = /* @__PURE__ */ function(_TextTrackButton) {
      _inheritsLoose__default["default"](DescriptionsButton2, _TextTrackButton);
      function DescriptionsButton2(player, options, ready) {
        var _this;
        _this = _TextTrackButton.call(this, player, options, ready) || this;
        var tracks = player.textTracks();
        var changeHandler = bind(_assertThisInitialized__default["default"](_this), _this.handleTracksChange);
        tracks.addEventListener("change", changeHandler);
        _this.on("dispose", function() {
          tracks.removeEventListener("change", changeHandler);
        });
        return _this;
      }
      var _proto = DescriptionsButton2.prototype;
      _proto.handleTracksChange = function handleTracksChange(event2) {
        var tracks = this.player().textTracks();
        var disabled = false;
        for (var i2 = 0, l = tracks.length; i2 < l; i2++) {
          var track = tracks[i2];
          if (track.kind !== this.kind_ && track.mode === "showing") {
            disabled = true;
            break;
          }
        }
        if (disabled) {
          this.disable();
        } else {
          this.enable();
        }
      };
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-descriptions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-descriptions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      return DescriptionsButton2;
    }(TextTrackButton);
    DescriptionsButton.prototype.kind_ = "descriptions";
    DescriptionsButton.prototype.controlText_ = "Descriptions";
    Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
    var SubtitlesButton = /* @__PURE__ */ function(_TextTrackButton) {
      _inheritsLoose__default["default"](SubtitlesButton2, _TextTrackButton);
      function SubtitlesButton2(player, options, ready) {
        return _TextTrackButton.call(this, player, options, ready) || this;
      }
      var _proto = SubtitlesButton2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-subtitles-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-subtitles-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      return SubtitlesButton2;
    }(TextTrackButton);
    SubtitlesButton.prototype.kind_ = "subtitles";
    SubtitlesButton.prototype.controlText_ = "Subtitles";
    Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
    var CaptionSettingsMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
      _inheritsLoose__default["default"](CaptionSettingsMenuItem2, _TextTrackMenuItem);
      function CaptionSettingsMenuItem2(player, options) {
        var _this;
        options.track = {
          player,
          kind: options.kind,
          label: options.kind + " settings",
          selectable: false,
          "default": false,
          mode: "disabled"
        };
        options.selectable = false;
        options.name = "CaptionSettingsMenuItem";
        _this = _TextTrackMenuItem.call(this, player, options) || this;
        _this.addClass("vjs-texttrack-settings");
        _this.controlText(", opens " + options.kind + " settings dialog");
        return _this;
      }
      var _proto = CaptionSettingsMenuItem2.prototype;
      _proto.handleClick = function handleClick(event2) {
        this.player().getChild("textTrackSettings").open();
      };
      return CaptionSettingsMenuItem2;
    }(TextTrackMenuItem);
    Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
    var CaptionsButton = /* @__PURE__ */ function(_TextTrackButton) {
      _inheritsLoose__default["default"](CaptionsButton2, _TextTrackButton);
      function CaptionsButton2(player, options, ready) {
        return _TextTrackButton.call(this, player, options, ready) || this;
      }
      var _proto = CaptionsButton2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-captions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-captions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      _proto.createItems = function createItems() {
        var items = [];
        if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
          items.push(new CaptionSettingsMenuItem(this.player_, {
            kind: this.kind_
          }));
          this.hideThreshold_ += 1;
        }
        return _TextTrackButton.prototype.createItems.call(this, items);
      };
      return CaptionsButton2;
    }(TextTrackButton);
    CaptionsButton.prototype.kind_ = "captions";
    CaptionsButton.prototype.controlText_ = "Captions";
    Component$1.registerComponent("CaptionsButton", CaptionsButton);
    var SubsCapsMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
      _inheritsLoose__default["default"](SubsCapsMenuItem2, _TextTrackMenuItem);
      function SubsCapsMenuItem2() {
        return _TextTrackMenuItem.apply(this, arguments) || this;
      }
      var _proto = SubsCapsMenuItem2.prototype;
      _proto.createEl = function createEl$1(type, props, attrs) {
        var el = _TextTrackMenuItem.prototype.createEl.call(this, type, props, attrs);
        var parentSpan = el.querySelector(".vjs-menu-item-text");
        if (this.options_.track.kind === "captions") {
          parentSpan.appendChild(createEl("span", {
            className: "vjs-icon-placeholder"
          }, {
            "aria-hidden": true
          }));
          parentSpan.appendChild(createEl("span", {
            className: "vjs-control-text",
            textContent: " " + this.localize("Captions")
          }));
        }
        return el;
      };
      return SubsCapsMenuItem2;
    }(TextTrackMenuItem);
    Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
    var SubsCapsButton = /* @__PURE__ */ function(_TextTrackButton) {
      _inheritsLoose__default["default"](SubsCapsButton2, _TextTrackButton);
      function SubsCapsButton2(player, options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _TextTrackButton.call(this, player, options) || this;
        _this.label_ = "subtitles";
        if (["en", "en-us", "en-ca", "fr-ca"].indexOf(_this.player_.language_) > -1) {
          _this.label_ = "captions";
        }
        _this.menuButton_.controlText(toTitleCase$1(_this.label_));
        return _this;
      }
      var _proto = SubsCapsButton2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      _proto.createItems = function createItems() {
        var items = [];
        if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
          items.push(new CaptionSettingsMenuItem(this.player_, {
            kind: this.label_
          }));
          this.hideThreshold_ += 1;
        }
        items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
        return items;
      };
      return SubsCapsButton2;
    }(TextTrackButton);
    SubsCapsButton.prototype.kinds_ = ["captions", "subtitles"];
    SubsCapsButton.prototype.controlText_ = "Subtitles";
    Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
    var AudioTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
      _inheritsLoose__default["default"](AudioTrackMenuItem2, _MenuItem);
      function AudioTrackMenuItem2(player, options) {
        var _this;
        var track = options.track;
        var tracks = player.audioTracks();
        options.label = track.label || track.language || "Unknown";
        options.selected = track.enabled;
        _this = _MenuItem.call(this, player, options) || this;
        _this.track = track;
        _this.addClass("vjs-" + track.kind + "-menu-item");
        var changeHandler = function changeHandler2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this.handleTracksChange.apply(_assertThisInitialized__default["default"](_this), args);
        };
        tracks.addEventListener("change", changeHandler);
        _this.on("dispose", function() {
          tracks.removeEventListener("change", changeHandler);
        });
        return _this;
      }
      var _proto = AudioTrackMenuItem2.prototype;
      _proto.createEl = function createEl$1(type, props, attrs) {
        var el = _MenuItem.prototype.createEl.call(this, type, props, attrs);
        var parentSpan = el.querySelector(".vjs-menu-item-text");
        if (this.options_.track.kind === "main-desc") {
          parentSpan.appendChild(createEl("span", {
            className: "vjs-icon-placeholder"
          }, {
            "aria-hidden": true
          }));
          parentSpan.appendChild(createEl("span", {
            className: "vjs-control-text",
            textContent: " " + this.localize("Descriptions")
          }));
        }
        return el;
      };
      _proto.handleClick = function handleClick(event2) {
        _MenuItem.prototype.handleClick.call(this, event2);
        this.track.enabled = true;
        if (this.player_.tech_.featuresNativeAudioTracks) {
          var tracks = this.player_.audioTracks();
          for (var i2 = 0; i2 < tracks.length; i2++) {
            var track = tracks[i2];
            if (track === this.track) {
              continue;
            }
            track.enabled = track === this.track;
          }
        }
      };
      _proto.handleTracksChange = function handleTracksChange(event2) {
        this.selected(this.track.enabled);
      };
      return AudioTrackMenuItem2;
    }(MenuItem);
    Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
    var AudioTrackButton = /* @__PURE__ */ function(_TrackButton) {
      _inheritsLoose__default["default"](AudioTrackButton2, _TrackButton);
      function AudioTrackButton2(player, options) {
        if (options === void 0) {
          options = {};
        }
        options.tracks = player.audioTracks();
        return _TrackButton.call(this, player, options) || this;
      }
      var _proto = AudioTrackButton2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-audio-button " + _TrackButton.prototype.buildCSSClass.call(this);
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-audio-button " + _TrackButton.prototype.buildWrapperCSSClass.call(this);
      };
      _proto.createItems = function createItems(items) {
        if (items === void 0) {
          items = [];
        }
        this.hideThreshold_ = 1;
        var tracks = this.player_.audioTracks();
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track = tracks[i2];
          items.push(new AudioTrackMenuItem(this.player_, {
            track,
            selectable: true,
            multiSelectable: false
          }));
        }
        return items;
      };
      return AudioTrackButton2;
    }(TrackButton);
    AudioTrackButton.prototype.controlText_ = "Audio Track";
    Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
    var PlaybackRateMenuItem = /* @__PURE__ */ function(_MenuItem) {
      _inheritsLoose__default["default"](PlaybackRateMenuItem2, _MenuItem);
      function PlaybackRateMenuItem2(player, options) {
        var _this;
        var label = options.rate;
        var rate = parseFloat(label, 10);
        options.label = label;
        options.selected = rate === player.playbackRate();
        options.selectable = true;
        options.multiSelectable = false;
        _this = _MenuItem.call(this, player, options) || this;
        _this.label = label;
        _this.rate = rate;
        _this.on(player, "ratechange", function(e) {
          return _this.update(e);
        });
        return _this;
      }
      var _proto = PlaybackRateMenuItem2.prototype;
      _proto.handleClick = function handleClick(event2) {
        _MenuItem.prototype.handleClick.call(this);
        this.player().playbackRate(this.rate);
      };
      _proto.update = function update(event2) {
        this.selected(this.player().playbackRate() === this.rate);
      };
      return PlaybackRateMenuItem2;
    }(MenuItem);
    PlaybackRateMenuItem.prototype.contentElType = "button";
    Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
    var PlaybackRateMenuButton = /* @__PURE__ */ function(_MenuButton) {
      _inheritsLoose__default["default"](PlaybackRateMenuButton2, _MenuButton);
      function PlaybackRateMenuButton2(player, options) {
        var _this;
        _this = _MenuButton.call(this, player, options) || this;
        _this.menuButton_.el_.setAttribute("aria-describedby", _this.labelElId_);
        _this.updateVisibility();
        _this.updateLabel();
        _this.on(player, "loadstart", function(e) {
          return _this.updateVisibility(e);
        });
        _this.on(player, "ratechange", function(e) {
          return _this.updateLabel(e);
        });
        _this.on(player, "playbackrateschange", function(e) {
          return _this.handlePlaybackRateschange(e);
        });
        return _this;
      }
      var _proto = PlaybackRateMenuButton2.prototype;
      _proto.createEl = function createEl$1() {
        var el = _MenuButton.prototype.createEl.call(this);
        this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
        this.labelEl_ = createEl("div", {
          className: "vjs-playback-rate-value",
          id: this.labelElId_,
          textContent: "1x"
        });
        el.appendChild(this.labelEl_);
        return el;
      };
      _proto.dispose = function dispose() {
        this.labelEl_ = null;
        _MenuButton.prototype.dispose.call(this);
      };
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-playback-rate " + _MenuButton.prototype.buildCSSClass.call(this);
      };
      _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
        return "vjs-playback-rate " + _MenuButton.prototype.buildWrapperCSSClass.call(this);
      };
      _proto.createItems = function createItems() {
        var rates = this.playbackRates();
        var items = [];
        for (var i2 = rates.length - 1; i2 >= 0; i2--) {
          items.push(new PlaybackRateMenuItem(this.player(), {
            rate: rates[i2] + "x"
          }));
        }
        return items;
      };
      _proto.updateARIAAttributes = function updateARIAAttributes() {
        this.el().setAttribute("aria-valuenow", this.player().playbackRate());
      };
      _proto.handleClick = function handleClick(event2) {
        var currentRate = this.player().playbackRate();
        var rates = this.playbackRates();
        var currentIndex = rates.indexOf(currentRate);
        var newIndex = (currentIndex + 1) % rates.length;
        this.player().playbackRate(rates[newIndex]);
      };
      _proto.handlePlaybackRateschange = function handlePlaybackRateschange(event2) {
        this.update();
      };
      _proto.playbackRates = function playbackRates() {
        var player = this.player();
        return player.playbackRates && player.playbackRates() || [];
      };
      _proto.playbackRateSupported = function playbackRateSupported() {
        return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
      };
      _proto.updateVisibility = function updateVisibility(event2) {
        if (this.playbackRateSupported()) {
          this.removeClass("vjs-hidden");
        } else {
          this.addClass("vjs-hidden");
        }
      };
      _proto.updateLabel = function updateLabel(event2) {
        if (this.playbackRateSupported()) {
          this.labelEl_.textContent = this.player().playbackRate() + "x";
        }
      };
      return PlaybackRateMenuButton2;
    }(MenuButton);
    PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
    Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
    var Spacer = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](Spacer2, _Component);
      function Spacer2() {
        return _Component.apply(this, arguments) || this;
      }
      var _proto = Spacer2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-spacer " + _Component.prototype.buildCSSClass.call(this);
      };
      _proto.createEl = function createEl2(tag, props, attributes) {
        if (tag === void 0) {
          tag = "div";
        }
        if (props === void 0) {
          props = {};
        }
        if (attributes === void 0) {
          attributes = {};
        }
        if (!props.className) {
          props.className = this.buildCSSClass();
        }
        return _Component.prototype.createEl.call(this, tag, props, attributes);
      };
      return Spacer2;
    }(Component$1);
    Component$1.registerComponent("Spacer", Spacer);
    var CustomControlSpacer = /* @__PURE__ */ function(_Spacer) {
      _inheritsLoose__default["default"](CustomControlSpacer2, _Spacer);
      function CustomControlSpacer2() {
        return _Spacer.apply(this, arguments) || this;
      }
      var _proto = CustomControlSpacer2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-custom-control-spacer " + _Spacer.prototype.buildCSSClass.call(this);
      };
      _proto.createEl = function createEl2() {
        return _Spacer.prototype.createEl.call(this, "div", {
          className: this.buildCSSClass(),
          textContent: "\xA0"
        });
      };
      return CustomControlSpacer2;
    }(Spacer);
    Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
    var ControlBar = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](ControlBar2, _Component);
      function ControlBar2() {
        return _Component.apply(this, arguments) || this;
      }
      var _proto = ControlBar2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "div", {
          className: "vjs-control-bar",
          dir: "ltr"
        });
      };
      return ControlBar2;
    }(Component$1);
    ControlBar.prototype.options_ = {
      children: ["playToggle", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"]
    };
    if ("exitPictureInPicture" in document__default["default"]) {
      ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, "pictureInPictureToggle");
    }
    Component$1.registerComponent("ControlBar", ControlBar);
    var ErrorDisplay = /* @__PURE__ */ function(_ModalDialog) {
      _inheritsLoose__default["default"](ErrorDisplay2, _ModalDialog);
      function ErrorDisplay2(player, options) {
        var _this;
        _this = _ModalDialog.call(this, player, options) || this;
        _this.on(player, "error", function(e) {
          return _this.open(e);
        });
        return _this;
      }
      var _proto = ErrorDisplay2.prototype;
      _proto.buildCSSClass = function buildCSSClass() {
        return "vjs-error-display " + _ModalDialog.prototype.buildCSSClass.call(this);
      };
      _proto.content = function content() {
        var error = this.player().error();
        return error ? this.localize(error.message) : "";
      };
      return ErrorDisplay2;
    }(ModalDialog);
    ErrorDisplay.prototype.options_ = _extends__default["default"]({}, ModalDialog.prototype.options_, {
      pauseOnOpen: false,
      fillAlways: true,
      temporary: false,
      uncloseable: true
    });
    Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
    var LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
    var COLOR_BLACK = ["#000", "Black"];
    var COLOR_BLUE = ["#00F", "Blue"];
    var COLOR_CYAN = ["#0FF", "Cyan"];
    var COLOR_GREEN = ["#0F0", "Green"];
    var COLOR_MAGENTA = ["#F0F", "Magenta"];
    var COLOR_RED = ["#F00", "Red"];
    var COLOR_WHITE = ["#FFF", "White"];
    var COLOR_YELLOW = ["#FF0", "Yellow"];
    var OPACITY_OPAQUE = ["1", "Opaque"];
    var OPACITY_SEMI = ["0.5", "Semi-Transparent"];
    var OPACITY_TRANS = ["0", "Transparent"];
    var selectConfigs = {
      backgroundColor: {
        selector: ".vjs-bg-color > select",
        id: "captions-background-color-%s",
        label: "Color",
        options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
      },
      backgroundOpacity: {
        selector: ".vjs-bg-opacity > select",
        id: "captions-background-opacity-%s",
        label: "Transparency",
        options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
      },
      color: {
        selector: ".vjs-fg-color > select",
        id: "captions-foreground-color-%s",
        label: "Color",
        options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
      },
      edgeStyle: {
        selector: ".vjs-edge-style > select",
        id: "%s",
        label: "Text Edge Style",
        options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Dropshadow"]]
      },
      fontFamily: {
        selector: ".vjs-font-family > select",
        id: "captions-font-family-%s",
        label: "Font Family",
        options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
      },
      fontPercent: {
        selector: ".vjs-font-percent > select",
        id: "captions-font-size-%s",
        label: "Font Size",
        options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
        "default": 2,
        parser: function parser(v) {
          return v === "1.00" ? null : Number(v);
        }
      },
      textOpacity: {
        selector: ".vjs-text-opacity > select",
        id: "captions-foreground-opacity-%s",
        label: "Transparency",
        options: [OPACITY_OPAQUE, OPACITY_SEMI]
      },
      windowColor: {
        selector: ".vjs-window-color > select",
        id: "captions-window-color-%s",
        label: "Color"
      },
      windowOpacity: {
        selector: ".vjs-window-opacity > select",
        id: "captions-window-opacity-%s",
        label: "Transparency",
        options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
      }
    };
    selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
    function parseOptionValue(value, parser) {
      if (parser) {
        value = parser(value);
      }
      if (value && value !== "none") {
        return value;
      }
    }
    function getSelectedOptionValue(el, parser) {
      var value = el.options[el.options.selectedIndex].value;
      return parseOptionValue(value, parser);
    }
    function setSelectedOption(el, value, parser) {
      if (!value) {
        return;
      }
      for (var i2 = 0; i2 < el.options.length; i2++) {
        if (parseOptionValue(el.options[i2].value, parser) === value) {
          el.selectedIndex = i2;
          break;
        }
      }
    }
    var TextTrackSettings = /* @__PURE__ */ function(_ModalDialog) {
      _inheritsLoose__default["default"](TextTrackSettings2, _ModalDialog);
      function TextTrackSettings2(player, options) {
        var _this;
        options.temporary = false;
        _this = _ModalDialog.call(this, player, options) || this;
        _this.updateDisplay = _this.updateDisplay.bind(_assertThisInitialized__default["default"](_this));
        _this.fill();
        _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;
        _this.endDialog = createEl("p", {
          className: "vjs-control-text",
          textContent: _this.localize("End of dialog window.")
        });
        _this.el().appendChild(_this.endDialog);
        _this.setDefaults();
        if (options.persistTextTrackSettings === void 0) {
          _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
        }
        _this.on(_this.$(".vjs-done-button"), "click", function() {
          _this.saveSettings();
          _this.close();
        });
        _this.on(_this.$(".vjs-default-button"), "click", function() {
          _this.setDefaults();
          _this.updateDisplay();
        });
        each(selectConfigs, function(config) {
          _this.on(_this.$(config.selector), "change", _this.updateDisplay);
        });
        if (_this.options_.persistTextTrackSettings) {
          _this.restoreSettings();
        }
        return _this;
      }
      var _proto = TextTrackSettings2.prototype;
      _proto.dispose = function dispose() {
        this.endDialog = null;
        _ModalDialog.prototype.dispose.call(this);
      };
      _proto.createElSelect_ = function createElSelect_(key, legendId, type) {
        var _this2 = this;
        if (legendId === void 0) {
          legendId = "";
        }
        if (type === void 0) {
          type = "label";
        }
        var config = selectConfigs[key];
        var id = config.id.replace("%s", this.id_);
        var selectLabelledbyIds = [legendId, id].join(" ").trim();
        return ["<" + type + ' id="' + id + '" class="' + (type === "label" ? "vjs-label" : "") + '">', this.localize(config.label), "</" + type + ">", '<select aria-labelledby="' + selectLabelledbyIds + '">'].concat(config.options.map(function(o) {
          var optionId = id + "-" + o[1].replace(/\W+/g, "");
          return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + selectLabelledbyIds + " " + optionId + '">', _this2.localize(o[1]), "</option>"].join("");
        })).concat("</select>").join("");
      };
      _proto.createElFgColor_ = function createElFgColor_() {
        var legendId = "captions-text-legend-" + this.id_;
        return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Text"), "</legend>", this.createElSelect_("color", legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", legendId), "</span>", "</fieldset>"].join("");
      };
      _proto.createElBgColor_ = function createElBgColor_() {
        var legendId = "captions-background-" + this.id_;
        return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Background"), "</legend>", this.createElSelect_("backgroundColor", legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", legendId), "</span>", "</fieldset>"].join("");
      };
      _proto.createElWinColor_ = function createElWinColor_() {
        var legendId = "captions-window-" + this.id_;
        return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Window"), "</legend>", this.createElSelect_("windowColor", legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", legendId), "</span>", "</fieldset>"].join("");
      };
      _proto.createElColors_ = function createElColors_() {
        return createEl("div", {
          className: "vjs-track-settings-colors",
          innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
        });
      };
      _proto.createElFont_ = function createElFont_() {
        return createEl("div", {
          className: "vjs-track-settings-font",
          innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
        });
      };
      _proto.createElControls_ = function createElControls_() {
        var defaultsDescription = this.localize("restore all settings to the default values");
        return createEl("div", {
          className: "vjs-track-settings-controls",
          innerHTML: ['<button type="button" class="vjs-default-button" title="' + defaultsDescription + '">', this.localize("Reset"), '<span class="vjs-control-text"> ' + defaultsDescription + "</span>", "</button>", '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"].join("")
        });
      };
      _proto.content = function content() {
        return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
      };
      _proto.label = function label() {
        return this.localize("Caption Settings Dialog");
      };
      _proto.description = function description() {
        return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
      };
      _proto.buildCSSClass = function buildCSSClass() {
        return _ModalDialog.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
      };
      _proto.getValues = function getValues() {
        var _this3 = this;
        return reduce(selectConfigs, function(accum, config, key) {
          var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);
          if (value !== void 0) {
            accum[key] = value;
          }
          return accum;
        }, {});
      };
      _proto.setValues = function setValues(values) {
        var _this4 = this;
        each(selectConfigs, function(config, key) {
          setSelectedOption(_this4.$(config.selector), values[key], config.parser);
        });
      };
      _proto.setDefaults = function setDefaults() {
        var _this5 = this;
        each(selectConfigs, function(config) {
          var index = config.hasOwnProperty("default") ? config["default"] : 0;
          _this5.$(config.selector).selectedIndex = index;
        });
      };
      _proto.restoreSettings = function restoreSettings() {
        var values;
        try {
          values = JSON.parse(window__default["default"].localStorage.getItem(LOCAL_STORAGE_KEY$1));
        } catch (err) {
          log$1.warn(err);
        }
        if (values) {
          this.setValues(values);
        }
      };
      _proto.saveSettings = function saveSettings() {
        if (!this.options_.persistTextTrackSettings) {
          return;
        }
        var values = this.getValues();
        try {
          if (Object.keys(values).length) {
            window__default["default"].localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values));
          } else {
            window__default["default"].localStorage.removeItem(LOCAL_STORAGE_KEY$1);
          }
        } catch (err) {
          log$1.warn(err);
        }
      };
      _proto.updateDisplay = function updateDisplay() {
        var ttDisplay = this.player_.getChild("textTrackDisplay");
        if (ttDisplay) {
          ttDisplay.updateDisplay();
        }
      };
      _proto.conditionalBlur_ = function conditionalBlur_() {
        this.previouslyActiveEl_ = null;
        var cb = this.player_.controlBar;
        var subsCapsBtn = cb && cb.subsCapsButton;
        var ccBtn = cb && cb.captionsButton;
        if (subsCapsBtn) {
          subsCapsBtn.focus();
        } else if (ccBtn) {
          ccBtn.focus();
        }
      };
      return TextTrackSettings2;
    }(ModalDialog);
    Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
    var ResizeManager = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](ResizeManager2, _Component);
      function ResizeManager2(player, options) {
        var _this;
        var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window__default["default"].ResizeObserver;
        if (options.ResizeObserver === null) {
          RESIZE_OBSERVER_AVAILABLE = false;
        }
        var options_ = mergeOptions$3({
          createEl: !RESIZE_OBSERVER_AVAILABLE,
          reportTouchActivity: false
        }, options);
        _this = _Component.call(this, player, options_) || this;
        _this.ResizeObserver = options.ResizeObserver || window__default["default"].ResizeObserver;
        _this.loadListener_ = null;
        _this.resizeObserver_ = null;
        _this.debouncedHandler_ = debounce(function() {
          _this.resizeHandler();
        }, 100, false, _assertThisInitialized__default["default"](_this));
        if (RESIZE_OBSERVER_AVAILABLE) {
          _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);
          _this.resizeObserver_.observe(player.el());
        } else {
          _this.loadListener_ = function() {
            if (!_this.el_ || !_this.el_.contentWindow) {
              return;
            }
            var debouncedHandler_ = _this.debouncedHandler_;
            var unloadListener_ = _this.unloadListener_ = function() {
              off(this, "resize", debouncedHandler_);
              off(this, "unload", unloadListener_);
              unloadListener_ = null;
            };
            on(_this.el_.contentWindow, "unload", unloadListener_);
            on(_this.el_.contentWindow, "resize", debouncedHandler_);
          };
          _this.one("load", _this.loadListener_);
        }
        return _this;
      }
      var _proto = ResizeManager2.prototype;
      _proto.createEl = function createEl2() {
        return _Component.prototype.createEl.call(this, "iframe", {
          className: "vjs-resize-manager",
          tabIndex: -1,
          title: this.localize("No content")
        }, {
          "aria-hidden": "true"
        });
      };
      _proto.resizeHandler = function resizeHandler() {
        if (!this.player_ || !this.player_.trigger) {
          return;
        }
        this.player_.trigger("playerresize");
      };
      _proto.dispose = function dispose() {
        if (this.debouncedHandler_) {
          this.debouncedHandler_.cancel();
        }
        if (this.resizeObserver_) {
          if (this.player_.el()) {
            this.resizeObserver_.unobserve(this.player_.el());
          }
          this.resizeObserver_.disconnect();
        }
        if (this.loadListener_) {
          this.off("load", this.loadListener_);
        }
        if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
          this.unloadListener_.call(this.el_.contentWindow);
        }
        this.ResizeObserver = null;
        this.resizeObserver = null;
        this.debouncedHandler_ = null;
        this.loadListener_ = null;
        _Component.prototype.dispose.call(this);
      };
      return ResizeManager2;
    }(Component$1);
    Component$1.registerComponent("ResizeManager", ResizeManager);
    var defaults2 = {
      trackingThreshold: 20,
      liveTolerance: 15
    };
    var LiveTracker = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](LiveTracker2, _Component);
      function LiveTracker2(player, options) {
        var _this;
        var options_ = mergeOptions$3(defaults2, options, {
          createEl: false
        });
        _this = _Component.call(this, player, options_) || this;
        _this.handleVisibilityChange_ = function(e) {
          return _this.handleVisibilityChange(e);
        };
        _this.trackLiveHandler_ = function() {
          return _this.trackLive_();
        };
        _this.handlePlay_ = function(e) {
          return _this.handlePlay(e);
        };
        _this.handleFirstTimeupdate_ = function(e) {
          return _this.handleFirstTimeupdate(e);
        };
        _this.handleSeeked_ = function(e) {
          return _this.handleSeeked(e);
        };
        _this.seekToLiveEdge_ = function(e) {
          return _this.seekToLiveEdge(e);
        };
        _this.reset_();
        _this.on(_this.player_, "durationchange", function(e) {
          return _this.handleDurationchange(e);
        });
        _this.on(_this.player_, "canplay", function() {
          return _this.toggleTracking();
        });
        if (IE_VERSION && "hidden" in document__default["default"] && "visibilityState" in document__default["default"]) {
          _this.on(document__default["default"], "visibilitychange", _this.handleVisibilityChange_);
        }
        return _this;
      }
      var _proto = LiveTracker2.prototype;
      _proto.handleVisibilityChange = function handleVisibilityChange() {
        if (this.player_.duration() !== Infinity) {
          return;
        }
        if (document__default["default"].hidden) {
          this.stopTracking();
        } else {
          this.startTracking();
        }
      };
      _proto.trackLive_ = function trackLive_() {
        var seekable2 = this.player_.seekable();
        if (!seekable2 || !seekable2.length) {
          return;
        }
        var newTime = Number(window__default["default"].performance.now().toFixed(4));
        var deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
        this.lastTime_ = newTime;
        this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
        var liveCurrentTime = this.liveCurrentTime();
        var currentTime = this.player_.currentTime();
        var isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
        if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
          isBehind = false;
        }
        if (isBehind !== this.behindLiveEdge_) {
          this.behindLiveEdge_ = isBehind;
          this.trigger("liveedgechange");
        }
      };
      _proto.handleDurationchange = function handleDurationchange() {
        this.toggleTracking();
      };
      _proto.toggleTracking = function toggleTracking() {
        if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
          if (this.player_.options_.liveui) {
            this.player_.addClass("vjs-liveui");
          }
          this.startTracking();
        } else {
          this.player_.removeClass("vjs-liveui");
          this.stopTracking();
        }
      };
      _proto.startTracking = function startTracking() {
        if (this.isTracking()) {
          return;
        }
        if (!this.timeupdateSeen_) {
          this.timeupdateSeen_ = this.player_.hasStarted();
        }
        this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
        this.trackLive_();
        this.on(this.player_, ["play", "pause"], this.trackLiveHandler_);
        if (!this.timeupdateSeen_) {
          this.one(this.player_, "play", this.handlePlay_);
          this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
        } else {
          this.on(this.player_, "seeked", this.handleSeeked_);
        }
      };
      _proto.handleFirstTimeupdate = function handleFirstTimeupdate() {
        this.timeupdateSeen_ = true;
        this.on(this.player_, "seeked", this.handleSeeked_);
      };
      _proto.handleSeeked = function handleSeeked() {
        var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
        this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
        this.nextSeekedFromUser_ = false;
        this.trackLive_();
      };
      _proto.handlePlay = function handlePlay3() {
        this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
      };
      _proto.reset_ = function reset_() {
        this.lastTime_ = -1;
        this.pastSeekEnd_ = 0;
        this.lastSeekEnd_ = -1;
        this.behindLiveEdge_ = true;
        this.timeupdateSeen_ = false;
        this.seekedBehindLive_ = false;
        this.nextSeekedFromUser_ = false;
        this.clearInterval(this.trackingInterval_);
        this.trackingInterval_ = null;
        this.off(this.player_, ["play", "pause"], this.trackLiveHandler_);
        this.off(this.player_, "seeked", this.handleSeeked_);
        this.off(this.player_, "play", this.handlePlay_);
        this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
        this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
      };
      _proto.nextSeekedFromUser = function nextSeekedFromUser() {
        this.nextSeekedFromUser_ = true;
      };
      _proto.stopTracking = function stopTracking() {
        if (!this.isTracking()) {
          return;
        }
        this.reset_();
        this.trigger("liveedgechange");
      };
      _proto.seekableEnd = function seekableEnd() {
        var seekable2 = this.player_.seekable();
        var seekableEnds = [];
        var i2 = seekable2 ? seekable2.length : 0;
        while (i2--) {
          seekableEnds.push(seekable2.end(i2));
        }
        return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
      };
      _proto.seekableStart = function seekableStart() {
        var seekable2 = this.player_.seekable();
        var seekableStarts = [];
        var i2 = seekable2 ? seekable2.length : 0;
        while (i2--) {
          seekableStarts.push(seekable2.start(i2));
        }
        return seekableStarts.length ? seekableStarts.sort()[0] : 0;
      };
      _proto.liveWindow = function liveWindow() {
        var liveCurrentTime = this.liveCurrentTime();
        if (liveCurrentTime === Infinity) {
          return 0;
        }
        return liveCurrentTime - this.seekableStart();
      };
      _proto.isLive = function isLive() {
        return this.isTracking();
      };
      _proto.atLiveEdge = function atLiveEdge() {
        return !this.behindLiveEdge();
      };
      _proto.liveCurrentTime = function liveCurrentTime() {
        return this.pastSeekEnd() + this.seekableEnd();
      };
      _proto.pastSeekEnd = function pastSeekEnd() {
        var seekableEnd = this.seekableEnd();
        if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
          this.pastSeekEnd_ = 0;
        }
        this.lastSeekEnd_ = seekableEnd;
        return this.pastSeekEnd_;
      };
      _proto.behindLiveEdge = function behindLiveEdge() {
        return this.behindLiveEdge_;
      };
      _proto.isTracking = function isTracking() {
        return typeof this.trackingInterval_ === "number";
      };
      _proto.seekToLiveEdge = function seekToLiveEdge() {
        this.seekedBehindLive_ = false;
        if (this.atLiveEdge()) {
          return;
        }
        this.nextSeekedFromUser_ = false;
        this.player_.currentTime(this.liveCurrentTime());
      };
      _proto.dispose = function dispose() {
        this.off(document__default["default"], "visibilitychange", this.handleVisibilityChange_);
        this.stopTracking();
        _Component.prototype.dispose.call(this);
      };
      return LiveTracker2;
    }(Component$1);
    Component$1.registerComponent("LiveTracker", LiveTracker);
    var sourcesetLoad = function sourcesetLoad2(tech) {
      var el = tech.el();
      if (el.hasAttribute("src")) {
        tech.triggerSourceset(el.src);
        return true;
      }
      var sources = tech.$$("source");
      var srcUrls = [];
      var src = "";
      if (!sources.length) {
        return false;
      }
      for (var i2 = 0; i2 < sources.length; i2++) {
        var url = sources[i2].src;
        if (url && srcUrls.indexOf(url) === -1) {
          srcUrls.push(url);
        }
      }
      if (!srcUrls.length) {
        return false;
      }
      if (srcUrls.length === 1) {
        src = srcUrls[0];
      }
      tech.triggerSourceset(src);
      return true;
    };
    var innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
      get: function get2() {
        return this.cloneNode(true).innerHTML;
      },
      set: function set2(v) {
        var dummy = document__default["default"].createElement(this.nodeName.toLowerCase());
        dummy.innerHTML = v;
        var docFrag = document__default["default"].createDocumentFragment();
        while (dummy.childNodes.length) {
          docFrag.appendChild(dummy.childNodes[0]);
        }
        this.innerText = "";
        window__default["default"].Element.prototype.appendChild.call(this, docFrag);
        return this.innerHTML;
      }
    });
    var getDescriptor = function getDescriptor2(priority, prop) {
      var descriptor = {};
      for (var i2 = 0; i2 < priority.length; i2++) {
        descriptor = Object.getOwnPropertyDescriptor(priority[i2], prop);
        if (descriptor && descriptor.set && descriptor.get) {
          break;
        }
      }
      descriptor.enumerable = true;
      descriptor.configurable = true;
      return descriptor;
    };
    var getInnerHTMLDescriptor = function getInnerHTMLDescriptor2(tech) {
      return getDescriptor([tech.el(), window__default["default"].HTMLMediaElement.prototype, window__default["default"].Element.prototype, innerHTMLDescriptorPolyfill], "innerHTML");
    };
    var firstSourceWatch = function firstSourceWatch2(tech) {
      var el = tech.el();
      if (el.resetSourceWatch_) {
        return;
      }
      var old = {};
      var innerDescriptor = getInnerHTMLDescriptor(tech);
      var appendWrapper = function appendWrapper2(appendFn) {
        return function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var retval = appendFn.apply(el, args);
          sourcesetLoad(tech);
          return retval;
        };
      };
      ["append", "appendChild", "insertAdjacentHTML"].forEach(function(k) {
        if (!el[k]) {
          return;
        }
        old[k] = el[k];
        el[k] = appendWrapper(old[k]);
      });
      Object.defineProperty(el, "innerHTML", mergeOptions$3(innerDescriptor, {
        set: appendWrapper(innerDescriptor.set)
      }));
      el.resetSourceWatch_ = function() {
        el.resetSourceWatch_ = null;
        Object.keys(old).forEach(function(k) {
          el[k] = old[k];
        });
        Object.defineProperty(el, "innerHTML", innerDescriptor);
      };
      tech.one("sourceset", el.resetSourceWatch_);
    };
    var srcDescriptorPolyfill = Object.defineProperty({}, "src", {
      get: function get2() {
        if (this.hasAttribute("src")) {
          return getAbsoluteURL(window__default["default"].Element.prototype.getAttribute.call(this, "src"));
        }
        return "";
      },
      set: function set2(v) {
        window__default["default"].Element.prototype.setAttribute.call(this, "src", v);
        return v;
      }
    });
    var getSrcDescriptor = function getSrcDescriptor2(tech) {
      return getDescriptor([tech.el(), window__default["default"].HTMLMediaElement.prototype, srcDescriptorPolyfill], "src");
    };
    var setupSourceset = function setupSourceset2(tech) {
      if (!tech.featuresSourceset) {
        return;
      }
      var el = tech.el();
      if (el.resetSourceset_) {
        return;
      }
      var srcDescriptor = getSrcDescriptor(tech);
      var oldSetAttribute = el.setAttribute;
      var oldLoad = el.load;
      Object.defineProperty(el, "src", mergeOptions$3(srcDescriptor, {
        set: function set2(v) {
          var retval = srcDescriptor.set.call(el, v);
          tech.triggerSourceset(el.src);
          return retval;
        }
      }));
      el.setAttribute = function(n, v) {
        var retval = oldSetAttribute.call(el, n, v);
        if (/src/i.test(n)) {
          tech.triggerSourceset(el.src);
        }
        return retval;
      };
      el.load = function() {
        var retval = oldLoad.call(el);
        if (!sourcesetLoad(tech)) {
          tech.triggerSourceset("");
          firstSourceWatch(tech);
        }
        return retval;
      };
      if (el.currentSrc) {
        tech.triggerSourceset(el.currentSrc);
      } else if (!sourcesetLoad(tech)) {
        firstSourceWatch(tech);
      }
      el.resetSourceset_ = function() {
        el.resetSourceset_ = null;
        el.load = oldLoad;
        el.setAttribute = oldSetAttribute;
        Object.defineProperty(el, "src", srcDescriptor);
        if (el.resetSourceWatch_) {
          el.resetSourceWatch_();
        }
      };
    };
    var defineLazyProperty = function defineLazyProperty2(obj2, key, getValue, setter) {
      if (setter === void 0) {
        setter = true;
      }
      var set2 = function set3(value) {
        return Object.defineProperty(obj2, key, {
          value,
          enumerable: true,
          writable: true
        });
      };
      var options = {
        configurable: true,
        enumerable: true,
        get: function get2() {
          var value = getValue();
          set2(value);
          return value;
        }
      };
      if (setter) {
        options.set = set2;
      }
      return Object.defineProperty(obj2, key, options);
    };
    var Html5 = /* @__PURE__ */ function(_Tech) {
      _inheritsLoose__default["default"](Html52, _Tech);
      function Html52(options, ready) {
        var _this;
        _this = _Tech.call(this, options, ready) || this;
        var source = options.source;
        var crossoriginTracks = false;
        _this.featuresVideoFrameCallback = _this.featuresVideoFrameCallback && _this.el_.tagName === "VIDEO";
        if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
          _this.setSource(source);
        } else {
          _this.handleLateInit_(_this.el_);
        }
        if (options.enableSourceset) {
          _this.setupSourcesetHandling_();
        }
        _this.isScrubbing_ = false;
        if (_this.el_.hasChildNodes()) {
          var nodes = _this.el_.childNodes;
          var nodesLength = nodes.length;
          var removeNodes = [];
          while (nodesLength--) {
            var node = nodes[nodesLength];
            var nodeName = node.nodeName.toLowerCase();
            if (nodeName === "track") {
              if (!_this.featuresNativeTextTracks) {
                removeNodes.push(node);
              } else {
                _this.remoteTextTrackEls().addTrackElement_(node);
                _this.remoteTextTracks().addTrack(node.track);
                _this.textTracks().addTrack(node.track);
                if (!crossoriginTracks && !_this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src)) {
                  crossoriginTracks = true;
                }
              }
            }
          }
          for (var i2 = 0; i2 < removeNodes.length; i2++) {
            _this.el_.removeChild(removeNodes[i2]);
          }
        }
        _this.proxyNativeTracks_();
        if (_this.featuresNativeTextTracks && crossoriginTracks) {
          log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading.");
        }
        _this.restoreMetadataTracksInIOSNativePlayer_();
        if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
          _this.setControls(true);
        }
        _this.proxyWebkitFullscreen_();
        _this.triggerReady();
        return _this;
      }
      var _proto = Html52.prototype;
      _proto.dispose = function dispose() {
        if (this.el_ && this.el_.resetSourceset_) {
          this.el_.resetSourceset_();
        }
        Html52.disposeMediaElement(this.el_);
        this.options_ = null;
        _Tech.prototype.dispose.call(this);
      };
      _proto.setupSourcesetHandling_ = function setupSourcesetHandling_() {
        setupSourceset(this);
      };
      _proto.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
        var textTracks = this.textTracks();
        var metadataTracksPreFullscreenState;
        var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot2() {
          metadataTracksPreFullscreenState = [];
          for (var i2 = 0; i2 < textTracks.length; i2++) {
            var track = textTracks[i2];
            if (track.kind === "metadata") {
              metadataTracksPreFullscreenState.push({
                track,
                storedMode: track.mode
              });
            }
          }
        };
        takeMetadataTrackSnapshot();
        textTracks.addEventListener("change", takeMetadataTrackSnapshot);
        this.on("dispose", function() {
          return textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
        });
        var restoreTrackMode = function restoreTrackMode2() {
          for (var i2 = 0; i2 < metadataTracksPreFullscreenState.length; i2++) {
            var storedTrack = metadataTracksPreFullscreenState[i2];
            if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) {
              storedTrack.track.mode = storedTrack.storedMode;
            }
          }
          textTracks.removeEventListener("change", restoreTrackMode2);
        };
        this.on("webkitbeginfullscreen", function() {
          textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
          textTracks.removeEventListener("change", restoreTrackMode);
          textTracks.addEventListener("change", restoreTrackMode);
        });
        this.on("webkitendfullscreen", function() {
          textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
          textTracks.addEventListener("change", takeMetadataTrackSnapshot);
          textTracks.removeEventListener("change", restoreTrackMode);
        });
      };
      _proto.overrideNative_ = function overrideNative_(type, override) {
        var _this2 = this;
        if (override !== this["featuresNative" + type + "Tracks"]) {
          return;
        }
        var lowerCaseType = type.toLowerCase();
        if (this[lowerCaseType + "TracksListeners_"]) {
          Object.keys(this[lowerCaseType + "TracksListeners_"]).forEach(function(eventName) {
            var elTracks = _this2.el()[lowerCaseType + "Tracks"];
            elTracks.removeEventListener(eventName, _this2[lowerCaseType + "TracksListeners_"][eventName]);
          });
        }
        this["featuresNative" + type + "Tracks"] = !override;
        this[lowerCaseType + "TracksListeners_"] = null;
        this.proxyNativeTracksForType_(lowerCaseType);
      };
      _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {
        this.overrideNative_("Audio", override);
      };
      _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {
        this.overrideNative_("Video", override);
      };
      _proto.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {
        var _this3 = this;
        var props = NORMAL[name];
        var elTracks = this.el()[props.getterName];
        var techTracks = this[props.getterName]();
        if (!this["featuresNative" + props.capitalName + "Tracks"] || !elTracks || !elTracks.addEventListener) {
          return;
        }
        var listeners = {
          change: function change(e) {
            var event2 = {
              type: "change",
              target: techTracks,
              currentTarget: techTracks,
              srcElement: techTracks
            };
            techTracks.trigger(event2);
            if (name === "text") {
              _this3[REMOTE.remoteText.getterName]().trigger(event2);
            }
          },
          addtrack: function addtrack(e) {
            techTracks.addTrack(e.track);
          },
          removetrack: function removetrack(e) {
            techTracks.removeTrack(e.track);
          }
        };
        var removeOldTracks = function removeOldTracks2() {
          var removeTracks = [];
          for (var i2 = 0; i2 < techTracks.length; i2++) {
            var found = false;
            for (var j = 0; j < elTracks.length; j++) {
              if (elTracks[j] === techTracks[i2]) {
                found = true;
                break;
              }
            }
            if (!found) {
              removeTracks.push(techTracks[i2]);
            }
          }
          while (removeTracks.length) {
            techTracks.removeTrack(removeTracks.shift());
          }
        };
        this[props.getterName + "Listeners_"] = listeners;
        Object.keys(listeners).forEach(function(eventName) {
          var listener = listeners[eventName];
          elTracks.addEventListener(eventName, listener);
          _this3.on("dispose", function(e) {
            return elTracks.removeEventListener(eventName, listener);
          });
        });
        this.on("loadstart", removeOldTracks);
        this.on("dispose", function(e) {
          return _this3.off("loadstart", removeOldTracks);
        });
      };
      _proto.proxyNativeTracks_ = function proxyNativeTracks_() {
        var _this4 = this;
        NORMAL.names.forEach(function(name) {
          _this4.proxyNativeTracksForType_(name);
        });
      };
      _proto.createEl = function createEl2() {
        var el = this.options_.tag;
        if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
          if (el) {
            var clone = el.cloneNode(true);
            if (el.parentNode) {
              el.parentNode.insertBefore(clone, el);
            }
            Html52.disposeMediaElement(el);
            el = clone;
          } else {
            el = document__default["default"].createElement("video");
            var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
            var attributes = mergeOptions$3({}, tagAttributes);
            if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
              delete attributes.controls;
            }
            setAttributes(el, assign(attributes, {
              id: this.options_.techId,
              "class": "vjs-tech"
            }));
          }
          el.playerId = this.options_.playerId;
        }
        if (typeof this.options_.preload !== "undefined") {
          setAttribute(el, "preload", this.options_.preload);
        }
        if (this.options_.disablePictureInPicture !== void 0) {
          el.disablePictureInPicture = this.options_.disablePictureInPicture;
        }
        var settingsAttrs = ["loop", "muted", "playsinline", "autoplay"];
        for (var i2 = 0; i2 < settingsAttrs.length; i2++) {
          var attr = settingsAttrs[i2];
          var value = this.options_[attr];
          if (typeof value !== "undefined") {
            if (value) {
              setAttribute(el, attr, attr);
            } else {
              removeAttribute(el, attr);
            }
            el[attr] = value;
          }
        }
        return el;
      };
      _proto.handleLateInit_ = function handleLateInit_(el) {
        if (el.networkState === 0 || el.networkState === 3) {
          return;
        }
        if (el.readyState === 0) {
          var loadstartFired = false;
          var setLoadstartFired = function setLoadstartFired2() {
            loadstartFired = true;
          };
          this.on("loadstart", setLoadstartFired);
          var triggerLoadstart = function triggerLoadstart2() {
            if (!loadstartFired) {
              this.trigger("loadstart");
            }
          };
          this.on("loadedmetadata", triggerLoadstart);
          this.ready(function() {
            this.off("loadstart", setLoadstartFired);
            this.off("loadedmetadata", triggerLoadstart);
            if (!loadstartFired) {
              this.trigger("loadstart");
            }
          });
          return;
        }
        var eventsToTrigger = ["loadstart"];
        eventsToTrigger.push("loadedmetadata");
        if (el.readyState >= 2) {
          eventsToTrigger.push("loadeddata");
        }
        if (el.readyState >= 3) {
          eventsToTrigger.push("canplay");
        }
        if (el.readyState >= 4) {
          eventsToTrigger.push("canplaythrough");
        }
        this.ready(function() {
          eventsToTrigger.forEach(function(type) {
            this.trigger(type);
          }, this);
        });
      };
      _proto.setScrubbing = function setScrubbing(isScrubbing) {
        this.isScrubbing_ = isScrubbing;
      };
      _proto.scrubbing = function scrubbing() {
        return this.isScrubbing_;
      };
      _proto.setCurrentTime = function setCurrentTime(seconds) {
        try {
          if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
            this.el_.fastSeek(seconds);
          } else {
            this.el_.currentTime = seconds;
          }
        } catch (e) {
          log$1(e, "Video is not ready. (Video.js)");
        }
      };
      _proto.duration = function duration2() {
        var _this5 = this;
        if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
          var checkProgress = function checkProgress2() {
            if (_this5.el_.currentTime > 0) {
              if (_this5.el_.duration === Infinity) {
                _this5.trigger("durationchange");
              }
              _this5.off("timeupdate", checkProgress2);
            }
          };
          this.on("timeupdate", checkProgress);
          return NaN;
        }
        return this.el_.duration || NaN;
      };
      _proto.width = function width() {
        return this.el_.offsetWidth;
      };
      _proto.height = function height() {
        return this.el_.offsetHeight;
      };
      _proto.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
        var _this6 = this;
        if (!("webkitDisplayingFullscreen" in this.el_)) {
          return;
        }
        var endFn = function endFn2() {
          this.trigger("fullscreenchange", {
            isFullscreen: false
          });
          if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
            this.el_.controls = false;
          }
        };
        var beginFn = function beginFn2() {
          if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
            this.one("webkitendfullscreen", endFn);
            this.trigger("fullscreenchange", {
              isFullscreen: true,
              nativeIOSFullscreen: true
            });
          }
        };
        this.on("webkitbeginfullscreen", beginFn);
        this.on("dispose", function() {
          _this6.off("webkitbeginfullscreen", beginFn);
          _this6.off("webkitendfullscreen", endFn);
        });
      };
      _proto.supportsFullScreen = function supportsFullScreen() {
        if (typeof this.el_.webkitEnterFullScreen === "function") {
          var userAgent = window__default["default"].navigator && window__default["default"].navigator.userAgent || "";
          if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
            return true;
          }
        }
        return false;
      };
      _proto.enterFullScreen = function enterFullScreen() {
        var video = this.el_;
        if (video.paused && video.networkState <= video.HAVE_METADATA) {
          silencePromise(this.el_.play());
          this.setTimeout(function() {
            video.pause();
            try {
              video.webkitEnterFullScreen();
            } catch (e) {
              this.trigger("fullscreenerror", e);
            }
          }, 0);
        } else {
          try {
            video.webkitEnterFullScreen();
          } catch (e) {
            this.trigger("fullscreenerror", e);
          }
        }
      };
      _proto.exitFullScreen = function exitFullScreen() {
        if (!this.el_.webkitDisplayingFullscreen) {
          this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
          return;
        }
        this.el_.webkitExitFullScreen();
      };
      _proto.requestPictureInPicture = function requestPictureInPicture() {
        return this.el_.requestPictureInPicture();
      };
      _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb) {
        if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
          return this.el_.requestVideoFrameCallback(cb);
        }
        return _Tech.prototype.requestVideoFrameCallback.call(this, cb);
      };
      _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id) {
        if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
          this.el_.cancelVideoFrameCallback(id);
        } else {
          _Tech.prototype.cancelVideoFrameCallback.call(this, id);
        }
      };
      _proto.src = function src(_src) {
        if (_src === void 0) {
          return this.el_.src;
        }
        this.setSrc(_src);
      };
      _proto.reset = function reset2() {
        Html52.resetMediaElement(this.el_);
      };
      _proto.currentSrc = function currentSrc() {
        if (this.currentSource_) {
          return this.currentSource_.src;
        }
        return this.el_.currentSrc;
      };
      _proto.setControls = function setControls(val) {
        this.el_.controls = !!val;
      };
      _proto.addTextTrack = function addTextTrack(kind, label, language) {
        if (!this.featuresNativeTextTracks) {
          return _Tech.prototype.addTextTrack.call(this, kind, label, language);
        }
        return this.el_.addTextTrack(kind, label, language);
      };
      _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
        if (!this.featuresNativeTextTracks) {
          return _Tech.prototype.createRemoteTextTrack.call(this, options);
        }
        var htmlTrackElement = document__default["default"].createElement("track");
        if (options.kind) {
          htmlTrackElement.kind = options.kind;
        }
        if (options.label) {
          htmlTrackElement.label = options.label;
        }
        if (options.language || options.srclang) {
          htmlTrackElement.srclang = options.language || options.srclang;
        }
        if (options["default"]) {
          htmlTrackElement["default"] = options["default"];
        }
        if (options.id) {
          htmlTrackElement.id = options.id;
        }
        if (options.src) {
          htmlTrackElement.src = options.src;
        }
        return htmlTrackElement;
      };
      _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
        var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);
        if (this.featuresNativeTextTracks) {
          this.el().appendChild(htmlTrackElement);
        }
        return htmlTrackElement;
      };
      _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
        _Tech.prototype.removeRemoteTextTrack.call(this, track);
        if (this.featuresNativeTextTracks) {
          var tracks = this.$$("track");
          var i2 = tracks.length;
          while (i2--) {
            if (track === tracks[i2] || track === tracks[i2].track) {
              this.el().removeChild(tracks[i2]);
            }
          }
        }
      };
      _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
        if (typeof this.el().getVideoPlaybackQuality === "function") {
          return this.el().getVideoPlaybackQuality();
        }
        var videoPlaybackQuality = {};
        if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
          videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
          videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
        }
        if (window__default["default"].performance && typeof window__default["default"].performance.now === "function") {
          videoPlaybackQuality.creationTime = window__default["default"].performance.now();
        } else if (window__default["default"].performance && window__default["default"].performance.timing && typeof window__default["default"].performance.timing.navigationStart === "number") {
          videoPlaybackQuality.creationTime = window__default["default"].Date.now() - window__default["default"].performance.timing.navigationStart;
        }
        return videoPlaybackQuality;
      };
      return Html52;
    }(Tech);
    defineLazyProperty(Html5, "TEST_VID", function() {
      if (!isReal()) {
        return;
      }
      var video = document__default["default"].createElement("video");
      var track = document__default["default"].createElement("track");
      track.kind = "captions";
      track.srclang = "en";
      track.label = "English";
      video.appendChild(track);
      return video;
    });
    Html5.isSupported = function() {
      try {
        Html5.TEST_VID.volume = 0.5;
      } catch (e) {
        return false;
      }
      return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
    };
    Html5.canPlayType = function(type) {
      return Html5.TEST_VID.canPlayType(type);
    };
    Html5.canPlaySource = function(srcObj, options) {
      return Html5.canPlayType(srcObj.type);
    };
    Html5.canControlVolume = function() {
      try {
        var volume = Html5.TEST_VID.volume;
        Html5.TEST_VID.volume = volume / 2 + 0.1;
        var canControl = volume !== Html5.TEST_VID.volume;
        if (canControl && IS_IOS) {
          window__default["default"].setTimeout(function() {
            if (Html5 && Html5.prototype) {
              Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
            }
          });
          return false;
        }
        return canControl;
      } catch (e) {
        return false;
      }
    };
    Html5.canMuteVolume = function() {
      try {
        var muted = Html5.TEST_VID.muted;
        Html5.TEST_VID.muted = !muted;
        if (Html5.TEST_VID.muted) {
          setAttribute(Html5.TEST_VID, "muted", "muted");
        } else {
          removeAttribute(Html5.TEST_VID, "muted", "muted");
        }
        return muted !== Html5.TEST_VID.muted;
      } catch (e) {
        return false;
      }
    };
    Html5.canControlPlaybackRate = function() {
      if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
        return false;
      }
      try {
        var playbackRate = Html5.TEST_VID.playbackRate;
        Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
        return playbackRate !== Html5.TEST_VID.playbackRate;
      } catch (e) {
        return false;
      }
    };
    Html5.canOverrideAttributes = function() {
      try {
        var noop2 = function noop3() {
        };
        Object.defineProperty(document__default["default"].createElement("video"), "src", {
          get: noop2,
          set: noop2
        });
        Object.defineProperty(document__default["default"].createElement("audio"), "src", {
          get: noop2,
          set: noop2
        });
        Object.defineProperty(document__default["default"].createElement("video"), "innerHTML", {
          get: noop2,
          set: noop2
        });
        Object.defineProperty(document__default["default"].createElement("audio"), "innerHTML", {
          get: noop2,
          set: noop2
        });
      } catch (e) {
        return false;
      }
      return true;
    };
    Html5.supportsNativeTextTracks = function() {
      return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
    };
    Html5.supportsNativeVideoTracks = function() {
      return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
    };
    Html5.supportsNativeAudioTracks = function() {
      return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
    };
    Html5.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
    [["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function(_ref) {
      var key = _ref[0], fn = _ref[1];
      defineLazyProperty(Html5.prototype, key, function() {
        return Html5[fn]();
      }, true);
    });
    Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
    Html5.prototype.movingMediaElementInDOM = !IS_IOS;
    Html5.prototype.featuresFullscreenResize = true;
    Html5.prototype.featuresProgressEvents = true;
    Html5.prototype.featuresTimeupdateEvents = true;
    Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
    var canPlayType;
    Html5.patchCanPlayType = function() {
      if (ANDROID_VERSION >= 4 && !IS_FIREFOX && !IS_CHROME) {
        canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
        Html5.TEST_VID.constructor.prototype.canPlayType = function(type) {
          var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
          if (type && mpegurlRE.test(type)) {
            return "maybe";
          }
          return canPlayType.call(this, type);
        };
      }
    };
    Html5.unpatchCanPlayType = function() {
      var r = Html5.TEST_VID.constructor.prototype.canPlayType;
      if (canPlayType) {
        Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
      }
      return r;
    };
    Html5.patchCanPlayType();
    Html5.disposeMediaElement = function(el) {
      if (!el) {
        return;
      }
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      while (el.hasChildNodes()) {
        el.removeChild(el.firstChild);
      }
      el.removeAttribute("src");
      if (typeof el.load === "function") {
        (function() {
          try {
            el.load();
          } catch (e) {
          }
        })();
      }
    };
    Html5.resetMediaElement = function(el) {
      if (!el) {
        return;
      }
      var sources = el.querySelectorAll("source");
      var i2 = sources.length;
      while (i2--) {
        el.removeChild(sources[i2]);
      }
      el.removeAttribute("src");
      if (typeof el.load === "function") {
        (function() {
          try {
            el.load();
          } catch (e) {
          }
        })();
      }
    };
    [
      "muted",
      "defaultMuted",
      "autoplay",
      "controls",
      "loop",
      "playsinline"
    ].forEach(function(prop) {
      Html5.prototype[prop] = function() {
        return this.el_[prop] || this.el_.hasAttribute(prop);
      };
    });
    [
      "muted",
      "defaultMuted",
      "autoplay",
      "loop",
      "playsinline"
    ].forEach(function(prop) {
      Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
        this.el_[prop] = v;
        if (v) {
          this.el_.setAttribute(prop, prop);
        } else {
          this.el_.removeAttribute(prop);
        }
      };
    });
    [
      "paused",
      "currentTime",
      "buffered",
      "volume",
      "poster",
      "preload",
      "error",
      "seeking",
      "seekable",
      "ended",
      "playbackRate",
      "defaultPlaybackRate",
      "disablePictureInPicture",
      "played",
      "networkState",
      "readyState",
      "videoWidth",
      "videoHeight",
      "crossOrigin"
    ].forEach(function(prop) {
      Html5.prototype[prop] = function() {
        return this.el_[prop];
      };
    });
    [
      "volume",
      "src",
      "poster",
      "preload",
      "playbackRate",
      "defaultPlaybackRate",
      "disablePictureInPicture",
      "crossOrigin"
    ].forEach(function(prop) {
      Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
        this.el_[prop] = v;
      };
    });
    [
      "pause",
      "load",
      "play"
    ].forEach(function(prop) {
      Html5.prototype[prop] = function() {
        return this.el_[prop]();
      };
    });
    Tech.withSourceHandlers(Html5);
    Html5.nativeSourceHandler = {};
    Html5.nativeSourceHandler.canPlayType = function(type) {
      try {
        return Html5.TEST_VID.canPlayType(type);
      } catch (e) {
        return "";
      }
    };
    Html5.nativeSourceHandler.canHandleSource = function(source, options) {
      if (source.type) {
        return Html5.nativeSourceHandler.canPlayType(source.type);
      } else if (source.src) {
        var ext = getFileExtension(source.src);
        return Html5.nativeSourceHandler.canPlayType("video/" + ext);
      }
      return "";
    };
    Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
      tech.setSrc(source.src);
    };
    Html5.nativeSourceHandler.dispose = function() {
    };
    Html5.registerSourceHandler(Html5.nativeSourceHandler);
    Tech.registerTech("Html5", Html5);
    var TECH_EVENTS_RETRIGGER = [
      "progress",
      "abort",
      "suspend",
      "emptied",
      "stalled",
      "loadedmetadata",
      "loadeddata",
      "timeupdate",
      "resize",
      "volumechange",
      "texttrackchange"
    ];
    var TECH_EVENTS_QUEUE = {
      canplay: "CanPlay",
      canplaythrough: "CanPlayThrough",
      playing: "Playing",
      seeked: "Seeked"
    };
    var BREAKPOINT_ORDER = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"];
    var BREAKPOINT_CLASSES = {};
    BREAKPOINT_ORDER.forEach(function(k) {
      var v = k.charAt(0) === "x" ? "x-" + k.substring(1) : k;
      BREAKPOINT_CLASSES[k] = "vjs-layout-" + v;
    });
    var DEFAULT_BREAKPOINTS = {
      tiny: 210,
      xsmall: 320,
      small: 425,
      medium: 768,
      large: 1440,
      xlarge: 2560,
      huge: Infinity
    };
    var Player = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](Player2, _Component);
      function Player2(tag, options, ready) {
        var _this;
        tag.id = tag.id || options.id || "vjs_video_" + newGUID();
        options = assign(Player2.getTagSettings(tag), options);
        options.initChildren = false;
        options.createEl = false;
        options.evented = false;
        options.reportTouchActivity = false;
        if (!options.language) {
          if (typeof tag.closest === "function") {
            var closest = tag.closest("[lang]");
            if (closest && closest.getAttribute) {
              options.language = closest.getAttribute("lang");
            }
          } else {
            var element = tag;
            while (element && element.nodeType === 1) {
              if (getAttributes(element).hasOwnProperty("lang")) {
                options.language = element.getAttribute("lang");
                break;
              }
              element = element.parentNode;
            }
          }
        }
        _this = _Component.call(this, null, options, ready) || this;
        _this.boundDocumentFullscreenChange_ = function(e) {
          return _this.documentFullscreenChange_(e);
        };
        _this.boundFullWindowOnEscKey_ = function(e) {
          return _this.fullWindowOnEscKey(e);
        };
        _this.boundUpdateStyleEl_ = function(e) {
          return _this.updateStyleEl_(e);
        };
        _this.boundApplyInitTime_ = function(e) {
          return _this.applyInitTime_(e);
        };
        _this.boundUpdateCurrentBreakpoint_ = function(e) {
          return _this.updateCurrentBreakpoint_(e);
        };
        _this.boundHandleTechClick_ = function(e) {
          return _this.handleTechClick_(e);
        };
        _this.boundHandleTechDoubleClick_ = function(e) {
          return _this.handleTechDoubleClick_(e);
        };
        _this.boundHandleTechTouchStart_ = function(e) {
          return _this.handleTechTouchStart_(e);
        };
        _this.boundHandleTechTouchMove_ = function(e) {
          return _this.handleTechTouchMove_(e);
        };
        _this.boundHandleTechTouchEnd_ = function(e) {
          return _this.handleTechTouchEnd_(e);
        };
        _this.boundHandleTechTap_ = function(e) {
          return _this.handleTechTap_(e);
        };
        _this.isFullscreen_ = false;
        _this.log = createLogger(_this.id_);
        _this.fsApi_ = FullscreenApi;
        _this.isPosterFromTech_ = false;
        _this.queuedCallbacks_ = [];
        _this.isReady_ = false;
        _this.hasStarted_ = false;
        _this.userActive_ = false;
        _this.debugEnabled_ = false;
        _this.audioOnlyMode_ = false;
        _this.audioPosterMode_ = false;
        _this.audioOnlyCache_ = {
          playerHeight: null,
          hiddenChildren: []
        };
        if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
          throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
        }
        _this.tag = tag;
        _this.tagAttributes = tag && getAttributes(tag);
        _this.language(_this.options_.language);
        if (options.languages) {
          var languagesToLower = {};
          Object.getOwnPropertyNames(options.languages).forEach(function(name) {
            languagesToLower[name.toLowerCase()] = options.languages[name];
          });
          _this.languages_ = languagesToLower;
        } else {
          _this.languages_ = Player2.prototype.options_.languages;
        }
        _this.resetCache_();
        _this.poster_ = options.poster || "";
        _this.controls_ = !!options.controls;
        tag.controls = false;
        tag.removeAttribute("controls");
        _this.changingSrc_ = false;
        _this.playCallbacks_ = [];
        _this.playTerminatedQueue_ = [];
        if (tag.hasAttribute("autoplay")) {
          _this.autoplay(true);
        } else {
          _this.autoplay(_this.options_.autoplay);
        }
        if (options.plugins) {
          Object.keys(options.plugins).forEach(function(name) {
            if (typeof _this[name] !== "function") {
              throw new Error('plugin "' + name + '" does not exist');
            }
          });
        }
        _this.scrubbing_ = false;
        _this.el_ = _this.createEl();
        evented(_assertThisInitialized__default["default"](_this), {
          eventBusKey: "el_"
        });
        if (_this.fsApi_.requestFullscreen) {
          on(document__default["default"], _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
          _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
        }
        if (_this.fluid_) {
          _this.on(["playerreset", "resize"], _this.boundUpdateStyleEl_);
        }
        var playerOptionsCopy = mergeOptions$3(_this.options_);
        if (options.plugins) {
          Object.keys(options.plugins).forEach(function(name) {
            _this[name](options.plugins[name]);
          });
        }
        if (options.debug) {
          _this.debug(true);
        }
        _this.options_.playerOptions = playerOptionsCopy;
        _this.middleware_ = [];
        _this.playbackRates(options.playbackRates);
        _this.initChildren();
        _this.isAudio(tag.nodeName.toLowerCase() === "audio");
        if (_this.controls()) {
          _this.addClass("vjs-controls-enabled");
        } else {
          _this.addClass("vjs-controls-disabled");
        }
        _this.el_.setAttribute("role", "region");
        if (_this.isAudio()) {
          _this.el_.setAttribute("aria-label", _this.localize("Audio Player"));
        } else {
          _this.el_.setAttribute("aria-label", _this.localize("Video Player"));
        }
        if (_this.isAudio()) {
          _this.addClass("vjs-audio");
        }
        if (_this.flexNotSupported_()) {
          _this.addClass("vjs-no-flex");
        }
        if (TOUCH_ENABLED) {
          _this.addClass("vjs-touch-enabled");
        }
        if (!IS_IOS) {
          _this.addClass("vjs-workinghover");
        }
        Player2.players[_this.id_] = _assertThisInitialized__default["default"](_this);
        var majorVersion = version$5.split(".")[0];
        _this.addClass("vjs-v" + majorVersion);
        _this.userActive(true);
        _this.reportUserActivity();
        _this.one("play", function(e) {
          return _this.listenForUserActivity_(e);
        });
        _this.on("stageclick", function(e) {
          return _this.handleStageClick_(e);
        });
        _this.on("keydown", function(e) {
          return _this.handleKeyDown(e);
        });
        _this.on("languagechange", function(e) {
          return _this.handleLanguagechange(e);
        });
        _this.breakpoints(_this.options_.breakpoints);
        _this.responsive(_this.options_.responsive);
        _this.on("ready", function() {
          _this.audioPosterMode(_this.options_.audioPosterMode);
          _this.audioOnlyMode(_this.options_.audioOnlyMode);
        });
        return _this;
      }
      var _proto = Player2.prototype;
      _proto.dispose = function dispose() {
        var _this2 = this;
        this.trigger("dispose");
        this.off("dispose");
        off(document__default["default"], this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
        off(document__default["default"], "keydown", this.boundFullWindowOnEscKey_);
        if (this.styleEl_ && this.styleEl_.parentNode) {
          this.styleEl_.parentNode.removeChild(this.styleEl_);
          this.styleEl_ = null;
        }
        Player2.players[this.id_] = null;
        if (this.tag && this.tag.player) {
          this.tag.player = null;
        }
        if (this.el_ && this.el_.player) {
          this.el_.player = null;
        }
        if (this.tech_) {
          this.tech_.dispose();
          this.isPosterFromTech_ = false;
          this.poster_ = "";
        }
        if (this.playerElIngest_) {
          this.playerElIngest_ = null;
        }
        if (this.tag) {
          this.tag = null;
        }
        clearCacheForPlayer(this);
        ALL.names.forEach(function(name) {
          var props = ALL[name];
          var list = _this2[props.getterName]();
          if (list && list.off) {
            list.off();
          }
        });
        _Component.prototype.dispose.call(this, {
          restoreEl: this.options_.restoreEl
        });
      };
      _proto.createEl = function createEl2() {
        var tag = this.tag;
        var el;
        var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
        var divEmbed = this.tag.tagName.toLowerCase() === "video-js";
        if (playerElIngest) {
          el = this.el_ = tag.parentNode;
        } else if (!divEmbed) {
          el = this.el_ = _Component.prototype.createEl.call(this, "div");
        }
        var attrs = getAttributes(tag);
        if (divEmbed) {
          el = this.el_ = tag;
          tag = this.tag = document__default["default"].createElement("video");
          while (el.children.length) {
            tag.appendChild(el.firstChild);
          }
          if (!hasClass(el, "video-js")) {
            addClass(el, "video-js");
          }
          el.appendChild(tag);
          playerElIngest = this.playerElIngest_ = el;
          Object.keys(el).forEach(function(k) {
            try {
              tag[k] = el[k];
            } catch (e) {
            }
          });
        }
        tag.setAttribute("tabindex", "-1");
        attrs.tabindex = "-1";
        if (IE_VERSION || IS_CHROME && IS_WINDOWS) {
          tag.setAttribute("role", "application");
          attrs.role = "application";
        }
        tag.removeAttribute("width");
        tag.removeAttribute("height");
        if ("width" in attrs) {
          delete attrs.width;
        }
        if ("height" in attrs) {
          delete attrs.height;
        }
        Object.getOwnPropertyNames(attrs).forEach(function(attr) {
          if (!(divEmbed && attr === "class")) {
            el.setAttribute(attr, attrs[attr]);
          }
          if (divEmbed) {
            tag.setAttribute(attr, attrs[attr]);
          }
        });
        tag.playerId = tag.id;
        tag.id += "_html5_api";
        tag.className = "vjs-tech";
        tag.player = el.player = this;
        this.addClass("vjs-paused");
        if (window__default["default"].VIDEOJS_NO_DYNAMIC_STYLE !== true) {
          this.styleEl_ = createStyleElement("vjs-styles-dimensions");
          var defaultsStyleEl = $(".vjs-styles-defaults");
          var head2 = $("head");
          head2.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head2.firstChild);
        }
        this.fill_ = false;
        this.fluid_ = false;
        this.width(this.options_.width);
        this.height(this.options_.height);
        this.fill(this.options_.fill);
        this.fluid(this.options_.fluid);
        this.aspectRatio(this.options_.aspectRatio);
        this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
        var links = tag.getElementsByTagName("a");
        for (var i2 = 0; i2 < links.length; i2++) {
          var linkEl = links.item(i2);
          addClass(linkEl, "vjs-hidden");
          linkEl.setAttribute("hidden", "hidden");
        }
        tag.initNetworkState_ = tag.networkState;
        if (tag.parentNode && !playerElIngest) {
          tag.parentNode.insertBefore(el, tag);
        }
        prependTo(tag, el);
        this.children_.unshift(tag);
        this.el_.setAttribute("lang", this.language_);
        this.el_.setAttribute("translate", "no");
        this.el_ = el;
        return el;
      };
      _proto.crossOrigin = function crossOrigin(value) {
        if (!value) {
          return this.techGet_("crossOrigin");
        }
        if (value !== "anonymous" && value !== "use-credentials") {
          log$1.warn('crossOrigin must be "anonymous" or "use-credentials", given "' + value + '"');
          return;
        }
        this.techCall_("setCrossOrigin", value);
        return;
      };
      _proto.width = function width(value) {
        return this.dimension("width", value);
      };
      _proto.height = function height(value) {
        return this.dimension("height", value);
      };
      _proto.dimension = function dimension(_dimension, value) {
        var privDimension = _dimension + "_";
        if (value === void 0) {
          return this[privDimension] || 0;
        }
        if (value === "" || value === "auto") {
          this[privDimension] = void 0;
          this.updateStyleEl_();
          return;
        }
        var parsedVal = parseFloat(value);
        if (isNaN(parsedVal)) {
          log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
          return;
        }
        this[privDimension] = parsedVal;
        this.updateStyleEl_();
      };
      _proto.fluid = function fluid(bool) {
        var _this3 = this;
        if (bool === void 0) {
          return !!this.fluid_;
        }
        this.fluid_ = !!bool;
        if (isEvented(this)) {
          this.off(["playerreset", "resize"], this.boundUpdateStyleEl_);
        }
        if (bool) {
          this.addClass("vjs-fluid");
          this.fill(false);
          addEventedCallback(this, function() {
            _this3.on(["playerreset", "resize"], _this3.boundUpdateStyleEl_);
          });
        } else {
          this.removeClass("vjs-fluid");
        }
        this.updateStyleEl_();
      };
      _proto.fill = function fill(bool) {
        if (bool === void 0) {
          return !!this.fill_;
        }
        this.fill_ = !!bool;
        if (bool) {
          this.addClass("vjs-fill");
          this.fluid(false);
        } else {
          this.removeClass("vjs-fill");
        }
      };
      _proto.aspectRatio = function aspectRatio(ratio) {
        if (ratio === void 0) {
          return this.aspectRatio_;
        }
        if (!/^\d+\:\d+$/.test(ratio)) {
          throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
        }
        this.aspectRatio_ = ratio;
        this.fluid(true);
        this.updateStyleEl_();
      };
      _proto.updateStyleEl_ = function updateStyleEl_() {
        if (window__default["default"].VIDEOJS_NO_DYNAMIC_STYLE === true) {
          var _width = typeof this.width_ === "number" ? this.width_ : this.options_.width;
          var _height = typeof this.height_ === "number" ? this.height_ : this.options_.height;
          var techEl = this.tech_ && this.tech_.el();
          if (techEl) {
            if (_width >= 0) {
              techEl.width = _width;
            }
            if (_height >= 0) {
              techEl.height = _height;
            }
          }
          return;
        }
        var width;
        var height;
        var aspectRatio;
        var idClass;
        if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") {
          aspectRatio = this.aspectRatio_;
        } else if (this.videoWidth() > 0) {
          aspectRatio = this.videoWidth() + ":" + this.videoHeight();
        } else {
          aspectRatio = "16:9";
        }
        var ratioParts = aspectRatio.split(":");
        var ratioMultiplier = ratioParts[1] / ratioParts[0];
        if (this.width_ !== void 0) {
          width = this.width_;
        } else if (this.height_ !== void 0) {
          width = this.height_ / ratioMultiplier;
        } else {
          width = this.videoWidth() || 300;
        }
        if (this.height_ !== void 0) {
          height = this.height_;
        } else {
          height = width * ratioMultiplier;
        }
        if (/^[^a-zA-Z]/.test(this.id())) {
          idClass = "dimensions-" + this.id();
        } else {
          idClass = this.id() + "-dimensions";
        }
        this.addClass(idClass);
        setTextContent(this.styleEl_, "\n      ." + idClass + " {\n        width: " + width + "px;\n        height: " + height + "px;\n      }\n\n      ." + idClass + ".vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: " + ratioMultiplier * 100 + "%;\n      }\n    ");
      };
      _proto.loadTech_ = function loadTech_(techName, source) {
        var _this4 = this;
        if (this.tech_) {
          this.unloadTech_();
        }
        var titleTechName = toTitleCase$1(techName);
        var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
        if (titleTechName !== "Html5" && this.tag) {
          Tech.getTech("Html5").disposeMediaElement(this.tag);
          this.tag.player = null;
          this.tag = null;
        }
        this.techName_ = titleTechName;
        this.isReady_ = false;
        var autoplay = this.autoplay();
        if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) {
          autoplay = false;
        }
        var techOptions = {
          source,
          autoplay,
          "nativeControlsForTouch": this.options_.nativeControlsForTouch,
          "playerId": this.id(),
          "techId": this.id() + "_" + camelTechName + "_api",
          "playsinline": this.options_.playsinline,
          "preload": this.options_.preload,
          "loop": this.options_.loop,
          "disablePictureInPicture": this.options_.disablePictureInPicture,
          "muted": this.options_.muted,
          "poster": this.poster(),
          "language": this.language(),
          "playerElIngest": this.playerElIngest_ || false,
          "vtt.js": this.options_["vtt.js"],
          "canOverridePoster": !!this.options_.techCanOverridePoster,
          "enableSourceset": this.options_.enableSourceset,
          "Promise": this.options_.Promise
        };
        ALL.names.forEach(function(name) {
          var props = ALL[name];
          techOptions[props.getterName] = _this4[props.privateName];
        });
        assign(techOptions, this.options_[titleTechName]);
        assign(techOptions, this.options_[camelTechName]);
        assign(techOptions, this.options_[techName.toLowerCase()]);
        if (this.tag) {
          techOptions.tag = this.tag;
        }
        if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
          techOptions.startTime = this.cache_.currentTime;
        }
        var TechClass = Tech.getTech(techName);
        if (!TechClass) {
          throw new Error("No Tech named '" + titleTechName + "' exists! '" + titleTechName + "' should be registered using videojs.registerTech()'");
        }
        this.tech_ = new TechClass(techOptions);
        this.tech_.ready(bind(this, this.handleTechReady_), true);
        textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
        TECH_EVENTS_RETRIGGER.forEach(function(event2) {
          _this4.on(_this4.tech_, event2, function(e) {
            return _this4["handleTech" + toTitleCase$1(event2) + "_"](e);
          });
        });
        Object.keys(TECH_EVENTS_QUEUE).forEach(function(event2) {
          _this4.on(_this4.tech_, event2, function(eventObj) {
            if (_this4.tech_.playbackRate() === 0 && _this4.tech_.seeking()) {
              _this4.queuedCallbacks_.push({
                callback: _this4["handleTech" + TECH_EVENTS_QUEUE[event2] + "_"].bind(_this4),
                event: eventObj
              });
              return;
            }
            _this4["handleTech" + TECH_EVENTS_QUEUE[event2] + "_"](eventObj);
          });
        });
        this.on(this.tech_, "loadstart", function(e) {
          return _this4.handleTechLoadStart_(e);
        });
        this.on(this.tech_, "sourceset", function(e) {
          return _this4.handleTechSourceset_(e);
        });
        this.on(this.tech_, "waiting", function(e) {
          return _this4.handleTechWaiting_(e);
        });
        this.on(this.tech_, "ended", function(e) {
          return _this4.handleTechEnded_(e);
        });
        this.on(this.tech_, "seeking", function(e) {
          return _this4.handleTechSeeking_(e);
        });
        this.on(this.tech_, "play", function(e) {
          return _this4.handleTechPlay_(e);
        });
        this.on(this.tech_, "firstplay", function(e) {
          return _this4.handleTechFirstPlay_(e);
        });
        this.on(this.tech_, "pause", function(e) {
          return _this4.handleTechPause_(e);
        });
        this.on(this.tech_, "durationchange", function(e) {
          return _this4.handleTechDurationChange_(e);
        });
        this.on(this.tech_, "fullscreenchange", function(e, data) {
          return _this4.handleTechFullscreenChange_(e, data);
        });
        this.on(this.tech_, "fullscreenerror", function(e, err) {
          return _this4.handleTechFullscreenError_(e, err);
        });
        this.on(this.tech_, "enterpictureinpicture", function(e) {
          return _this4.handleTechEnterPictureInPicture_(e);
        });
        this.on(this.tech_, "leavepictureinpicture", function(e) {
          return _this4.handleTechLeavePictureInPicture_(e);
        });
        this.on(this.tech_, "error", function(e) {
          return _this4.handleTechError_(e);
        });
        this.on(this.tech_, "posterchange", function(e) {
          return _this4.handleTechPosterChange_(e);
        });
        this.on(this.tech_, "textdata", function(e) {
          return _this4.handleTechTextData_(e);
        });
        this.on(this.tech_, "ratechange", function(e) {
          return _this4.handleTechRateChange_(e);
        });
        this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
        this.usingNativeControls(this.techGet_("controls"));
        if (this.controls() && !this.usingNativeControls()) {
          this.addTechControlsListeners_();
        }
        if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) {
          prependTo(this.tech_.el(), this.el());
        }
        if (this.tag) {
          this.tag.player = null;
          this.tag = null;
        }
      };
      _proto.unloadTech_ = function unloadTech_() {
        var _this5 = this;
        ALL.names.forEach(function(name) {
          var props = ALL[name];
          _this5[props.privateName] = _this5[props.getterName]();
        });
        this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
        this.isReady_ = false;
        this.tech_.dispose();
        this.tech_ = false;
        if (this.isPosterFromTech_) {
          this.poster_ = "";
          this.trigger("posterchange");
        }
        this.isPosterFromTech_ = false;
      };
      _proto.tech = function tech(safety) {
        if (safety === void 0) {
          log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n");
        }
        return this.tech_;
      };
      _proto.addTechControlsListeners_ = function addTechControlsListeners_() {
        this.removeTechControlsListeners_();
        this.on(this.tech_, "click", this.boundHandleTechClick_);
        this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
        this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
        this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
        this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
        this.on(this.tech_, "tap", this.boundHandleTechTap_);
      };
      _proto.removeTechControlsListeners_ = function removeTechControlsListeners_() {
        this.off(this.tech_, "tap", this.boundHandleTechTap_);
        this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
        this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
        this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
        this.off(this.tech_, "click", this.boundHandleTechClick_);
        this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
      };
      _proto.handleTechReady_ = function handleTechReady_() {
        this.triggerReady();
        if (this.cache_.volume) {
          this.techCall_("setVolume", this.cache_.volume);
        }
        this.handleTechPosterChange_();
        this.handleTechDurationChange_();
      };
      _proto.handleTechLoadStart_ = function handleTechLoadStart_() {
        this.removeClass("vjs-ended");
        this.removeClass("vjs-seeking");
        this.error(null);
        this.handleTechDurationChange_();
        if (!this.paused()) {
          this.trigger("loadstart");
          this.trigger("firstplay");
        } else {
          this.hasStarted(false);
          this.trigger("loadstart");
        }
        this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
      };
      _proto.manualAutoplay_ = function manualAutoplay_(type) {
        var _this6 = this;
        if (!this.tech_ || typeof type !== "string") {
          return;
        }
        var resolveMuted = function resolveMuted2() {
          var previouslyMuted = _this6.muted();
          _this6.muted(true);
          var restoreMuted = function restoreMuted2() {
            _this6.muted(previouslyMuted);
          };
          _this6.playTerminatedQueue_.push(restoreMuted);
          var mutedPromise = _this6.play();
          if (!isPromise(mutedPromise)) {
            return;
          }
          return mutedPromise["catch"](function(err) {
            restoreMuted();
            throw new Error("Rejection at manualAutoplay. Restoring muted value. " + (err ? err : ""));
          });
        };
        var promise;
        if (type === "any" && !this.muted()) {
          promise = this.play();
          if (isPromise(promise)) {
            promise = promise["catch"](resolveMuted);
          }
        } else if (type === "muted" && !this.muted()) {
          promise = resolveMuted();
        } else {
          promise = this.play();
        }
        if (!isPromise(promise)) {
          return;
        }
        return promise.then(function() {
          _this6.trigger({
            type: "autoplay-success",
            autoplay: type
          });
        })["catch"](function() {
          _this6.trigger({
            type: "autoplay-failure",
            autoplay: type
          });
        });
      };
      _proto.updateSourceCaches_ = function updateSourceCaches_(srcObj) {
        if (srcObj === void 0) {
          srcObj = "";
        }
        var src = srcObj;
        var type = "";
        if (typeof src !== "string") {
          src = srcObj.src;
          type = srcObj.type;
        }
        this.cache_.source = this.cache_.source || {};
        this.cache_.sources = this.cache_.sources || [];
        if (src && !type) {
          type = findMimetype(this, src);
        }
        this.cache_.source = mergeOptions$3({}, srcObj, {
          src,
          type
        });
        var matchingSources = this.cache_.sources.filter(function(s) {
          return s.src && s.src === src;
        });
        var sourceElSources = [];
        var sourceEls = this.$$("source");
        var matchingSourceEls = [];
        for (var i2 = 0; i2 < sourceEls.length; i2++) {
          var sourceObj = getAttributes(sourceEls[i2]);
          sourceElSources.push(sourceObj);
          if (sourceObj.src && sourceObj.src === src) {
            matchingSourceEls.push(sourceObj.src);
          }
        }
        if (matchingSourceEls.length && !matchingSources.length) {
          this.cache_.sources = sourceElSources;
        } else if (!matchingSources.length) {
          this.cache_.sources = [this.cache_.source];
        }
        this.cache_.src = src;
      };
      _proto.handleTechSourceset_ = function handleTechSourceset_(event2) {
        var _this7 = this;
        if (!this.changingSrc_) {
          var updateSourceCaches = function updateSourceCaches2(src) {
            return _this7.updateSourceCaches_(src);
          };
          var playerSrc = this.currentSource().src;
          var eventSrc = event2.src;
          if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
            if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
              updateSourceCaches = function updateSourceCaches2() {
              };
            }
          }
          updateSourceCaches(eventSrc);
          if (!event2.src) {
            this.tech_.any(["sourceset", "loadstart"], function(e) {
              if (e.type === "sourceset") {
                return;
              }
              var techSrc = _this7.techGet("currentSrc");
              _this7.lastSource_.tech = techSrc;
              _this7.updateSourceCaches_(techSrc);
            });
          }
        }
        this.lastSource_ = {
          player: this.currentSource().src,
          tech: event2.src
        };
        this.trigger({
          src: event2.src,
          type: "sourceset"
        });
      };
      _proto.hasStarted = function hasStarted(request) {
        if (request === void 0) {
          return this.hasStarted_;
        }
        if (request === this.hasStarted_) {
          return;
        }
        this.hasStarted_ = request;
        if (this.hasStarted_) {
          this.addClass("vjs-has-started");
          this.trigger("firstplay");
        } else {
          this.removeClass("vjs-has-started");
        }
      };
      _proto.handleTechPlay_ = function handleTechPlay_() {
        this.removeClass("vjs-ended");
        this.removeClass("vjs-paused");
        this.addClass("vjs-playing");
        this.hasStarted(true);
        this.trigger("play");
      };
      _proto.handleTechRateChange_ = function handleTechRateChange_() {
        if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
          this.queuedCallbacks_.forEach(function(queued) {
            return queued.callback(queued.event);
          });
          this.queuedCallbacks_ = [];
        }
        this.cache_.lastPlaybackRate = this.tech_.playbackRate();
        this.trigger("ratechange");
      };
      _proto.handleTechWaiting_ = function handleTechWaiting_() {
        var _this8 = this;
        this.addClass("vjs-waiting");
        this.trigger("waiting");
        var timeWhenWaiting = this.currentTime();
        var timeUpdateListener = function timeUpdateListener2() {
          if (timeWhenWaiting !== _this8.currentTime()) {
            _this8.removeClass("vjs-waiting");
            _this8.off("timeupdate", timeUpdateListener2);
          }
        };
        this.on("timeupdate", timeUpdateListener);
      };
      _proto.handleTechCanPlay_ = function handleTechCanPlay_() {
        this.removeClass("vjs-waiting");
        this.trigger("canplay");
      };
      _proto.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
        this.removeClass("vjs-waiting");
        this.trigger("canplaythrough");
      };
      _proto.handleTechPlaying_ = function handleTechPlaying_() {
        this.removeClass("vjs-waiting");
        this.trigger("playing");
      };
      _proto.handleTechSeeking_ = function handleTechSeeking_() {
        this.addClass("vjs-seeking");
        this.trigger("seeking");
      };
      _proto.handleTechSeeked_ = function handleTechSeeked_() {
        this.removeClass("vjs-seeking");
        this.removeClass("vjs-ended");
        this.trigger("seeked");
      };
      _proto.handleTechFirstPlay_ = function handleTechFirstPlay_() {
        if (this.options_.starttime) {
          log$1.warn("Passing the `starttime` option to the player will be deprecated in 6.0");
          this.currentTime(this.options_.starttime);
        }
        this.addClass("vjs-has-started");
        this.trigger("firstplay");
      };
      _proto.handleTechPause_ = function handleTechPause_() {
        this.removeClass("vjs-playing");
        this.addClass("vjs-paused");
        this.trigger("pause");
      };
      _proto.handleTechEnded_ = function handleTechEnded_() {
        this.addClass("vjs-ended");
        this.removeClass("vjs-waiting");
        if (this.options_.loop) {
          this.currentTime(0);
          this.play();
        } else if (!this.paused()) {
          this.pause();
        }
        this.trigger("ended");
      };
      _proto.handleTechDurationChange_ = function handleTechDurationChange_() {
        this.duration(this.techGet_("duration"));
      };
      _proto.handleTechClick_ = function handleTechClick_(event2) {
        if (!this.controls_) {
          return;
        }
        if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) {
          if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") {
            this.options_.userActions.click.call(this, event2);
          } else if (this.paused()) {
            silencePromise(this.play());
          } else {
            this.pause();
          }
        }
      };
      _proto.handleTechDoubleClick_ = function handleTechDoubleClick_(event2) {
        if (!this.controls_) {
          return;
        }
        var inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), function(el) {
          return el.contains(event2.target);
        });
        if (!inAllowedEls) {
          if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) {
            if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") {
              this.options_.userActions.doubleClick.call(this, event2);
            } else if (this.isFullscreen()) {
              this.exitFullscreen();
            } else {
              this.requestFullscreen();
            }
          }
        }
      };
      _proto.handleTechTap_ = function handleTechTap_() {
        this.userActive(!this.userActive());
      };
      _proto.handleTechTouchStart_ = function handleTechTouchStart_() {
        this.userWasActive = this.userActive();
      };
      _proto.handleTechTouchMove_ = function handleTechTouchMove_() {
        if (this.userWasActive) {
          this.reportUserActivity();
        }
      };
      _proto.handleTechTouchEnd_ = function handleTechTouchEnd_(event2) {
        if (event2.cancelable) {
          event2.preventDefault();
        }
      };
      _proto.handleStageClick_ = function handleStageClick_() {
        this.reportUserActivity();
      };
      _proto.toggleFullscreenClass_ = function toggleFullscreenClass_() {
        if (this.isFullscreen()) {
          this.addClass("vjs-fullscreen");
        } else {
          this.removeClass("vjs-fullscreen");
        }
      };
      _proto.documentFullscreenChange_ = function documentFullscreenChange_(e) {
        var targetPlayer = e.target.player;
        if (targetPlayer && targetPlayer !== this) {
          return;
        }
        var el = this.el();
        var isFs = document__default["default"][this.fsApi_.fullscreenElement] === el;
        if (!isFs && el.matches) {
          isFs = el.matches(":" + this.fsApi_.fullscreen);
        } else if (!isFs && el.msMatchesSelector) {
          isFs = el.msMatchesSelector(":" + this.fsApi_.fullscreen);
        }
        this.isFullscreen(isFs);
      };
      _proto.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event2, data) {
        var _this9 = this;
        if (data) {
          if (data.nativeIOSFullscreen) {
            this.addClass("vjs-ios-native-fs");
            this.tech_.one("webkitendfullscreen", function() {
              _this9.removeClass("vjs-ios-native-fs");
            });
          }
          this.isFullscreen(data.isFullscreen);
        }
      };
      _proto.handleTechFullscreenError_ = function handleTechFullscreenError_(event2, err) {
        this.trigger("fullscreenerror", err);
      };
      _proto.togglePictureInPictureClass_ = function togglePictureInPictureClass_() {
        if (this.isInPictureInPicture()) {
          this.addClass("vjs-picture-in-picture");
        } else {
          this.removeClass("vjs-picture-in-picture");
        }
      };
      _proto.handleTechEnterPictureInPicture_ = function handleTechEnterPictureInPicture_(event2) {
        this.isInPictureInPicture(true);
      };
      _proto.handleTechLeavePictureInPicture_ = function handleTechLeavePictureInPicture_(event2) {
        this.isInPictureInPicture(false);
      };
      _proto.handleTechError_ = function handleTechError_() {
        var error = this.tech_.error();
        this.error(error);
      };
      _proto.handleTechTextData_ = function handleTechTextData_() {
        var data = null;
        if (arguments.length > 1) {
          data = arguments[1];
        }
        this.trigger("textdata", data);
      };
      _proto.getCache = function getCache() {
        return this.cache_;
      };
      _proto.resetCache_ = function resetCache_() {
        this.cache_ = {
          currentTime: 0,
          initTime: 0,
          inactivityTimeout: this.options_.inactivityTimeout,
          duration: NaN,
          lastVolume: 1,
          lastPlaybackRate: this.defaultPlaybackRate(),
          media: null,
          src: "",
          source: {},
          sources: [],
          playbackRates: [],
          volume: 1
        };
      };
      _proto.techCall_ = function techCall_(method, arg) {
        this.ready(function() {
          if (method in allowedSetters) {
            return set(this.middleware_, this.tech_, method, arg);
          } else if (method in allowedMediators) {
            return mediate(this.middleware_, this.tech_, method, arg);
          }
          try {
            if (this.tech_) {
              this.tech_[method](arg);
            }
          } catch (e) {
            log$1(e);
            throw e;
          }
        }, true);
      };
      _proto.techGet_ = function techGet_(method) {
        if (!this.tech_ || !this.tech_.isReady_) {
          return;
        }
        if (method in allowedGetters) {
          return get(this.middleware_, this.tech_, method);
        } else if (method in allowedMediators) {
          return mediate(this.middleware_, this.tech_, method);
        }
        try {
          return this.tech_[method]();
        } catch (e) {
          if (this.tech_[method] === void 0) {
            log$1("Video.js: " + method + " method not defined for " + this.techName_ + " playback technology.", e);
            throw e;
          }
          if (e.name === "TypeError") {
            log$1("Video.js: " + method + " unavailable on " + this.techName_ + " playback technology element.", e);
            this.tech_.isReady_ = false;
            throw e;
          }
          log$1(e);
          throw e;
        }
      };
      _proto.play = function play() {
        var _this10 = this;
        var PromiseClass = this.options_.Promise || window__default["default"].Promise;
        if (PromiseClass) {
          return new PromiseClass(function(resolve) {
            _this10.play_(resolve);
          });
        }
        return this.play_();
      };
      _proto.play_ = function play_(callback) {
        var _this11 = this;
        if (callback === void 0) {
          callback = silencePromise;
        }
        this.playCallbacks_.push(callback);
        var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
        var isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);
        if (this.waitToPlay_) {
          this.off(["ready", "loadstart"], this.waitToPlay_);
          this.waitToPlay_ = null;
        }
        if (!this.isReady_ || !isSrcReady) {
          this.waitToPlay_ = function(e) {
            _this11.play_();
          };
          this.one(["ready", "loadstart"], this.waitToPlay_);
          if (!isSrcReady && isSafariOrIOS) {
            this.load();
          }
          return;
        }
        var val = this.techGet_("play");
        var isNativeReplay = isSafariOrIOS && this.hasClass("vjs-ended");
        if (isNativeReplay) {
          this.resetProgressBar_();
        }
        if (val === null) {
          this.runPlayTerminatedQueue_();
        } else {
          this.runPlayCallbacks_(val);
        }
      };
      _proto.runPlayTerminatedQueue_ = function runPlayTerminatedQueue_() {
        var queue = this.playTerminatedQueue_.slice(0);
        this.playTerminatedQueue_ = [];
        queue.forEach(function(q) {
          q();
        });
      };
      _proto.runPlayCallbacks_ = function runPlayCallbacks_(val) {
        var callbacks = this.playCallbacks_.slice(0);
        this.playCallbacks_ = [];
        this.playTerminatedQueue_ = [];
        callbacks.forEach(function(cb) {
          cb(val);
        });
      };
      _proto.pause = function pause() {
        this.techCall_("pause");
      };
      _proto.paused = function paused() {
        return this.techGet_("paused") === false ? false : true;
      };
      _proto.played = function played() {
        return this.techGet_("played") || createTimeRanges(0, 0);
      };
      _proto.scrubbing = function scrubbing(isScrubbing) {
        if (typeof isScrubbing === "undefined") {
          return this.scrubbing_;
        }
        this.scrubbing_ = !!isScrubbing;
        this.techCall_("setScrubbing", this.scrubbing_);
        if (isScrubbing) {
          this.addClass("vjs-scrubbing");
        } else {
          this.removeClass("vjs-scrubbing");
        }
      };
      _proto.currentTime = function currentTime(seconds) {
        if (typeof seconds !== "undefined") {
          if (seconds < 0) {
            seconds = 0;
          }
          if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
            this.cache_.initTime = seconds;
            this.off("canplay", this.boundApplyInitTime_);
            this.one("canplay", this.boundApplyInitTime_);
            return;
          }
          this.techCall_("setCurrentTime", seconds);
          this.cache_.initTime = 0;
          return;
        }
        this.cache_.currentTime = this.techGet_("currentTime") || 0;
        return this.cache_.currentTime;
      };
      _proto.applyInitTime_ = function applyInitTime_() {
        this.currentTime(this.cache_.initTime);
      };
      _proto.duration = function duration2(seconds) {
        if (seconds === void 0) {
          return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
        }
        seconds = parseFloat(seconds);
        if (seconds < 0) {
          seconds = Infinity;
        }
        if (seconds !== this.cache_.duration) {
          this.cache_.duration = seconds;
          if (seconds === Infinity) {
            this.addClass("vjs-live");
          } else {
            this.removeClass("vjs-live");
          }
          if (!isNaN(seconds)) {
            this.trigger("durationchange");
          }
        }
      };
      _proto.remainingTime = function remainingTime() {
        return this.duration() - this.currentTime();
      };
      _proto.remainingTimeDisplay = function remainingTimeDisplay() {
        return Math.floor(this.duration()) - Math.floor(this.currentTime());
      };
      _proto.buffered = function buffered() {
        var buffered2 = this.techGet_("buffered");
        if (!buffered2 || !buffered2.length) {
          buffered2 = createTimeRanges(0, 0);
        }
        return buffered2;
      };
      _proto.bufferedPercent = function bufferedPercent$1() {
        return bufferedPercent(this.buffered(), this.duration());
      };
      _proto.bufferedEnd = function bufferedEnd() {
        var buffered = this.buffered();
        var duration2 = this.duration();
        var end2 = buffered.end(buffered.length - 1);
        if (end2 > duration2) {
          end2 = duration2;
        }
        return end2;
      };
      _proto.volume = function volume(percentAsDecimal) {
        var vol;
        if (percentAsDecimal !== void 0) {
          vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
          this.cache_.volume = vol;
          this.techCall_("setVolume", vol);
          if (vol > 0) {
            this.lastVolume_(vol);
          }
          return;
        }
        vol = parseFloat(this.techGet_("volume"));
        return isNaN(vol) ? 1 : vol;
      };
      _proto.muted = function muted(_muted) {
        if (_muted !== void 0) {
          this.techCall_("setMuted", _muted);
          return;
        }
        return this.techGet_("muted") || false;
      };
      _proto.defaultMuted = function defaultMuted(_defaultMuted) {
        if (_defaultMuted !== void 0) {
          return this.techCall_("setDefaultMuted", _defaultMuted);
        }
        return this.techGet_("defaultMuted") || false;
      };
      _proto.lastVolume_ = function lastVolume_(percentAsDecimal) {
        if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
          this.cache_.lastVolume = percentAsDecimal;
          return;
        }
        return this.cache_.lastVolume;
      };
      _proto.supportsFullScreen = function supportsFullScreen() {
        return this.techGet_("supportsFullScreen") || false;
      };
      _proto.isFullscreen = function isFullscreen(isFS) {
        if (isFS !== void 0) {
          var oldValue = this.isFullscreen_;
          this.isFullscreen_ = Boolean(isFS);
          if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
            this.trigger("fullscreenchange");
          }
          this.toggleFullscreenClass_();
          return;
        }
        return this.isFullscreen_;
      };
      _proto.requestFullscreen = function requestFullscreen(fullscreenOptions) {
        var PromiseClass = this.options_.Promise || window__default["default"].Promise;
        if (PromiseClass) {
          var self2 = this;
          return new PromiseClass(function(resolve, reject) {
            function offHandler() {
              self2.off("fullscreenerror", errorHandler);
              self2.off("fullscreenchange", changeHandler);
            }
            function changeHandler() {
              offHandler();
              resolve();
            }
            function errorHandler(e, err) {
              offHandler();
              reject(err);
            }
            self2.one("fullscreenchange", changeHandler);
            self2.one("fullscreenerror", errorHandler);
            var promise = self2.requestFullscreenHelper_(fullscreenOptions);
            if (promise) {
              promise.then(offHandler, offHandler);
              promise.then(resolve, reject);
            }
          });
        }
        return this.requestFullscreenHelper_();
      };
      _proto.requestFullscreenHelper_ = function requestFullscreenHelper_(fullscreenOptions) {
        var _this12 = this;
        var fsOptions;
        if (!this.fsApi_.prefixed) {
          fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
          if (fullscreenOptions !== void 0) {
            fsOptions = fullscreenOptions;
          }
        }
        if (this.fsApi_.requestFullscreen) {
          var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
          if (promise) {
            promise.then(function() {
              return _this12.isFullscreen(true);
            }, function() {
              return _this12.isFullscreen(false);
            });
          }
          return promise;
        } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
          this.techCall_("enterFullScreen");
        } else {
          this.enterFullWindow();
        }
      };
      _proto.exitFullscreen = function exitFullscreen() {
        var PromiseClass = this.options_.Promise || window__default["default"].Promise;
        if (PromiseClass) {
          var self2 = this;
          return new PromiseClass(function(resolve, reject) {
            function offHandler() {
              self2.off("fullscreenerror", errorHandler);
              self2.off("fullscreenchange", changeHandler);
            }
            function changeHandler() {
              offHandler();
              resolve();
            }
            function errorHandler(e, err) {
              offHandler();
              reject(err);
            }
            self2.one("fullscreenchange", changeHandler);
            self2.one("fullscreenerror", errorHandler);
            var promise = self2.exitFullscreenHelper_();
            if (promise) {
              promise.then(offHandler, offHandler);
              promise.then(resolve, reject);
            }
          });
        }
        return this.exitFullscreenHelper_();
      };
      _proto.exitFullscreenHelper_ = function exitFullscreenHelper_() {
        var _this13 = this;
        if (this.fsApi_.requestFullscreen) {
          var promise = document__default["default"][this.fsApi_.exitFullscreen]();
          if (promise) {
            silencePromise(promise.then(function() {
              return _this13.isFullscreen(false);
            }));
          }
          return promise;
        } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
          this.techCall_("exitFullScreen");
        } else {
          this.exitFullWindow();
        }
      };
      _proto.enterFullWindow = function enterFullWindow() {
        this.isFullscreen(true);
        this.isFullWindow = true;
        this.docOrigOverflow = document__default["default"].documentElement.style.overflow;
        on(document__default["default"], "keydown", this.boundFullWindowOnEscKey_);
        document__default["default"].documentElement.style.overflow = "hidden";
        addClass(document__default["default"].body, "vjs-full-window");
        this.trigger("enterFullWindow");
      };
      _proto.fullWindowOnEscKey = function fullWindowOnEscKey(event2) {
        if (keycode__default["default"].isEventKey(event2, "Esc")) {
          if (this.isFullscreen() === true) {
            if (!this.isFullWindow) {
              this.exitFullscreen();
            } else {
              this.exitFullWindow();
            }
          }
        }
      };
      _proto.exitFullWindow = function exitFullWindow() {
        this.isFullscreen(false);
        this.isFullWindow = false;
        off(document__default["default"], "keydown", this.boundFullWindowOnEscKey_);
        document__default["default"].documentElement.style.overflow = this.docOrigOverflow;
        removeClass(document__default["default"].body, "vjs-full-window");
        this.trigger("exitFullWindow");
      };
      _proto.disablePictureInPicture = function disablePictureInPicture(value) {
        if (value === void 0) {
          return this.techGet_("disablePictureInPicture");
        }
        this.techCall_("setDisablePictureInPicture", value);
        this.options_.disablePictureInPicture = value;
        this.trigger("disablepictureinpicturechanged");
      };
      _proto.isInPictureInPicture = function isInPictureInPicture(isPiP) {
        if (isPiP !== void 0) {
          this.isInPictureInPicture_ = !!isPiP;
          this.togglePictureInPictureClass_();
          return;
        }
        return !!this.isInPictureInPicture_;
      };
      _proto.requestPictureInPicture = function requestPictureInPicture() {
        if ("pictureInPictureEnabled" in document__default["default"] && this.disablePictureInPicture() === false) {
          return this.techGet_("requestPictureInPicture");
        }
      };
      _proto.exitPictureInPicture = function exitPictureInPicture() {
        if ("pictureInPictureEnabled" in document__default["default"]) {
          return document__default["default"].exitPictureInPicture();
        }
      };
      _proto.handleKeyDown = function handleKeyDown(event2) {
        var userActions = this.options_.userActions;
        if (!userActions || !userActions.hotkeys) {
          return;
        }
        var excludeElement = function excludeElement2(el) {
          var tagName = el.tagName.toLowerCase();
          if (el.isContentEditable) {
            return true;
          }
          var allowedInputTypes = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
          if (tagName === "input") {
            return allowedInputTypes.indexOf(el.type) === -1;
          }
          var excludedTags = ["textarea"];
          return excludedTags.indexOf(tagName) !== -1;
        };
        if (excludeElement(this.el_.ownerDocument.activeElement)) {
          return;
        }
        if (typeof userActions.hotkeys === "function") {
          userActions.hotkeys.call(this, event2);
        } else {
          this.handleHotkeys(event2);
        }
      };
      _proto.handleHotkeys = function handleHotkeys(event2) {
        var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
        var _hotkeys$fullscreenKe = hotkeys.fullscreenKey, fullscreenKey = _hotkeys$fullscreenKe === void 0 ? function(keydownEvent) {
          return keycode__default["default"].isEventKey(keydownEvent, "f");
        } : _hotkeys$fullscreenKe, _hotkeys$muteKey = hotkeys.muteKey, muteKey = _hotkeys$muteKey === void 0 ? function(keydownEvent) {
          return keycode__default["default"].isEventKey(keydownEvent, "m");
        } : _hotkeys$muteKey, _hotkeys$playPauseKey = hotkeys.playPauseKey, playPauseKey = _hotkeys$playPauseKey === void 0 ? function(keydownEvent) {
          return keycode__default["default"].isEventKey(keydownEvent, "k") || keycode__default["default"].isEventKey(keydownEvent, "Space");
        } : _hotkeys$playPauseKey;
        if (fullscreenKey.call(this, event2)) {
          event2.preventDefault();
          event2.stopPropagation();
          var FSToggle = Component$1.getComponent("FullscreenToggle");
          if (document__default["default"][this.fsApi_.fullscreenEnabled] !== false) {
            FSToggle.prototype.handleClick.call(this, event2);
          }
        } else if (muteKey.call(this, event2)) {
          event2.preventDefault();
          event2.stopPropagation();
          var MuteToggle2 = Component$1.getComponent("MuteToggle");
          MuteToggle2.prototype.handleClick.call(this, event2);
        } else if (playPauseKey.call(this, event2)) {
          event2.preventDefault();
          event2.stopPropagation();
          var PlayToggle2 = Component$1.getComponent("PlayToggle");
          PlayToggle2.prototype.handleClick.call(this, event2);
        }
      };
      _proto.canPlayType = function canPlayType2(type) {
        var can;
        for (var i2 = 0, j = this.options_.techOrder; i2 < j.length; i2++) {
          var techName = j[i2];
          var tech = Tech.getTech(techName);
          if (!tech) {
            tech = Component$1.getComponent(techName);
          }
          if (!tech) {
            log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
            continue;
          }
          if (tech.isSupported()) {
            can = tech.canPlayType(type);
            if (can) {
              return can;
            }
          }
        }
        return "";
      };
      _proto.selectSource = function selectSource(sources) {
        var _this14 = this;
        var techs = this.options_.techOrder.map(function(techName) {
          return [techName, Tech.getTech(techName)];
        }).filter(function(_ref) {
          var techName = _ref[0], tech = _ref[1];
          if (tech) {
            return tech.isSupported();
          }
          log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
          return false;
        });
        var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair2(outerArray, innerArray, tester) {
          var found;
          outerArray.some(function(outerChoice) {
            return innerArray.some(function(innerChoice) {
              found = tester(outerChoice, innerChoice);
              if (found) {
                return true;
              }
            });
          });
          return found;
        };
        var foundSourceAndTech;
        var flip = function flip2(fn) {
          return function(a, b) {
            return fn(b, a);
          };
        };
        var finder = function finder2(_ref2, source) {
          var techName = _ref2[0], tech = _ref2[1];
          if (tech.canPlaySource(source, _this14.options_[techName.toLowerCase()])) {
            return {
              source,
              tech: techName
            };
          }
        };
        if (this.options_.sourceOrder) {
          foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
        } else {
          foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
        }
        return foundSourceAndTech || false;
      };
      _proto.handleSrc_ = function handleSrc_(source, isRetry) {
        var _this15 = this;
        if (typeof source === "undefined") {
          return this.cache_.src || "";
        }
        if (this.resetRetryOnError_) {
          this.resetRetryOnError_();
        }
        var sources = filterSource(source);
        if (!sources.length) {
          this.setTimeout(function() {
            this.error({
              code: 4,
              message: this.options_.notSupportedMessage
            });
          }, 0);
          return;
        }
        this.changingSrc_ = true;
        if (!isRetry) {
          this.cache_.sources = sources;
        }
        this.updateSourceCaches_(sources[0]);
        setSource(this, sources[0], function(middlewareSource, mws) {
          _this15.middleware_ = mws;
          if (!isRetry) {
            _this15.cache_.sources = sources;
          }
          _this15.updateSourceCaches_(middlewareSource);
          var err = _this15.src_(middlewareSource);
          if (err) {
            if (sources.length > 1) {
              return _this15.handleSrc_(sources.slice(1));
            }
            _this15.changingSrc_ = false;
            _this15.setTimeout(function() {
              this.error({
                code: 4,
                message: this.options_.notSupportedMessage
              });
            }, 0);
            _this15.triggerReady();
            return;
          }
          setTech(mws, _this15.tech_);
        });
        if (this.options_.retryOnError && sources.length > 1) {
          var retry = function retry2() {
            _this15.error(null);
            _this15.handleSrc_(sources.slice(1), true);
          };
          var stopListeningForErrors = function stopListeningForErrors2() {
            _this15.off("error", retry);
          };
          this.one("error", retry);
          this.one("playing", stopListeningForErrors);
          this.resetRetryOnError_ = function() {
            _this15.off("error", retry);
            _this15.off("playing", stopListeningForErrors);
          };
        }
      };
      _proto.src = function src(source) {
        return this.handleSrc_(source, false);
      };
      _proto.src_ = function src_(source) {
        var _this16 = this;
        var sourceTech = this.selectSource([source]);
        if (!sourceTech) {
          return true;
        }
        if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
          this.changingSrc_ = true;
          this.loadTech_(sourceTech.tech, sourceTech.source);
          this.tech_.ready(function() {
            _this16.changingSrc_ = false;
          });
          return false;
        }
        this.ready(function() {
          if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) {
            this.techCall_("setSource", source);
          } else {
            this.techCall_("src", source.src);
          }
          this.changingSrc_ = false;
        }, true);
        return false;
      };
      _proto.load = function load() {
        this.techCall_("load");
      };
      _proto.reset = function reset2() {
        var _this17 = this;
        var PromiseClass = this.options_.Promise || window__default["default"].Promise;
        if (this.paused() || !PromiseClass) {
          this.doReset_();
        } else {
          var playPromise = this.play();
          silencePromise(playPromise.then(function() {
            return _this17.doReset_();
          }));
        }
      };
      _proto.doReset_ = function doReset_() {
        if (this.tech_) {
          this.tech_.clearTracks("text");
        }
        this.resetCache_();
        this.poster("");
        this.loadTech_(this.options_.techOrder[0], null);
        this.techCall_("reset");
        this.resetControlBarUI_();
        if (isEvented(this)) {
          this.trigger("playerreset");
        }
      };
      _proto.resetControlBarUI_ = function resetControlBarUI_() {
        this.resetProgressBar_();
        this.resetPlaybackRate_();
        this.resetVolumeBar_();
      };
      _proto.resetProgressBar_ = function resetProgressBar_() {
        this.currentTime(0);
        var _ref3 = this.controlBar || {}, durationDisplay = _ref3.durationDisplay, remainingTimeDisplay = _ref3.remainingTimeDisplay;
        if (durationDisplay) {
          durationDisplay.updateContent();
        }
        if (remainingTimeDisplay) {
          remainingTimeDisplay.updateContent();
        }
      };
      _proto.resetPlaybackRate_ = function resetPlaybackRate_() {
        this.playbackRate(this.defaultPlaybackRate());
        this.handleTechRateChange_();
      };
      _proto.resetVolumeBar_ = function resetVolumeBar_() {
        this.volume(1);
        this.trigger("volumechange");
      };
      _proto.currentSources = function currentSources() {
        var source = this.currentSource();
        var sources = [];
        if (Object.keys(source).length !== 0) {
          sources.push(source);
        }
        return this.cache_.sources || sources;
      };
      _proto.currentSource = function currentSource() {
        return this.cache_.source || {};
      };
      _proto.currentSrc = function currentSrc() {
        return this.currentSource() && this.currentSource().src || "";
      };
      _proto.currentType = function currentType() {
        return this.currentSource() && this.currentSource().type || "";
      };
      _proto.preload = function preload(value) {
        if (value !== void 0) {
          this.techCall_("setPreload", value);
          this.options_.preload = value;
          return;
        }
        return this.techGet_("preload");
      };
      _proto.autoplay = function autoplay(value) {
        if (value === void 0) {
          return this.options_.autoplay || false;
        }
        var techAutoplay;
        if (typeof value === "string" && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
          this.options_.autoplay = value;
          this.manualAutoplay_(typeof value === "string" ? value : "play");
          techAutoplay = false;
        } else if (!value) {
          this.options_.autoplay = false;
        } else {
          this.options_.autoplay = true;
        }
        techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
        if (this.tech_) {
          this.techCall_("setAutoplay", techAutoplay);
        }
      };
      _proto.playsinline = function playsinline(value) {
        if (value !== void 0) {
          this.techCall_("setPlaysinline", value);
          this.options_.playsinline = value;
          return this;
        }
        return this.techGet_("playsinline");
      };
      _proto.loop = function loop(value) {
        if (value !== void 0) {
          this.techCall_("setLoop", value);
          this.options_.loop = value;
          return;
        }
        return this.techGet_("loop");
      };
      _proto.poster = function poster(src) {
        if (src === void 0) {
          return this.poster_;
        }
        if (!src) {
          src = "";
        }
        if (src === this.poster_) {
          return;
        }
        this.poster_ = src;
        this.techCall_("setPoster", src);
        this.isPosterFromTech_ = false;
        this.trigger("posterchange");
      };
      _proto.handleTechPosterChange_ = function handleTechPosterChange_() {
        if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
          var newPoster = this.tech_.poster() || "";
          if (newPoster !== this.poster_) {
            this.poster_ = newPoster;
            this.isPosterFromTech_ = true;
            this.trigger("posterchange");
          }
        }
      };
      _proto.controls = function controls(bool) {
        if (bool === void 0) {
          return !!this.controls_;
        }
        bool = !!bool;
        if (this.controls_ === bool) {
          return;
        }
        this.controls_ = bool;
        if (this.usingNativeControls()) {
          this.techCall_("setControls", bool);
        }
        if (this.controls_) {
          this.removeClass("vjs-controls-disabled");
          this.addClass("vjs-controls-enabled");
          this.trigger("controlsenabled");
          if (!this.usingNativeControls()) {
            this.addTechControlsListeners_();
          }
        } else {
          this.removeClass("vjs-controls-enabled");
          this.addClass("vjs-controls-disabled");
          this.trigger("controlsdisabled");
          if (!this.usingNativeControls()) {
            this.removeTechControlsListeners_();
          }
        }
      };
      _proto.usingNativeControls = function usingNativeControls(bool) {
        if (bool === void 0) {
          return !!this.usingNativeControls_;
        }
        bool = !!bool;
        if (this.usingNativeControls_ === bool) {
          return;
        }
        this.usingNativeControls_ = bool;
        if (this.usingNativeControls_) {
          this.addClass("vjs-using-native-controls");
          this.trigger("usingnativecontrols");
        } else {
          this.removeClass("vjs-using-native-controls");
          this.trigger("usingcustomcontrols");
        }
      };
      _proto.error = function error(err) {
        var _this18 = this;
        if (err === void 0) {
          return this.error_ || null;
        }
        hooks("beforeerror").forEach(function(hookFunction) {
          var newErr = hookFunction(_this18, err);
          if (!(isObject(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
            _this18.log.error("please return a value that MediaError expects in beforeerror hooks");
            return;
          }
          err = newErr;
        });
        if (this.options_.suppressNotSupportedError && err && err.code === 4) {
          var triggerSuppressedError = function triggerSuppressedError2() {
            this.error(err);
          };
          this.options_.suppressNotSupportedError = false;
          this.any(["click", "touchstart"], triggerSuppressedError);
          this.one("loadstart", function() {
            this.off(["click", "touchstart"], triggerSuppressedError);
          });
          return;
        }
        if (err === null) {
          this.error_ = err;
          this.removeClass("vjs-error");
          if (this.errorDisplay) {
            this.errorDisplay.close();
          }
          return;
        }
        this.error_ = new MediaError(err);
        this.addClass("vjs-error");
        log$1.error("(CODE:" + this.error_.code + " " + MediaError.errorTypes[this.error_.code] + ")", this.error_.message, this.error_);
        this.trigger("error");
        hooks("error").forEach(function(hookFunction) {
          return hookFunction(_this18, _this18.error_);
        });
        return;
      };
      _proto.reportUserActivity = function reportUserActivity(event2) {
        this.userActivity_ = true;
      };
      _proto.userActive = function userActive(bool) {
        if (bool === void 0) {
          return this.userActive_;
        }
        bool = !!bool;
        if (bool === this.userActive_) {
          return;
        }
        this.userActive_ = bool;
        if (this.userActive_) {
          this.userActivity_ = true;
          this.removeClass("vjs-user-inactive");
          this.addClass("vjs-user-active");
          this.trigger("useractive");
          return;
        }
        if (this.tech_) {
          this.tech_.one("mousemove", function(e) {
            e.stopPropagation();
            e.preventDefault();
          });
        }
        this.userActivity_ = false;
        this.removeClass("vjs-user-active");
        this.addClass("vjs-user-inactive");
        this.trigger("userinactive");
      };
      _proto.listenForUserActivity_ = function listenForUserActivity_() {
        var mouseInProgress;
        var lastMoveX;
        var lastMoveY;
        var handleActivity = bind(this, this.reportUserActivity);
        var handleMouseMove = function handleMouseMove2(e) {
          if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
            lastMoveX = e.screenX;
            lastMoveY = e.screenY;
            handleActivity();
          }
        };
        var handleMouseDown = function handleMouseDown2() {
          handleActivity();
          this.clearInterval(mouseInProgress);
          mouseInProgress = this.setInterval(handleActivity, 250);
        };
        var handleMouseUpAndMouseLeave = function handleMouseUpAndMouseLeave2(event2) {
          handleActivity();
          this.clearInterval(mouseInProgress);
        };
        this.on("mousedown", handleMouseDown);
        this.on("mousemove", handleMouseMove);
        this.on("mouseup", handleMouseUpAndMouseLeave);
        this.on("mouseleave", handleMouseUpAndMouseLeave);
        var controlBar = this.getChild("controlBar");
        if (controlBar && !IS_IOS && !IS_ANDROID) {
          controlBar.on("mouseenter", function(event2) {
            if (this.player().options_.inactivityTimeout !== 0) {
              this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
            }
            this.player().options_.inactivityTimeout = 0;
          });
          controlBar.on("mouseleave", function(event2) {
            this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
          });
        }
        this.on("keydown", handleActivity);
        this.on("keyup", handleActivity);
        var inactivityTimeout;
        this.setInterval(function() {
          if (!this.userActivity_) {
            return;
          }
          this.userActivity_ = false;
          this.userActive(true);
          this.clearTimeout(inactivityTimeout);
          var timeout = this.options_.inactivityTimeout;
          if (timeout <= 0) {
            return;
          }
          inactivityTimeout = this.setTimeout(function() {
            if (!this.userActivity_) {
              this.userActive(false);
            }
          }, timeout);
        }, 250);
      };
      _proto.playbackRate = function playbackRate(rate) {
        if (rate !== void 0) {
          this.techCall_("setPlaybackRate", rate);
          return;
        }
        if (this.tech_ && this.tech_.featuresPlaybackRate) {
          return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
        }
        return 1;
      };
      _proto.defaultPlaybackRate = function defaultPlaybackRate(rate) {
        if (rate !== void 0) {
          return this.techCall_("setDefaultPlaybackRate", rate);
        }
        if (this.tech_ && this.tech_.featuresPlaybackRate) {
          return this.techGet_("defaultPlaybackRate");
        }
        return 1;
      };
      _proto.isAudio = function isAudio(bool) {
        if (bool !== void 0) {
          this.isAudio_ = !!bool;
          return;
        }
        return !!this.isAudio_;
      };
      _proto.enableAudioOnlyUI_ = function enableAudioOnlyUI_() {
        var _this19 = this;
        this.addClass("vjs-audio-only-mode");
        var playerChildren = this.children();
        var controlBar = this.getChild("ControlBar");
        var controlBarHeight = controlBar && controlBar.currentHeight();
        playerChildren.forEach(function(child) {
          if (child === controlBar) {
            return;
          }
          if (child.el_ && !child.hasClass("vjs-hidden")) {
            child.hide();
            _this19.audioOnlyCache_.hiddenChildren.push(child);
          }
        });
        this.audioOnlyCache_.playerHeight = this.currentHeight();
        this.height(controlBarHeight);
        this.trigger("audioonlymodechange");
      };
      _proto.disableAudioOnlyUI_ = function disableAudioOnlyUI_() {
        this.removeClass("vjs-audio-only-mode");
        this.audioOnlyCache_.hiddenChildren.forEach(function(child) {
          return child.show();
        });
        this.height(this.audioOnlyCache_.playerHeight);
        this.trigger("audioonlymodechange");
      };
      _proto.audioOnlyMode = function audioOnlyMode(value) {
        var _this20 = this;
        if (typeof value !== "boolean" || value === this.audioOnlyMode_) {
          return this.audioOnlyMode_;
        }
        this.audioOnlyMode_ = value;
        var PromiseClass = this.options_.Promise || window__default["default"].Promise;
        if (PromiseClass) {
          if (value) {
            var exitPromises = [];
            if (this.isInPictureInPicture()) {
              exitPromises.push(this.exitPictureInPicture());
            }
            if (this.isFullscreen()) {
              exitPromises.push(this.exitFullscreen());
            }
            if (this.audioPosterMode()) {
              exitPromises.push(this.audioPosterMode(false));
            }
            return PromiseClass.all(exitPromises).then(function() {
              return _this20.enableAudioOnlyUI_();
            });
          }
          return PromiseClass.resolve().then(function() {
            return _this20.disableAudioOnlyUI_();
          });
        }
        if (value) {
          if (this.isInPictureInPicture()) {
            this.exitPictureInPicture();
          }
          if (this.isFullscreen()) {
            this.exitFullscreen();
          }
          this.enableAudioOnlyUI_();
        } else {
          this.disableAudioOnlyUI_();
        }
      };
      _proto.enablePosterModeUI_ = function enablePosterModeUI_() {
        var tech = this.tech_ && this.tech_;
        tech.hide();
        this.addClass("vjs-audio-poster-mode");
        this.trigger("audiopostermodechange");
      };
      _proto.disablePosterModeUI_ = function disablePosterModeUI_() {
        var tech = this.tech_ && this.tech_;
        tech.show();
        this.removeClass("vjs-audio-poster-mode");
        this.trigger("audiopostermodechange");
      };
      _proto.audioPosterMode = function audioPosterMode(value) {
        var _this21 = this;
        if (typeof value !== "boolean" || value === this.audioPosterMode_) {
          return this.audioPosterMode_;
        }
        this.audioPosterMode_ = value;
        var PromiseClass = this.options_.Promise || window__default["default"].Promise;
        if (PromiseClass) {
          if (value) {
            if (this.audioOnlyMode()) {
              var audioOnlyModePromise = this.audioOnlyMode(false);
              return audioOnlyModePromise.then(function() {
                _this21.enablePosterModeUI_();
              });
            }
            return PromiseClass.resolve().then(function() {
              _this21.enablePosterModeUI_();
            });
          }
          return PromiseClass.resolve().then(function() {
            _this21.disablePosterModeUI_();
          });
        }
        if (value) {
          if (this.audioOnlyMode()) {
            this.audioOnlyMode(false);
          }
          this.enablePosterModeUI_();
          return;
        }
        this.disablePosterModeUI_();
      };
      _proto.addTextTrack = function addTextTrack(kind, label, language) {
        if (this.tech_) {
          return this.tech_.addTextTrack(kind, label, language);
        }
      };
      _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
        if (this.tech_) {
          return this.tech_.addRemoteTextTrack(options, manualCleanup);
        }
      };
      _proto.removeRemoteTextTrack = function removeRemoteTextTrack(obj2) {
        if (obj2 === void 0) {
          obj2 = {};
        }
        var _obj = obj2, track = _obj.track;
        if (!track) {
          track = obj2;
        }
        if (this.tech_) {
          return this.tech_.removeRemoteTextTrack(track);
        }
      };
      _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
        return this.techGet_("getVideoPlaybackQuality");
      };
      _proto.videoWidth = function videoWidth() {
        return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
      };
      _proto.videoHeight = function videoHeight() {
        return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
      };
      _proto.language = function language(code) {
        if (code === void 0) {
          return this.language_;
        }
        if (this.language_ !== String(code).toLowerCase()) {
          this.language_ = String(code).toLowerCase();
          if (isEvented(this)) {
            this.trigger("languagechange");
          }
        }
      };
      _proto.languages = function languages() {
        return mergeOptions$3(Player2.prototype.options_.languages, this.languages_);
      };
      _proto.toJSON = function toJSON() {
        var options = mergeOptions$3(this.options_);
        var tracks = options.tracks;
        options.tracks = [];
        for (var i2 = 0; i2 < tracks.length; i2++) {
          var track = tracks[i2];
          track = mergeOptions$3(track);
          track.player = void 0;
          options.tracks[i2] = track;
        }
        return options;
      };
      _proto.createModal = function createModal(content, options) {
        var _this22 = this;
        options = options || {};
        options.content = content || "";
        var modal = new ModalDialog(this, options);
        this.addChild(modal);
        modal.on("dispose", function() {
          _this22.removeChild(modal);
        });
        modal.open();
        return modal;
      };
      _proto.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {
        if (!this.responsive()) {
          return;
        }
        var currentBreakpoint = this.currentBreakpoint();
        var currentWidth = this.currentWidth();
        for (var i2 = 0; i2 < BREAKPOINT_ORDER.length; i2++) {
          var candidateBreakpoint = BREAKPOINT_ORDER[i2];
          var maxWidth = this.breakpoints_[candidateBreakpoint];
          if (currentWidth <= maxWidth) {
            if (currentBreakpoint === candidateBreakpoint) {
              return;
            }
            if (currentBreakpoint) {
              this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
            }
            this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
            this.breakpoint_ = candidateBreakpoint;
            break;
          }
        }
      };
      _proto.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {
        var className = this.currentBreakpointClass();
        this.breakpoint_ = "";
        if (className) {
          this.removeClass(className);
        }
      };
      _proto.breakpoints = function breakpoints(_breakpoints) {
        if (_breakpoints === void 0) {
          return assign(this.breakpoints_);
        }
        this.breakpoint_ = "";
        this.breakpoints_ = assign({}, DEFAULT_BREAKPOINTS, _breakpoints);
        this.updateCurrentBreakpoint_();
        return assign(this.breakpoints_);
      };
      _proto.responsive = function responsive(value) {
        if (value === void 0) {
          return this.responsive_;
        }
        value = Boolean(value);
        var current = this.responsive_;
        if (value === current) {
          return;
        }
        this.responsive_ = value;
        if (value) {
          this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
          this.updateCurrentBreakpoint_();
        } else {
          this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
          this.removeCurrentBreakpoint_();
        }
        return value;
      };
      _proto.currentBreakpoint = function currentBreakpoint() {
        return this.breakpoint_;
      };
      _proto.currentBreakpointClass = function currentBreakpointClass() {
        return BREAKPOINT_CLASSES[this.breakpoint_] || "";
      };
      _proto.loadMedia = function loadMedia(media, ready) {
        var _this23 = this;
        if (!media || typeof media !== "object") {
          return;
        }
        this.reset();
        this.cache_.media = mergeOptions$3(media);
        var _this$cache_$media = this.cache_.media, artwork = _this$cache_$media.artwork, poster = _this$cache_$media.poster, src = _this$cache_$media.src, textTracks = _this$cache_$media.textTracks;
        if (!artwork && poster) {
          this.cache_.media.artwork = [{
            src: poster,
            type: getMimetype(poster)
          }];
        }
        if (src) {
          this.src(src);
        }
        if (poster) {
          this.poster(poster);
        }
        if (Array.isArray(textTracks)) {
          textTracks.forEach(function(tt) {
            return _this23.addRemoteTextTrack(tt, false);
          });
        }
        this.ready(ready);
      };
      _proto.getMedia = function getMedia() {
        if (!this.cache_.media) {
          var poster = this.poster();
          var src = this.currentSources();
          var textTracks = Array.prototype.map.call(this.remoteTextTracks(), function(tt) {
            return {
              kind: tt.kind,
              label: tt.label,
              language: tt.language,
              src: tt.src
            };
          });
          var media = {
            src,
            textTracks
          };
          if (poster) {
            media.poster = poster;
            media.artwork = [{
              src: media.poster,
              type: getMimetype(media.poster)
            }];
          }
          return media;
        }
        return mergeOptions$3(this.cache_.media);
      };
      Player2.getTagSettings = function getTagSettings(tag) {
        var baseOptions = {
          sources: [],
          tracks: []
        };
        var tagOptions = getAttributes(tag);
        var dataSetup = tagOptions["data-setup"];
        if (hasClass(tag, "vjs-fill")) {
          tagOptions.fill = true;
        }
        if (hasClass(tag, "vjs-fluid")) {
          tagOptions.fluid = true;
        }
        if (dataSetup !== null) {
          var _safeParseTuple = safeParseTuple__default["default"](dataSetup || "{}"), err = _safeParseTuple[0], data = _safeParseTuple[1];
          if (err) {
            log$1.error(err);
          }
          assign(tagOptions, data);
        }
        assign(baseOptions, tagOptions);
        if (tag.hasChildNodes()) {
          var children = tag.childNodes;
          for (var i2 = 0, j = children.length; i2 < j; i2++) {
            var child = children[i2];
            var childName = child.nodeName.toLowerCase();
            if (childName === "source") {
              baseOptions.sources.push(getAttributes(child));
            } else if (childName === "track") {
              baseOptions.tracks.push(getAttributes(child));
            }
          }
        }
        return baseOptions;
      };
      _proto.flexNotSupported_ = function flexNotSupported_() {
        var elem = document__default["default"].createElement("i");
        return !("flexBasis" in elem.style || "webkitFlexBasis" in elem.style || "mozFlexBasis" in elem.style || "msFlexBasis" in elem.style || "msFlexOrder" in elem.style);
      };
      _proto.debug = function debug(enabled) {
        if (enabled === void 0) {
          return this.debugEnabled_;
        }
        if (enabled) {
          this.trigger("debugon");
          this.previousLogLevel_ = this.log.level;
          this.log.level("debug");
          this.debugEnabled_ = true;
        } else {
          this.trigger("debugoff");
          this.log.level(this.previousLogLevel_);
          this.previousLogLevel_ = void 0;
          this.debugEnabled_ = false;
        }
      };
      _proto.playbackRates = function playbackRates(newRates) {
        if (newRates === void 0) {
          return this.cache_.playbackRates;
        }
        if (!Array.isArray(newRates)) {
          return;
        }
        if (!newRates.every(function(rate) {
          return typeof rate === "number";
        })) {
          return;
        }
        this.cache_.playbackRates = newRates;
        this.trigger("playbackrateschange");
      };
      return Player2;
    }(Component$1);
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      Player.prototype[props.getterName] = function() {
        if (this.tech_) {
          return this.tech_[props.getterName]();
        }
        this[props.privateName] = this[props.privateName] || new props.ListClass();
        return this[props.privateName];
      };
    });
    Player.prototype.crossorigin = Player.prototype.crossOrigin;
    Player.players = {};
    var navigator = window__default["default"].navigator;
    Player.prototype.options_ = {
      techOrder: Tech.defaultTechOrder_,
      html5: {},
      inactivityTimeout: 2e3,
      playbackRates: [],
      liveui: false,
      children: ["mediaLoader", "posterImage", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
      language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || "en",
      languages: {},
      notSupportedMessage: "No compatible source was found for this media.",
      normalizeAutoplay: false,
      fullscreen: {
        options: {
          navigationUI: "hide"
        }
      },
      breakpoints: {},
      responsive: false,
      audioOnlyMode: false,
      audioPosterMode: false
    };
    [
      "ended",
      "seeking",
      "seekable",
      "networkState",
      "readyState"
    ].forEach(function(fn) {
      Player.prototype[fn] = function() {
        return this.techGet_(fn);
      };
    });
    TECH_EVENTS_RETRIGGER.forEach(function(event2) {
      Player.prototype["handleTech" + toTitleCase$1(event2) + "_"] = function() {
        return this.trigger(event2);
      };
    });
    Component$1.registerComponent("Player", Player);
    var BASE_PLUGIN_NAME = "plugin";
    var PLUGIN_CACHE_KEY = "activePlugins_";
    var pluginStorage = {};
    var pluginExists = function pluginExists2(name) {
      return pluginStorage.hasOwnProperty(name);
    };
    var getPlugin = function getPlugin2(name) {
      return pluginExists(name) ? pluginStorage[name] : void 0;
    };
    var markPluginAsActive = function markPluginAsActive2(player, name) {
      player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
      player[PLUGIN_CACHE_KEY][name] = true;
    };
    var triggerSetupEvent = function triggerSetupEvent2(player, hash, before) {
      var eventName = (before ? "before" : "") + "pluginsetup";
      player.trigger(eventName, hash);
      player.trigger(eventName + ":" + hash.name, hash);
    };
    var createBasicPlugin = function createBasicPlugin2(name, plugin) {
      var basicPluginWrapper = function basicPluginWrapper2() {
        triggerSetupEvent(this, {
          name,
          plugin,
          instance: null
        }, true);
        var instance = plugin.apply(this, arguments);
        markPluginAsActive(this, name);
        triggerSetupEvent(this, {
          name,
          plugin,
          instance
        });
        return instance;
      };
      Object.keys(plugin).forEach(function(prop) {
        basicPluginWrapper[prop] = plugin[prop];
      });
      return basicPluginWrapper;
    };
    var createPluginFactory = function createPluginFactory2(name, PluginSubClass) {
      PluginSubClass.prototype.name = name;
      return function() {
        triggerSetupEvent(this, {
          name,
          plugin: PluginSubClass,
          instance: null
        }, true);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var instance = _construct__default["default"](PluginSubClass, [this].concat(args));
        this[name] = function() {
          return instance;
        };
        triggerSetupEvent(this, instance.getEventHash());
        return instance;
      };
    };
    var Plugin = /* @__PURE__ */ function() {
      function Plugin2(player) {
        if (this.constructor === Plugin2) {
          throw new Error("Plugin must be sub-classed; not directly instantiated.");
        }
        this.player = player;
        if (!this.log) {
          this.log = this.player.log.createLogger(this.name);
        }
        evented(this);
        delete this.trigger;
        stateful(this, this.constructor.defaultState);
        markPluginAsActive(player, this.name);
        this.dispose = this.dispose.bind(this);
        player.on("dispose", this.dispose);
      }
      var _proto = Plugin2.prototype;
      _proto.version = function version3() {
        return this.constructor.VERSION;
      };
      _proto.getEventHash = function getEventHash(hash) {
        if (hash === void 0) {
          hash = {};
        }
        hash.name = this.name;
        hash.plugin = this.constructor;
        hash.instance = this;
        return hash;
      };
      _proto.trigger = function trigger$1(event2, hash) {
        if (hash === void 0) {
          hash = {};
        }
        return trigger(this.eventBusEl_, event2, this.getEventHash(hash));
      };
      _proto.handleStateChanged = function handleStateChanged(e) {
      };
      _proto.dispose = function dispose() {
        var name = this.name, player = this.player;
        this.trigger("dispose");
        this.off();
        player.off("dispose", this.dispose);
        player[PLUGIN_CACHE_KEY][name] = false;
        this.player = this.state = null;
        player[name] = createPluginFactory(name, pluginStorage[name]);
      };
      Plugin2.isBasic = function isBasic(plugin) {
        var p = typeof plugin === "string" ? getPlugin(plugin) : plugin;
        return typeof p === "function" && !Plugin2.prototype.isPrototypeOf(p.prototype);
      };
      Plugin2.registerPlugin = function registerPlugin2(name, plugin) {
        if (typeof name !== "string") {
          throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + typeof name + ".");
        }
        if (pluginExists(name)) {
          log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
        } else if (Player.prototype.hasOwnProperty(name)) {
          throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
        }
        if (typeof plugin !== "function") {
          throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + typeof plugin + ".");
        }
        pluginStorage[name] = plugin;
        if (name !== BASE_PLUGIN_NAME) {
          if (Plugin2.isBasic(plugin)) {
            Player.prototype[name] = createBasicPlugin(name, plugin);
          } else {
            Player.prototype[name] = createPluginFactory(name, plugin);
          }
        }
        return plugin;
      };
      Plugin2.deregisterPlugin = function deregisterPlugin(name) {
        if (name === BASE_PLUGIN_NAME) {
          throw new Error("Cannot de-register base plugin.");
        }
        if (pluginExists(name)) {
          delete pluginStorage[name];
          delete Player.prototype[name];
        }
      };
      Plugin2.getPlugins = function getPlugins(names) {
        if (names === void 0) {
          names = Object.keys(pluginStorage);
        }
        var result;
        names.forEach(function(name) {
          var plugin = getPlugin(name);
          if (plugin) {
            result = result || {};
            result[name] = plugin;
          }
        });
        return result;
      };
      Plugin2.getPluginVersion = function getPluginVersion(name) {
        var plugin = getPlugin(name);
        return plugin && plugin.VERSION || "";
      };
      return Plugin2;
    }();
    Plugin.getPlugin = getPlugin;
    Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
    Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
    Player.prototype.usingPlugin = function(name) {
      return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
    };
    Player.prototype.hasPlugin = function(name) {
      return !!pluginExists(name);
    };
    var hasLogged = false;
    var extend = function extend2(superClass, subClassMethods) {
      if (subClassMethods === void 0) {
        subClassMethods = {};
      }
      if (!hasLogged) {
        log$1.warn("videojs.extend is deprecated as of Video.js 7.22.0 and will be removed in Video.js 8.0.0");
        hasLogged = true;
      }
      var subClass = function subClass2() {
        superClass.apply(this, arguments);
      };
      var methods = {};
      if (typeof subClassMethods === "object") {
        if (subClassMethods.constructor !== Object.prototype.constructor) {
          subClass = subClassMethods.constructor;
        }
        methods = subClassMethods;
      } else if (typeof subClassMethods === "function") {
        subClass = subClassMethods;
      }
      _inherits__default["default"](subClass, superClass);
      if (superClass) {
        subClass.super_ = superClass;
      }
      for (var name in methods) {
        if (methods.hasOwnProperty(name)) {
          subClass.prototype[name] = methods[name];
        }
      }
      return subClass;
    };
    var normalizeId = function normalizeId2(id) {
      return id.indexOf("#") === 0 ? id.slice(1) : id;
    };
    function videojs3(id, options, ready) {
      var player = videojs3.getPlayer(id);
      if (player) {
        if (options) {
          log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.');
        }
        if (ready) {
          player.ready(ready);
        }
        return player;
      }
      var el = typeof id === "string" ? $("#" + normalizeId(id)) : id;
      if (!isEl(el)) {
        throw new TypeError("The element or ID supplied is not valid. (videojs)");
      }
      if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {
        log$1.warn("The element supplied is not included in the DOM");
      }
      options = options || {};
      if (options.restoreEl === true) {
        options.restoreEl = (el.parentNode && el.parentNode.hasAttribute("data-vjs-player") ? el.parentNode : el).cloneNode(true);
      }
      hooks("beforesetup").forEach(function(hookFunction) {
        var opts = hookFunction(el, mergeOptions$3(options));
        if (!isObject(opts) || Array.isArray(opts)) {
          log$1.error("please return an object in beforesetup hooks");
          return;
        }
        options = mergeOptions$3(options, opts);
      });
      var PlayerComponent = Component$1.getComponent("Player");
      player = new PlayerComponent(el, options, ready);
      hooks("setup").forEach(function(hookFunction) {
        return hookFunction(player);
      });
      return player;
    }
    videojs3.hooks_ = hooks_;
    videojs3.hooks = hooks;
    videojs3.hook = hook;
    videojs3.hookOnce = hookOnce;
    videojs3.removeHook = removeHook;
    if (window__default["default"].VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
      style = $(".vjs-styles-defaults");
      if (!style) {
        style = createStyleElement("vjs-styles-defaults");
        head = $("head");
        if (head) {
          head.insertBefore(style, head.firstChild);
        }
        setTextContent(style, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    ");
      }
    }
    var style;
    var head;
    autoSetupTimeout(1, videojs3);
    videojs3.VERSION = version$5;
    videojs3.options = Player.prototype.options_;
    videojs3.getPlayers = function() {
      return Player.players;
    };
    videojs3.getPlayer = function(id) {
      var players = Player.players;
      var tag;
      if (typeof id === "string") {
        var nId = normalizeId(id);
        var player = players[nId];
        if (player) {
          return player;
        }
        tag = $("#" + nId);
      } else {
        tag = id;
      }
      if (isEl(tag)) {
        var _tag = tag, _player = _tag.player, playerId = _tag.playerId;
        if (_player || players[playerId]) {
          return _player || players[playerId];
        }
      }
    };
    videojs3.getAllPlayers = function() {
      return Object.keys(Player.players).map(function(k) {
        return Player.players[k];
      }).filter(Boolean);
    };
    videojs3.players = Player.players;
    videojs3.getComponent = Component$1.getComponent;
    videojs3.registerComponent = function(name, comp) {
      if (Tech.isTech(comp)) {
        log$1.warn("The " + name + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)");
      }
      Component$1.registerComponent.call(Component$1, name, comp);
    };
    videojs3.getTech = Tech.getTech;
    videojs3.registerTech = Tech.registerTech;
    videojs3.use = use;
    Object.defineProperty(videojs3, "middleware", {
      value: {},
      writeable: false,
      enumerable: true
    });
    Object.defineProperty(videojs3.middleware, "TERMINATOR", {
      value: TERMINATOR,
      writeable: false,
      enumerable: true
    });
    videojs3.browser = browser;
    videojs3.TOUCH_ENABLED = TOUCH_ENABLED;
    videojs3.extend = extend;
    videojs3.mergeOptions = mergeOptions$3;
    videojs3.bind = bind;
    videojs3.registerPlugin = Plugin.registerPlugin;
    videojs3.deregisterPlugin = Plugin.deregisterPlugin;
    videojs3.plugin = function(name, plugin) {
      log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
      return Plugin.registerPlugin(name, plugin);
    };
    videojs3.getPlugins = Plugin.getPlugins;
    videojs3.getPlugin = Plugin.getPlugin;
    videojs3.getPluginVersion = Plugin.getPluginVersion;
    videojs3.addLanguage = function(code, data) {
      var _mergeOptions;
      code = ("" + code).toLowerCase();
      videojs3.options.languages = mergeOptions$3(videojs3.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));
      return videojs3.options.languages[code];
    };
    videojs3.log = log$1;
    videojs3.createLogger = createLogger;
    videojs3.createTimeRange = videojs3.createTimeRanges = createTimeRanges;
    videojs3.formatTime = formatTime;
    videojs3.setFormatTime = setFormatTime;
    videojs3.resetFormatTime = resetFormatTime;
    videojs3.parseUrl = parseUrl;
    videojs3.isCrossOrigin = isCrossOrigin;
    videojs3.EventTarget = EventTarget$2;
    videojs3.on = on;
    videojs3.one = one;
    videojs3.off = off;
    videojs3.trigger = trigger;
    videojs3.xhr = XHR__default["default"];
    videojs3.TextTrack = TextTrack;
    videojs3.AudioTrack = AudioTrack;
    videojs3.VideoTrack = VideoTrack;
    ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(function(k) {
      videojs3[k] = function() {
        log$1.warn("videojs." + k + "() is deprecated; use videojs.dom." + k + "() instead");
        return Dom[k].apply(null, arguments);
      };
    });
    videojs3.computedStyle = computedStyle;
    videojs3.dom = Dom;
    videojs3.url = Url;
    videojs3.defineLazyProperty = defineLazyProperty;
    videojs3.addLanguage("en", {
      "Non-Fullscreen": "Exit Fullscreen"
    });
    var resolveUrl = _resolveUrl__default["default"];
    var resolveManifestRedirect = function resolveManifestRedirect2(handleManifestRedirect, url, req) {
      if (handleManifestRedirect && req && req.responseURL && url !== req.responseURL) {
        return req.responseURL;
      }
      return url;
    };
    var logger = function logger2(source) {
      if (videojs3.log.debug) {
        return videojs3.log.debug.bind(videojs3, "VHS:", source + " >");
      }
      return function() {
      };
    };
    var TIME_FUDGE_FACTOR = 1 / 30;
    var SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
    var filterRanges = function filterRanges2(timeRanges, predicate) {
      var results = [];
      var i2;
      if (timeRanges && timeRanges.length) {
        for (i2 = 0; i2 < timeRanges.length; i2++) {
          if (predicate(timeRanges.start(i2), timeRanges.end(i2))) {
            results.push([timeRanges.start(i2), timeRanges.end(i2)]);
          }
        }
      }
      return videojs3.createTimeRanges(results);
    };
    var findRange = function findRange2(buffered, time) {
      return filterRanges(buffered, function(start2, end2) {
        return start2 - SAFE_TIME_DELTA <= time && end2 + SAFE_TIME_DELTA >= time;
      });
    };
    var findNextRange = function findNextRange2(timeRanges, time) {
      return filterRanges(timeRanges, function(start2) {
        return start2 - TIME_FUDGE_FACTOR >= time;
      });
    };
    var findGaps = function findGaps2(buffered) {
      if (buffered.length < 2) {
        return videojs3.createTimeRanges();
      }
      var ranges = [];
      for (var i2 = 1; i2 < buffered.length; i2++) {
        var start2 = buffered.end(i2 - 1);
        var end2 = buffered.start(i2);
        ranges.push([start2, end2]);
      }
      return videojs3.createTimeRanges(ranges);
    };
    var bufferIntersection = function bufferIntersection2(bufferA, bufferB) {
      var start2 = null;
      var end2 = null;
      var arity = 0;
      var extents = [];
      var ranges = [];
      if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {
        return videojs3.createTimeRange();
      }
      var count = bufferA.length;
      while (count--) {
        extents.push({
          time: bufferA.start(count),
          type: "start"
        });
        extents.push({
          time: bufferA.end(count),
          type: "end"
        });
      }
      count = bufferB.length;
      while (count--) {
        extents.push({
          time: bufferB.start(count),
          type: "start"
        });
        extents.push({
          time: bufferB.end(count),
          type: "end"
        });
      }
      extents.sort(function(a, b) {
        return a.time - b.time;
      });
      for (count = 0; count < extents.length; count++) {
        if (extents[count].type === "start") {
          arity++;
          if (arity === 2) {
            start2 = extents[count].time;
          }
        } else if (extents[count].type === "end") {
          arity--;
          if (arity === 1) {
            end2 = extents[count].time;
          }
        }
        if (start2 !== null && end2 !== null) {
          ranges.push([start2, end2]);
          start2 = null;
          end2 = null;
        }
      }
      return videojs3.createTimeRanges(ranges);
    };
    var printableRange = function printableRange2(range) {
      var strArr = [];
      if (!range || !range.length) {
        return "";
      }
      for (var i2 = 0; i2 < range.length; i2++) {
        strArr.push(range.start(i2) + " => " + range.end(i2));
      }
      return strArr.join(", ");
    };
    var timeUntilRebuffer = function timeUntilRebuffer2(buffered, currentTime, playbackRate) {
      if (playbackRate === void 0) {
        playbackRate = 1;
      }
      var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
      return (bufferedEnd - currentTime) / playbackRate;
    };
    var timeRangesToArray = function timeRangesToArray2(timeRanges) {
      var timeRangesList = [];
      for (var i2 = 0; i2 < timeRanges.length; i2++) {
        timeRangesList.push({
          start: timeRanges.start(i2),
          end: timeRanges.end(i2)
        });
      }
      return timeRangesList;
    };
    var isRangeDifferent = function isRangeDifferent2(a, b) {
      if (a === b) {
        return false;
      }
      if (!a && b || !b && a) {
        return true;
      }
      if (a.length !== b.length) {
        return true;
      }
      for (var i2 = 0; i2 < a.length; i2++) {
        if (a.start(i2) !== b.start(i2) || a.end(i2) !== b.end(i2)) {
          return true;
        }
      }
      return false;
    };
    var lastBufferedEnd = function lastBufferedEnd2(a) {
      if (!a || !a.length || !a.end) {
        return;
      }
      return a.end(a.length - 1);
    };
    var timeAheadOf = function timeAheadOf2(range, startTime) {
      var time = 0;
      if (!range || !range.length) {
        return time;
      }
      for (var i2 = 0; i2 < range.length; i2++) {
        var start2 = range.start(i2);
        var end2 = range.end(i2);
        if (startTime > end2) {
          continue;
        }
        if (startTime > start2 && startTime <= end2) {
          time += end2 - startTime;
          continue;
        }
        time += end2 - start2;
      }
      return time;
    };
    var createTimeRange = videojs3.createTimeRange;
    var segmentDurationWithParts = function segmentDurationWithParts2(playlist, segment) {
      if (!segment.preload) {
        return segment.duration;
      }
      var result = 0;
      (segment.parts || []).forEach(function(p) {
        result += p.duration;
      });
      (segment.preloadHints || []).forEach(function(p) {
        if (p.type === "PART") {
          result += playlist.partTargetDuration;
        }
      });
      return result;
    };
    var getPartsAndSegments = function getPartsAndSegments2(playlist) {
      return (playlist.segments || []).reduce(function(acc, segment, si) {
        if (segment.parts) {
          segment.parts.forEach(function(part, pi) {
            acc.push({
              duration: part.duration,
              segmentIndex: si,
              partIndex: pi,
              part,
              segment
            });
          });
        } else {
          acc.push({
            duration: segment.duration,
            segmentIndex: si,
            partIndex: null,
            segment,
            part: null
          });
        }
        return acc;
      }, []);
    };
    var getLastParts = function getLastParts2(media) {
      var lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
      return lastSegment && lastSegment.parts || [];
    };
    var getKnownPartCount = function getKnownPartCount2(_ref) {
      var preloadSegment = _ref.preloadSegment;
      if (!preloadSegment) {
        return;
      }
      var parts = preloadSegment.parts, preloadHints = preloadSegment.preloadHints;
      var partCount = (preloadHints || []).reduce(function(count, hint) {
        return count + (hint.type === "PART" ? 1 : 0);
      }, 0);
      partCount += parts && parts.length ? parts.length : 0;
      return partCount;
    };
    var liveEdgeDelay = function liveEdgeDelay2(master, media) {
      if (media.endList) {
        return 0;
      }
      if (master && master.suggestedPresentationDelay) {
        return master.suggestedPresentationDelay;
      }
      var hasParts = getLastParts(media).length > 0;
      if (hasParts && media.serverControl && media.serverControl.partHoldBack) {
        return media.serverControl.partHoldBack;
      } else if (hasParts && media.partTargetDuration) {
        return media.partTargetDuration * 3;
      } else if (media.serverControl && media.serverControl.holdBack) {
        return media.serverControl.holdBack;
      } else if (media.targetDuration) {
        return media.targetDuration * 3;
      }
      return 0;
    };
    var backwardDuration = function backwardDuration2(playlist, endSequence) {
      var result = 0;
      var i2 = endSequence - playlist.mediaSequence;
      var segment = playlist.segments[i2];
      if (segment) {
        if (typeof segment.start !== "undefined") {
          return {
            result: segment.start,
            precise: true
          };
        }
        if (typeof segment.end !== "undefined") {
          return {
            result: segment.end - segment.duration,
            precise: true
          };
        }
      }
      while (i2--) {
        segment = playlist.segments[i2];
        if (typeof segment.end !== "undefined") {
          return {
            result: result + segment.end,
            precise: true
          };
        }
        result += segmentDurationWithParts(playlist, segment);
        if (typeof segment.start !== "undefined") {
          return {
            result: result + segment.start,
            precise: true
          };
        }
      }
      return {
        result,
        precise: false
      };
    };
    var forwardDuration = function forwardDuration2(playlist, endSequence) {
      var result = 0;
      var segment;
      var i2 = endSequence - playlist.mediaSequence;
      for (; i2 < playlist.segments.length; i2++) {
        segment = playlist.segments[i2];
        if (typeof segment.start !== "undefined") {
          return {
            result: segment.start - result,
            precise: true
          };
        }
        result += segmentDurationWithParts(playlist, segment);
        if (typeof segment.end !== "undefined") {
          return {
            result: segment.end - result,
            precise: true
          };
        }
      }
      return {
        result: -1,
        precise: false
      };
    };
    var intervalDuration = function intervalDuration2(playlist, endSequence, expired) {
      if (typeof endSequence === "undefined") {
        endSequence = playlist.mediaSequence + playlist.segments.length;
      }
      if (endSequence < playlist.mediaSequence) {
        return 0;
      }
      var backward = backwardDuration(playlist, endSequence);
      if (backward.precise) {
        return backward.result;
      }
      var forward = forwardDuration(playlist, endSequence);
      if (forward.precise) {
        return forward.result;
      }
      return backward.result + expired;
    };
    var duration = function duration2(playlist, endSequence, expired) {
      if (!playlist) {
        return 0;
      }
      if (typeof expired !== "number") {
        expired = 0;
      }
      if (typeof endSequence === "undefined") {
        if (playlist.totalDuration) {
          return playlist.totalDuration;
        }
        if (!playlist.endList) {
          return window__default["default"].Infinity;
        }
      }
      return intervalDuration(playlist, endSequence, expired);
    };
    var sumDurations = function sumDurations2(_ref2) {
      var defaultDuration = _ref2.defaultDuration, durationList = _ref2.durationList, startIndex = _ref2.startIndex, endIndex = _ref2.endIndex;
      var durations = 0;
      if (startIndex > endIndex) {
        var _ref3 = [endIndex, startIndex];
        startIndex = _ref3[0];
        endIndex = _ref3[1];
      }
      if (startIndex < 0) {
        for (var i2 = startIndex; i2 < Math.min(0, endIndex); i2++) {
          durations += defaultDuration;
        }
        startIndex = 0;
      }
      for (var _i2 = startIndex; _i2 < endIndex; _i2++) {
        durations += durationList[_i2].duration;
      }
      return durations;
    };
    var playlistEnd = function playlistEnd2(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
      if (!playlist || !playlist.segments) {
        return null;
      }
      if (playlist.endList) {
        return duration(playlist);
      }
      if (expired === null) {
        return null;
      }
      expired = expired || 0;
      var lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
      if (useSafeLiveEnd) {
        liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : liveEdgeDelay(null, playlist);
        lastSegmentEndTime -= liveEdgePadding;
      }
      return Math.max(0, lastSegmentEndTime);
    };
    var seekable = function seekable2(playlist, expired, liveEdgePadding) {
      var useSafeLiveEnd = true;
      var seekableStart = expired || 0;
      var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
      if (seekableEnd === null) {
        return createTimeRange();
      }
      return createTimeRange(seekableStart, seekableEnd);
    };
    var getMediaInfoForTime = function getMediaInfoForTime2(_ref4) {
      var playlist = _ref4.playlist, currentTime = _ref4.currentTime, startingSegmentIndex = _ref4.startingSegmentIndex, startingPartIndex = _ref4.startingPartIndex, startTime = _ref4.startTime, experimentalExactManifestTimings = _ref4.experimentalExactManifestTimings;
      var time = currentTime - startTime;
      var partsAndSegments = getPartsAndSegments(playlist);
      var startIndex = 0;
      for (var i2 = 0; i2 < partsAndSegments.length; i2++) {
        var partAndSegment = partsAndSegments[i2];
        if (startingSegmentIndex !== partAndSegment.segmentIndex) {
          continue;
        }
        if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) {
          continue;
        }
        startIndex = i2;
        break;
      }
      if (time < 0) {
        if (startIndex > 0) {
          for (var _i2 = startIndex - 1; _i2 >= 0; _i2--) {
            var _partAndSegment = partsAndSegments[_i2];
            time += _partAndSegment.duration;
            if (experimentalExactManifestTimings) {
              if (time < 0) {
                continue;
              }
            } else if (time + TIME_FUDGE_FACTOR <= 0) {
              continue;
            }
            return {
              partIndex: _partAndSegment.partIndex,
              segmentIndex: _partAndSegment.segmentIndex,
              startTime: startTime - sumDurations({
                defaultDuration: playlist.targetDuration,
                durationList: partsAndSegments,
                startIndex,
                endIndex: _i2
              })
            };
          }
        }
        return {
          partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
          segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
          startTime: currentTime
        };
      }
      if (startIndex < 0) {
        for (var _i3 = startIndex; _i3 < 0; _i3++) {
          time -= playlist.targetDuration;
          if (time < 0) {
            return {
              partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
              segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
              startTime: currentTime
            };
          }
        }
        startIndex = 0;
      }
      for (var _i4 = startIndex; _i4 < partsAndSegments.length; _i4++) {
        var _partAndSegment2 = partsAndSegments[_i4];
        time -= _partAndSegment2.duration;
        if (experimentalExactManifestTimings) {
          if (time > 0) {
            continue;
          }
        } else if (time - TIME_FUDGE_FACTOR >= 0) {
          continue;
        }
        return {
          partIndex: _partAndSegment2.partIndex,
          segmentIndex: _partAndSegment2.segmentIndex,
          startTime: startTime + sumDurations({
            defaultDuration: playlist.targetDuration,
            durationList: partsAndSegments,
            startIndex,
            endIndex: _i4
          })
        };
      }
      return {
        segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
        partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
        startTime: currentTime
      };
    };
    var isBlacklisted = function isBlacklisted2(playlist) {
      return playlist.excludeUntil && playlist.excludeUntil > Date.now();
    };
    var isIncompatible = function isIncompatible2(playlist) {
      return playlist.excludeUntil && playlist.excludeUntil === Infinity;
    };
    var isEnabled = function isEnabled2(playlist) {
      var blacklisted = isBlacklisted(playlist);
      return !playlist.disabled && !blacklisted;
    };
    var isDisabled = function isDisabled2(playlist) {
      return playlist.disabled;
    };
    var isAes = function isAes2(media) {
      for (var i2 = 0; i2 < media.segments.length; i2++) {
        if (media.segments[i2].key) {
          return true;
        }
      }
      return false;
    };
    var hasAttribute = function hasAttribute2(attr, playlist) {
      return playlist.attributes && playlist.attributes[attr];
    };
    var estimateSegmentRequestTime = function estimateSegmentRequestTime2(segmentDuration, bandwidth, playlist, bytesReceived) {
      if (bytesReceived === void 0) {
        bytesReceived = 0;
      }
      if (!hasAttribute("BANDWIDTH", playlist)) {
        return NaN;
      }
      var size = segmentDuration * playlist.attributes.BANDWIDTH;
      return (size - bytesReceived * 8) / bandwidth;
    };
    var isLowestEnabledRendition = function isLowestEnabledRendition2(master, media) {
      if (master.playlists.length === 1) {
        return true;
      }
      var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
      return master.playlists.filter(function(playlist) {
        if (!isEnabled(playlist)) {
          return false;
        }
        return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
      }).length === 0;
    };
    var playlistMatch = function playlistMatch2(a, b) {
      if (!a && !b || !a && b || a && !b) {
        return false;
      }
      if (a === b) {
        return true;
      }
      if (a.id && b.id && a.id === b.id) {
        return true;
      }
      if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {
        return true;
      }
      if (a.uri && b.uri && a.uri === b.uri) {
        return true;
      }
      return false;
    };
    var someAudioVariant = function someAudioVariant2(master, callback) {
      var AUDIO = master && master.mediaGroups && master.mediaGroups.AUDIO || {};
      var found = false;
      for (var groupName in AUDIO) {
        for (var label in AUDIO[groupName]) {
          found = callback(AUDIO[groupName][label]);
          if (found) {
            break;
          }
        }
        if (found) {
          break;
        }
      }
      return !!found;
    };
    var isAudioOnly = function isAudioOnly2(master) {
      if (!master || !master.playlists || !master.playlists.length) {
        var found = someAudioVariant(master, function(variant) {
          return variant.playlists && variant.playlists.length || variant.uri;
        });
        return found;
      }
      var _loop = function _loop2(i3) {
        var playlist = master.playlists[i3];
        var CODECS = playlist.attributes && playlist.attributes.CODECS;
        if (CODECS && CODECS.split(",").every(function(c) {
          return codecs_js.isAudioCodec(c);
        })) {
          return "continue";
        }
        var found2 = someAudioVariant(master, function(variant) {
          return playlistMatch(playlist, variant);
        });
        if (found2) {
          return "continue";
        }
        return {
          v: false
        };
      };
      for (var i2 = 0; i2 < master.playlists.length; i2++) {
        var _ret = _loop(i2);
        if (_ret === "continue")
          continue;
        if (typeof _ret === "object")
          return _ret.v;
      }
      return true;
    };
    var Playlist = {
      liveEdgeDelay,
      duration,
      seekable,
      getMediaInfoForTime,
      isEnabled,
      isDisabled,
      isBlacklisted,
      isIncompatible,
      playlistEnd,
      isAes,
      hasAttribute,
      estimateSegmentRequestTime,
      isLowestEnabledRendition,
      isAudioOnly,
      playlistMatch,
      segmentDurationWithParts
    };
    var log2 = videojs3.log;
    var createPlaylistID = function createPlaylistID2(index, uri) {
      return index + "-" + uri;
    };
    var groupID = function groupID2(type, group, label) {
      return "placeholder-uri-" + type + "-" + group + "-" + label;
    };
    var parseManifest = function parseManifest2(_ref) {
      var onwarn = _ref.onwarn, oninfo = _ref.oninfo, manifestString = _ref.manifestString, _ref$customTagParsers = _ref.customTagParsers, customTagParsers = _ref$customTagParsers === void 0 ? [] : _ref$customTagParsers, _ref$customTagMappers = _ref.customTagMappers, customTagMappers = _ref$customTagMappers === void 0 ? [] : _ref$customTagMappers, experimentalLLHLS = _ref.experimentalLLHLS;
      var parser = new m3u8Parser.Parser();
      if (onwarn) {
        parser.on("warn", onwarn);
      }
      if (oninfo) {
        parser.on("info", oninfo);
      }
      customTagParsers.forEach(function(customParser) {
        return parser.addParser(customParser);
      });
      customTagMappers.forEach(function(mapper) {
        return parser.addTagMapper(mapper);
      });
      parser.push(manifestString);
      parser.end();
      var manifest = parser.manifest;
      if (!experimentalLLHLS) {
        ["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(k) {
          if (manifest.hasOwnProperty(k)) {
            delete manifest[k];
          }
        });
        if (manifest.segments) {
          manifest.segments.forEach(function(segment) {
            ["parts", "preloadHints"].forEach(function(k) {
              if (segment.hasOwnProperty(k)) {
                delete segment[k];
              }
            });
          });
        }
      }
      if (!manifest.targetDuration) {
        var targetDuration = 10;
        if (manifest.segments && manifest.segments.length) {
          targetDuration = manifest.segments.reduce(function(acc, s) {
            return Math.max(acc, s.duration);
          }, 0);
        }
        if (onwarn) {
          onwarn("manifest has no targetDuration defaulting to " + targetDuration);
        }
        manifest.targetDuration = targetDuration;
      }
      var parts = getLastParts(manifest);
      if (parts.length && !manifest.partTargetDuration) {
        var partTargetDuration = parts.reduce(function(acc, p) {
          return Math.max(acc, p.duration);
        }, 0);
        if (onwarn) {
          onwarn("manifest has no partTargetDuration defaulting to " + partTargetDuration);
          log2.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
        }
        manifest.partTargetDuration = partTargetDuration;
      }
      return manifest;
    };
    var forEachMediaGroup = function forEachMediaGroup2(master, callback) {
      if (!master.mediaGroups) {
        return;
      }
      ["AUDIO", "SUBTITLES"].forEach(function(mediaType) {
        if (!master.mediaGroups[mediaType]) {
          return;
        }
        for (var groupKey in master.mediaGroups[mediaType]) {
          for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
            var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
            callback(mediaProperties, mediaType, groupKey, labelKey);
          }
        }
      });
    };
    var setupMediaPlaylist = function setupMediaPlaylist2(_ref2) {
      var playlist = _ref2.playlist, uri = _ref2.uri, id = _ref2.id;
      playlist.id = id;
      playlist.playlistErrors_ = 0;
      if (uri) {
        playlist.uri = uri;
      }
      playlist.attributes = playlist.attributes || {};
    };
    var setupMediaPlaylists = function setupMediaPlaylists2(master) {
      var i2 = master.playlists.length;
      while (i2--) {
        var playlist = master.playlists[i2];
        setupMediaPlaylist({
          playlist,
          id: createPlaylistID(i2, playlist.uri)
        });
        playlist.resolvedUri = resolveUrl(master.uri, playlist.uri);
        master.playlists[playlist.id] = playlist;
        master.playlists[playlist.uri] = playlist;
        if (!playlist.attributes.BANDWIDTH) {
          log2.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
        }
      }
    };
    var resolveMediaGroupUris = function resolveMediaGroupUris2(master) {
      forEachMediaGroup(master, function(properties) {
        if (properties.uri) {
          properties.resolvedUri = resolveUrl(master.uri, properties.uri);
        }
      });
    };
    var masterForMedia = function masterForMedia2(media, uri) {
      var id = createPlaylistID(0, uri);
      var master = {
        mediaGroups: {
          "AUDIO": {},
          "VIDEO": {},
          "CLOSED-CAPTIONS": {},
          "SUBTITLES": {}
        },
        uri: window__default["default"].location.href,
        resolvedUri: window__default["default"].location.href,
        playlists: [{
          uri,
          id,
          resolvedUri: uri,
          attributes: {}
        }]
      };
      master.playlists[id] = master.playlists[0];
      master.playlists[uri] = master.playlists[0];
      return master;
    };
    var addPropertiesToMaster = function addPropertiesToMaster2(master, uri, createGroupID) {
      if (createGroupID === void 0) {
        createGroupID = groupID;
      }
      master.uri = uri;
      for (var i2 = 0; i2 < master.playlists.length; i2++) {
        if (!master.playlists[i2].uri) {
          var phonyUri = "placeholder-uri-" + i2;
          master.playlists[i2].uri = phonyUri;
        }
      }
      var audioOnlyMaster = isAudioOnly(master);
      forEachMediaGroup(master, function(properties, mediaType, groupKey, labelKey) {
        if (!properties.playlists || !properties.playlists.length) {
          if (audioOnlyMaster && mediaType === "AUDIO" && !properties.uri) {
            for (var _i2 = 0; _i2 < master.playlists.length; _i2++) {
              var p = master.playlists[_i2];
              if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {
                return;
              }
            }
          }
          properties.playlists = [_extends__default["default"]({}, properties)];
        }
        properties.playlists.forEach(function(p2, i3) {
          var groupId = createGroupID(mediaType, groupKey, labelKey, p2);
          var id = createPlaylistID(i3, groupId);
          if (p2.uri) {
            p2.resolvedUri = p2.resolvedUri || resolveUrl(master.uri, p2.uri);
          } else {
            p2.uri = i3 === 0 ? groupId : id;
            p2.resolvedUri = p2.uri;
          }
          p2.id = p2.id || id;
          p2.attributes = p2.attributes || {};
          master.playlists[p2.id] = p2;
          master.playlists[p2.uri] = p2;
        });
      });
      setupMediaPlaylists(master);
      resolveMediaGroupUris(master);
    };
    var mergeOptions$2 = videojs3.mergeOptions;
    var EventTarget$1 = videojs3.EventTarget;
    var addLLHLSQueryDirectives = function addLLHLSQueryDirectives2(uri, media) {
      if (media.endList || !media.serverControl) {
        return uri;
      }
      var parameters = {};
      if (media.serverControl.canBlockReload) {
        var preloadSegment = media.preloadSegment;
        var nextMSN = media.mediaSequence + media.segments.length;
        if (preloadSegment) {
          var parts = preloadSegment.parts || [];
          var nextPart = getKnownPartCount(media) - 1;
          if (nextPart > -1 && nextPart !== parts.length - 1) {
            parameters._HLS_part = nextPart;
          }
          if (nextPart > -1 || parts.length) {
            nextMSN--;
          }
        }
        parameters._HLS_msn = nextMSN;
      }
      if (media.serverControl && media.serverControl.canSkipUntil) {
        parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
      }
      if (Object.keys(parameters).length) {
        var parsedUri = new window__default["default"].URL(uri);
        ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(name) {
          if (!parameters.hasOwnProperty(name)) {
            return;
          }
          parsedUri.searchParams.set(name, parameters[name]);
        });
        uri = parsedUri.toString();
      }
      return uri;
    };
    var updateSegment = function updateSegment2(a, b) {
      if (!a) {
        return b;
      }
      var result = mergeOptions$2(a, b);
      if (a.preloadHints && !b.preloadHints) {
        delete result.preloadHints;
      }
      if (a.parts && !b.parts) {
        delete result.parts;
      } else if (a.parts && b.parts) {
        for (var i2 = 0; i2 < b.parts.length; i2++) {
          if (a.parts && a.parts[i2]) {
            result.parts[i2] = mergeOptions$2(a.parts[i2], b.parts[i2]);
          }
        }
      }
      if (!a.skipped && b.skipped) {
        result.skipped = false;
      }
      if (a.preload && !b.preload) {
        result.preload = false;
      }
      return result;
    };
    var updateSegments = function updateSegments2(original, update, offset) {
      var oldSegments = original.slice();
      var newSegments = update.slice();
      offset = offset || 0;
      var result = [];
      var currentMap;
      for (var newIndex = 0; newIndex < newSegments.length; newIndex++) {
        var oldSegment = oldSegments[newIndex + offset];
        var newSegment = newSegments[newIndex];
        if (oldSegment) {
          currentMap = oldSegment.map || currentMap;
          result.push(updateSegment(oldSegment, newSegment));
        } else {
          if (currentMap && !newSegment.map) {
            newSegment.map = currentMap;
          }
          result.push(newSegment);
        }
      }
      return result;
    };
    var resolveSegmentUris = function resolveSegmentUris2(segment, baseUri) {
      if (!segment.resolvedUri && segment.uri) {
        segment.resolvedUri = resolveUrl(baseUri, segment.uri);
      }
      if (segment.key && !segment.key.resolvedUri) {
        segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);
      }
      if (segment.map && !segment.map.resolvedUri) {
        segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);
      }
      if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {
        segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri);
      }
      if (segment.parts && segment.parts.length) {
        segment.parts.forEach(function(p) {
          if (p.resolvedUri) {
            return;
          }
          p.resolvedUri = resolveUrl(baseUri, p.uri);
        });
      }
      if (segment.preloadHints && segment.preloadHints.length) {
        segment.preloadHints.forEach(function(p) {
          if (p.resolvedUri) {
            return;
          }
          p.resolvedUri = resolveUrl(baseUri, p.uri);
        });
      }
    };
    var getAllSegments = function getAllSegments2(media) {
      var segments = media.segments || [];
      var preloadSegment = media.preloadSegment;
      if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
        if (preloadSegment.preloadHints) {
          for (var i2 = 0; i2 < preloadSegment.preloadHints.length; i2++) {
            if (preloadSegment.preloadHints[i2].type === "MAP") {
              return segments;
            }
          }
        }
        preloadSegment.duration = media.targetDuration;
        preloadSegment.preload = true;
        segments.push(preloadSegment);
      }
      return segments;
    };
    var isPlaylistUnchanged = function isPlaylistUnchanged2(a, b) {
      return a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
    };
    var updateMaster$1 = function updateMaster2(master, newMedia, unchangedCheck) {
      if (unchangedCheck === void 0) {
        unchangedCheck = isPlaylistUnchanged;
      }
      var result = mergeOptions$2(master, {});
      var oldMedia = result.playlists[newMedia.id];
      if (!oldMedia) {
        return null;
      }
      if (unchangedCheck(oldMedia, newMedia)) {
        return null;
      }
      newMedia.segments = getAllSegments(newMedia);
      var mergedPlaylist = mergeOptions$2(oldMedia, newMedia);
      if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {
        delete mergedPlaylist.preloadSegment;
      }
      if (oldMedia.segments) {
        if (newMedia.skip) {
          newMedia.segments = newMedia.segments || [];
          for (var i2 = 0; i2 < newMedia.skip.skippedSegments; i2++) {
            newMedia.segments.unshift({
              skipped: true
            });
          }
        }
        mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
      }
      mergedPlaylist.segments.forEach(function(segment) {
        resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
      });
      for (var _i2 = 0; _i2 < result.playlists.length; _i2++) {
        if (result.playlists[_i2].id === newMedia.id) {
          result.playlists[_i2] = mergedPlaylist;
        }
      }
      result.playlists[newMedia.id] = mergedPlaylist;
      result.playlists[newMedia.uri] = mergedPlaylist;
      forEachMediaGroup(master, function(properties, mediaType, groupKey, labelKey) {
        if (!properties.playlists) {
          return;
        }
        for (var _i22 = 0; _i22 < properties.playlists.length; _i22++) {
          if (newMedia.id === properties.playlists[_i22].id) {
            properties.playlists[_i22] = mergedPlaylist;
          }
        }
      });
      return result;
    };
    var refreshDelay = function refreshDelay2(media, update) {
      var segments = media.segments || [];
      var lastSegment = segments[segments.length - 1];
      var lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
      var lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
      if (update && lastDuration) {
        return lastDuration * 1e3;
      }
      return (media.partTargetDuration || media.targetDuration || 10) * 500;
    };
    var PlaylistLoader = /* @__PURE__ */ function(_EventTarget) {
      _inheritsLoose__default["default"](PlaylistLoader2, _EventTarget);
      function PlaylistLoader2(src, vhs, options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _EventTarget.call(this) || this;
        if (!src) {
          throw new Error("A non-empty playlist URL or object is required");
        }
        _this.logger_ = logger("PlaylistLoader");
        var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
        _this.src = src;
        _this.vhs_ = vhs;
        _this.withCredentials = withCredentials;
        _this.handleManifestRedirects = handleManifestRedirects;
        var vhsOptions = vhs.options_;
        _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
        _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
        _this.experimentalLLHLS = vhsOptions && vhsOptions.experimentalLLHLS || false;
        if (videojs3.browser.IE_VERSION) {
          _this.experimentalLLHLS = false;
        }
        _this.state = "HAVE_NOTHING";
        _this.handleMediaupdatetimeout_ = _this.handleMediaupdatetimeout_.bind(_assertThisInitialized__default["default"](_this));
        _this.on("mediaupdatetimeout", _this.handleMediaupdatetimeout_);
        return _this;
      }
      var _proto = PlaylistLoader2.prototype;
      _proto.handleMediaupdatetimeout_ = function handleMediaupdatetimeout_() {
        var _this2 = this;
        if (this.state !== "HAVE_METADATA") {
          return;
        }
        var media = this.media();
        var uri = resolveUrl(this.master.uri, media.uri);
        if (this.experimentalLLHLS) {
          uri = addLLHLSQueryDirectives(uri, media);
        }
        this.state = "HAVE_CURRENT_METADATA";
        this.request = this.vhs_.xhr({
          uri,
          withCredentials: this.withCredentials
        }, function(error, req) {
          if (!_this2.request) {
            return;
          }
          if (error) {
            return _this2.playlistRequestError(_this2.request, _this2.media(), "HAVE_METADATA");
          }
          _this2.haveMetadata({
            playlistString: _this2.request.responseText,
            url: _this2.media().uri,
            id: _this2.media().id
          });
        });
      };
      _proto.playlistRequestError = function playlistRequestError(xhr, playlist, startingState) {
        var uri = playlist.uri, id = playlist.id;
        this.request = null;
        if (startingState) {
          this.state = startingState;
        }
        this.error = {
          playlist: this.master.playlists[id],
          status: xhr.status,
          message: "HLS playlist request error at URL: " + uri + ".",
          responseText: xhr.responseText,
          code: xhr.status >= 500 ? 4 : 2
        };
        this.trigger("error");
      };
      _proto.parseManifest_ = function parseManifest_(_ref) {
        var _this3 = this;
        var url = _ref.url, manifestString = _ref.manifestString;
        return parseManifest({
          onwarn: function onwarn(_ref2) {
            var message = _ref2.message;
            return _this3.logger_("m3u8-parser warn for " + url + ": " + message);
          },
          oninfo: function oninfo(_ref3) {
            var message = _ref3.message;
            return _this3.logger_("m3u8-parser info for " + url + ": " + message);
          },
          manifestString,
          customTagParsers: this.customTagParsers,
          customTagMappers: this.customTagMappers,
          experimentalLLHLS: this.experimentalLLHLS
        });
      };
      _proto.haveMetadata = function haveMetadata(_ref4) {
        var playlistString = _ref4.playlistString, playlistObject = _ref4.playlistObject, url = _ref4.url, id = _ref4.id;
        this.request = null;
        this.state = "HAVE_METADATA";
        var playlist = playlistObject || this.parseManifest_({
          url,
          manifestString: playlistString
        });
        playlist.lastRequest = Date.now();
        setupMediaPlaylist({
          playlist,
          uri: url,
          id
        });
        var update = updateMaster$1(this.master, playlist);
        this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
        this.pendingMedia_ = null;
        if (update) {
          this.master = update;
          this.media_ = this.master.playlists[id];
        } else {
          this.trigger("playlistunchanged");
        }
        this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));
        this.trigger("loadedplaylist");
      };
      _proto.dispose = function dispose() {
        this.trigger("dispose");
        this.stopRequest();
        window__default["default"].clearTimeout(this.mediaUpdateTimeout);
        window__default["default"].clearTimeout(this.finalRenditionTimeout);
        this.off();
      };
      _proto.stopRequest = function stopRequest() {
        if (this.request) {
          var oldRequest = this.request;
          this.request = null;
          oldRequest.onreadystatechange = null;
          oldRequest.abort();
        }
      };
      _proto.media = function media(playlist, shouldDelay) {
        var _this4 = this;
        if (!playlist) {
          return this.media_;
        }
        if (this.state === "HAVE_NOTHING") {
          throw new Error("Cannot switch media playlist from " + this.state);
        }
        if (typeof playlist === "string") {
          if (!this.master.playlists[playlist]) {
            throw new Error("Unknown playlist URI: " + playlist);
          }
          playlist = this.master.playlists[playlist];
        }
        window__default["default"].clearTimeout(this.finalRenditionTimeout);
        if (shouldDelay) {
          var delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
          this.finalRenditionTimeout = window__default["default"].setTimeout(this.media.bind(this, playlist, false), delay);
          return;
        }
        var startingState = this.state;
        var mediaChange = !this.media_ || playlist.id !== this.media_.id;
        var masterPlaylistRef = this.master.playlists[playlist.id];
        if (masterPlaylistRef && masterPlaylistRef.endList || playlist.endList && playlist.segments.length) {
          if (this.request) {
            this.request.onreadystatechange = null;
            this.request.abort();
            this.request = null;
          }
          this.state = "HAVE_METADATA";
          this.media_ = playlist;
          if (mediaChange) {
            this.trigger("mediachanging");
            if (startingState === "HAVE_MASTER") {
              this.trigger("loadedmetadata");
            } else {
              this.trigger("mediachange");
            }
          }
          return;
        }
        this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
        if (!mediaChange) {
          return;
        }
        this.state = "SWITCHING_MEDIA";
        if (this.request) {
          if (playlist.resolvedUri === this.request.url) {
            return;
          }
          this.request.onreadystatechange = null;
          this.request.abort();
          this.request = null;
        }
        if (this.media_) {
          this.trigger("mediachanging");
        }
        this.pendingMedia_ = playlist;
        this.request = this.vhs_.xhr({
          uri: playlist.resolvedUri,
          withCredentials: this.withCredentials
        }, function(error, req) {
          if (!_this4.request) {
            return;
          }
          playlist.lastRequest = Date.now();
          playlist.resolvedUri = resolveManifestRedirect(_this4.handleManifestRedirects, playlist.resolvedUri, req);
          if (error) {
            return _this4.playlistRequestError(_this4.request, playlist, startingState);
          }
          _this4.haveMetadata({
            playlistString: req.responseText,
            url: playlist.uri,
            id: playlist.id
          });
          if (startingState === "HAVE_MASTER") {
            _this4.trigger("loadedmetadata");
          } else {
            _this4.trigger("mediachange");
          }
        });
      };
      _proto.pause = function pause() {
        if (this.mediaUpdateTimeout) {
          window__default["default"].clearTimeout(this.mediaUpdateTimeout);
          this.mediaUpdateTimeout = null;
        }
        this.stopRequest();
        if (this.state === "HAVE_NOTHING") {
          this.started = false;
        }
        if (this.state === "SWITCHING_MEDIA") {
          if (this.media_) {
            this.state = "HAVE_METADATA";
          } else {
            this.state = "HAVE_MASTER";
          }
        } else if (this.state === "HAVE_CURRENT_METADATA") {
          this.state = "HAVE_METADATA";
        }
      };
      _proto.load = function load(shouldDelay) {
        var _this5 = this;
        if (this.mediaUpdateTimeout) {
          window__default["default"].clearTimeout(this.mediaUpdateTimeout);
          this.mediaUpdateTimeout = null;
        }
        var media = this.media();
        if (shouldDelay) {
          var delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
          this.mediaUpdateTimeout = window__default["default"].setTimeout(function() {
            _this5.mediaUpdateTimeout = null;
            _this5.load();
          }, delay);
          return;
        }
        if (!this.started) {
          this.start();
          return;
        }
        if (media && !media.endList) {
          this.trigger("mediaupdatetimeout");
        } else {
          this.trigger("loadedplaylist");
        }
      };
      _proto.updateMediaUpdateTimeout_ = function updateMediaUpdateTimeout_(delay) {
        var _this6 = this;
        if (this.mediaUpdateTimeout) {
          window__default["default"].clearTimeout(this.mediaUpdateTimeout);
          this.mediaUpdateTimeout = null;
        }
        if (!this.media() || this.media().endList) {
          return;
        }
        this.mediaUpdateTimeout = window__default["default"].setTimeout(function() {
          _this6.mediaUpdateTimeout = null;
          _this6.trigger("mediaupdatetimeout");
          _this6.updateMediaUpdateTimeout_(delay);
        }, delay);
      };
      _proto.start = function start2() {
        var _this7 = this;
        this.started = true;
        if (typeof this.src === "object") {
          if (!this.src.uri) {
            this.src.uri = window__default["default"].location.href;
          }
          this.src.resolvedUri = this.src.uri;
          setTimeout(function() {
            _this7.setupInitialPlaylist(_this7.src);
          }, 0);
          return;
        }
        this.request = this.vhs_.xhr({
          uri: this.src,
          withCredentials: this.withCredentials
        }, function(error, req) {
          if (!_this7.request) {
            return;
          }
          _this7.request = null;
          if (error) {
            _this7.error = {
              status: req.status,
              message: "HLS playlist request error at URL: " + _this7.src + ".",
              responseText: req.responseText,
              code: 2
            };
            if (_this7.state === "HAVE_NOTHING") {
              _this7.started = false;
            }
            return _this7.trigger("error");
          }
          _this7.src = resolveManifestRedirect(_this7.handleManifestRedirects, _this7.src, req);
          var manifest = _this7.parseManifest_({
            manifestString: req.responseText,
            url: _this7.src
          });
          _this7.setupInitialPlaylist(manifest);
        });
      };
      _proto.srcUri = function srcUri() {
        return typeof this.src === "string" ? this.src : this.src.uri;
      };
      _proto.setupInitialPlaylist = function setupInitialPlaylist(manifest) {
        this.state = "HAVE_MASTER";
        if (manifest.playlists) {
          this.master = manifest;
          addPropertiesToMaster(this.master, this.srcUri());
          manifest.playlists.forEach(function(playlist) {
            playlist.segments = getAllSegments(playlist);
            playlist.segments.forEach(function(segment) {
              resolveSegmentUris(segment, playlist.resolvedUri);
            });
          });
          this.trigger("loadedplaylist");
          if (!this.request) {
            this.media(this.master.playlists[0]);
          }
          return;
        }
        var uri = this.srcUri() || window__default["default"].location.href;
        this.master = masterForMedia(manifest, uri);
        this.haveMetadata({
          playlistObject: manifest,
          url: uri,
          id: this.master.playlists[0].id
        });
        this.trigger("loadedmetadata");
      };
      return PlaylistLoader2;
    }(EventTarget$1);
    var videojsXHR = videojs3.xhr;
    var mergeOptions$1 = videojs3.mergeOptions;
    var callbackWrapper = function callbackWrapper2(request, error, response, callback) {
      var reqResponse = request.responseType === "arraybuffer" ? request.response : request.responseText;
      if (!error && reqResponse) {
        request.responseTime = Date.now();
        request.roundTripTime = request.responseTime - request.requestTime;
        request.bytesReceived = reqResponse.byteLength || reqResponse.length;
        if (!request.bandwidth) {
          request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1e3);
        }
      }
      if (response.headers) {
        request.responseHeaders = response.headers;
      }
      if (error && error.code === "ETIMEDOUT") {
        request.timedout = true;
      }
      if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {
        error = new Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)));
      }
      callback(error, request);
    };
    var xhrFactory = function xhrFactory2() {
      var xhr = function XhrFunction(options, callback) {
        options = mergeOptions$1({
          timeout: 45e3
        }, options);
        var beforeRequest = XhrFunction.beforeRequest || videojs3.Vhs.xhr.beforeRequest;
        if (beforeRequest && typeof beforeRequest === "function") {
          var newOptions = beforeRequest(options);
          if (newOptions) {
            options = newOptions;
          }
        }
        var xhrMethod = videojs3.Vhs.xhr.original === true ? videojsXHR : videojs3.Vhs.xhr;
        var request = xhrMethod(options, function(error, response) {
          return callbackWrapper(request, error, response, callback);
        });
        var originalAbort = request.abort;
        request.abort = function() {
          request.aborted = true;
          return originalAbort.apply(request, arguments);
        };
        request.uri = options.uri;
        request.requestTime = Date.now();
        return request;
      };
      xhr.original = true;
      return xhr;
    };
    var byterangeStr = function byterangeStr2(byterange) {
      var byterangeEnd;
      var byterangeStart = byterange.offset;
      if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
        byterangeEnd = window__default["default"].BigInt(byterange.offset) + window__default["default"].BigInt(byterange.length) - window__default["default"].BigInt(1);
      } else {
        byterangeEnd = byterange.offset + byterange.length - 1;
      }
      return "bytes=" + byterangeStart + "-" + byterangeEnd;
    };
    var segmentXhrHeaders = function segmentXhrHeaders2(segment) {
      var headers = {};
      if (segment.byterange) {
        headers.Range = byterangeStr(segment.byterange);
      }
      return headers;
    };
    var textRange = function textRange2(range, i2) {
      return range.start(i2) + "-" + range.end(i2);
    };
    var formatHexString = function formatHexString2(e, i2) {
      var value = e.toString(16);
      return "00".substring(0, 2 - value.length) + value + (i2 % 2 ? " " : "");
    };
    var formatAsciiString = function formatAsciiString2(e) {
      if (e >= 32 && e < 126) {
        return String.fromCharCode(e);
      }
      return ".";
    };
    var createTransferableMessage = function createTransferableMessage2(message) {
      var transferable = {};
      Object.keys(message).forEach(function(key) {
        var value = message[key];
        if (byteHelpers.isArrayBufferView(value)) {
          transferable[key] = {
            bytes: value.buffer,
            byteOffset: value.byteOffset,
            byteLength: value.byteLength
          };
        } else {
          transferable[key] = value;
        }
      });
      return transferable;
    };
    var initSegmentId = function initSegmentId2(initSegment) {
      var byterange = initSegment.byterange || {
        length: Infinity,
        offset: 0
      };
      return [byterange.length, byterange.offset, initSegment.resolvedUri].join(",");
    };
    var segmentKeyId = function segmentKeyId2(key) {
      return key.resolvedUri;
    };
    var hexDump = function hexDump2(data) {
      var bytes = Array.prototype.slice.call(data);
      var step = 16;
      var result = "";
      var hex;
      var ascii;
      for (var j = 0; j < bytes.length / step; j++) {
        hex = bytes.slice(j * step, j * step + step).map(formatHexString).join("");
        ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join("");
        result += hex + " " + ascii + "\n";
      }
      return result;
    };
    var tagDump = function tagDump2(_ref) {
      var bytes = _ref.bytes;
      return hexDump(bytes);
    };
    var textRanges = function textRanges2(ranges) {
      var result = "";
      var i2;
      for (i2 = 0; i2 < ranges.length; i2++) {
        result += textRange(ranges, i2) + " ";
      }
      return result;
    };
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      createTransferableMessage,
      initSegmentId,
      segmentKeyId,
      hexDump,
      tagDump,
      textRanges
    });
    var SEGMENT_END_FUDGE_PERCENT = 0.25;
    var playerTimeToProgramTime = function playerTimeToProgramTime2(playerTime, segment) {
      if (!segment.dateTimeObject) {
        return null;
      }
      var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
      var transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
      var startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
      var offsetFromSegmentStart = playerTime - startOfSegment;
      return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
    };
    var originalSegmentVideoDuration = function originalSegmentVideoDuration2(videoTimingInfo) {
      return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
    };
    var findSegmentForProgramTime = function findSegmentForProgramTime2(programTime, playlist) {
      var dateTimeObject;
      try {
        dateTimeObject = new Date(programTime);
      } catch (e) {
        return null;
      }
      if (!playlist || !playlist.segments || playlist.segments.length === 0) {
        return null;
      }
      var segment = playlist.segments[0];
      if (dateTimeObject < segment.dateTimeObject) {
        return null;
      }
      for (var i2 = 0; i2 < playlist.segments.length - 1; i2++) {
        segment = playlist.segments[i2];
        var nextSegmentStart = playlist.segments[i2 + 1].dateTimeObject;
        if (dateTimeObject < nextSegmentStart) {
          break;
        }
      }
      var lastSegment = playlist.segments[playlist.segments.length - 1];
      var lastSegmentStart = lastSegment.dateTimeObject;
      var lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
      var lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
      if (dateTimeObject > lastSegmentEnd) {
        return null;
      }
      if (dateTimeObject > lastSegmentStart) {
        segment = lastSegment;
      }
      return {
        segment,
        estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
        type: segment.videoTimingInfo ? "accurate" : "estimate"
      };
    };
    var findSegmentForPlayerTime = function findSegmentForPlayerTime2(time, playlist) {
      if (!playlist || !playlist.segments || playlist.segments.length === 0) {
        return null;
      }
      var segmentEnd = 0;
      var segment;
      for (var i2 = 0; i2 < playlist.segments.length; i2++) {
        segment = playlist.segments[i2];
        segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
        if (time <= segmentEnd) {
          break;
        }
      }
      var lastSegment = playlist.segments[playlist.segments.length - 1];
      if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {
        return null;
      }
      if (time > segmentEnd) {
        if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {
          return null;
        }
        segment = lastSegment;
      }
      return {
        segment,
        estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
        type: segment.videoTimingInfo ? "accurate" : "estimate"
      };
    };
    var getOffsetFromTimestamp = function getOffsetFromTimestamp2(comparisonTimeStamp, programTime) {
      var segmentDateTime;
      var programDateTime;
      try {
        segmentDateTime = new Date(comparisonTimeStamp);
        programDateTime = new Date(programTime);
      } catch (e) {
      }
      var segmentTimeEpoch = segmentDateTime.getTime();
      var programTimeEpoch = programDateTime.getTime();
      return (programTimeEpoch - segmentTimeEpoch) / 1e3;
    };
    var verifyProgramDateTimeTags = function verifyProgramDateTimeTags2(playlist) {
      if (!playlist.segments || playlist.segments.length === 0) {
        return false;
      }
      for (var i2 = 0; i2 < playlist.segments.length; i2++) {
        var segment = playlist.segments[i2];
        if (!segment.dateTimeObject) {
          return false;
        }
      }
      return true;
    };
    var getProgramTime = function getProgramTime2(_ref) {
      var playlist = _ref.playlist, _ref$time = _ref.time, time = _ref$time === void 0 ? void 0 : _ref$time, callback = _ref.callback;
      if (!callback) {
        throw new Error("getProgramTime: callback must be provided");
      }
      if (!playlist || time === void 0) {
        return callback({
          message: "getProgramTime: playlist and time must be provided"
        });
      }
      var matchedSegment = findSegmentForPlayerTime(time, playlist);
      if (!matchedSegment) {
        return callback({
          message: "valid programTime was not found"
        });
      }
      if (matchedSegment.type === "estimate") {
        return callback({
          message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
          seekTime: matchedSegment.estimatedStart
        });
      }
      var programTimeObject = {
        mediaSeconds: time
      };
      var programTime = playerTimeToProgramTime(time, matchedSegment.segment);
      if (programTime) {
        programTimeObject.programDateTime = programTime.toISOString();
      }
      return callback(null, programTimeObject);
    };
    var seekToProgramTime = function seekToProgramTime2(_ref2) {
      var programTime = _ref2.programTime, playlist = _ref2.playlist, _ref2$retryCount = _ref2.retryCount, retryCount = _ref2$retryCount === void 0 ? 2 : _ref2$retryCount, seekTo = _ref2.seekTo, _ref2$pauseAfterSeek = _ref2.pauseAfterSeek, pauseAfterSeek = _ref2$pauseAfterSeek === void 0 ? true : _ref2$pauseAfterSeek, tech = _ref2.tech, callback = _ref2.callback;
      if (!callback) {
        throw new Error("seekToProgramTime: callback must be provided");
      }
      if (typeof programTime === "undefined" || !playlist || !seekTo) {
        return callback({
          message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
        });
      }
      if (!playlist.endList && !tech.hasStarted_) {
        return callback({
          message: "player must be playing a live stream to start buffering"
        });
      }
      if (!verifyProgramDateTimeTags(playlist)) {
        return callback({
          message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
        });
      }
      var matchedSegment = findSegmentForProgramTime(programTime, playlist);
      if (!matchedSegment) {
        return callback({
          message: programTime + " was not found in the stream"
        });
      }
      var segment = matchedSegment.segment;
      var mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
      if (matchedSegment.type === "estimate") {
        if (retryCount === 0) {
          return callback({
            message: programTime + " is not buffered yet. Try again"
          });
        }
        seekTo(matchedSegment.estimatedStart + mediaOffset);
        tech.one("seeked", function() {
          seekToProgramTime2({
            programTime,
            playlist,
            retryCount: retryCount - 1,
            seekTo,
            pauseAfterSeek,
            tech,
            callback
          });
        });
        return;
      }
      var seekToTime = segment.start + mediaOffset;
      var seekedCallback = function seekedCallback2() {
        return callback(null, tech.currentTime());
      };
      tech.one("seeked", seekedCallback);
      if (pauseAfterSeek) {
        tech.pause();
      }
      seekTo(seekToTime);
    };
    var callbackOnCompleted = function callbackOnCompleted2(request, cb) {
      if (request.readyState === 4) {
        return cb();
      }
      return;
    };
    var containerRequest = function containerRequest2(uri, xhr, cb) {
      var bytes = [];
      var id3Offset;
      var finished = false;
      var endRequestAndCallback = function endRequestAndCallback2(err, req, type, _bytes) {
        req.abort();
        finished = true;
        return cb(err, req, type, _bytes);
      };
      var progressListener = function progressListener2(error, request2) {
        if (finished) {
          return;
        }
        if (error) {
          return endRequestAndCallback(error, request2, "", bytes);
        }
        var newPart = request2.responseText.substring(bytes && bytes.byteLength || 0, request2.responseText.length);
        bytes = byteHelpers.concatTypedArrays(bytes, byteHelpers.stringToBytes(newPart, true));
        id3Offset = id3Offset || id3Helpers.getId3Offset(bytes);
        if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {
          return callbackOnCompleted(request2, function() {
            return endRequestAndCallback(error, request2, "", bytes);
          });
        }
        var type = containers.detectContainerForBytes(bytes);
        if (type === "ts" && bytes.length < 188) {
          return callbackOnCompleted(request2, function() {
            return endRequestAndCallback(error, request2, "", bytes);
          });
        }
        if (!type && bytes.length < 376) {
          return callbackOnCompleted(request2, function() {
            return endRequestAndCallback(error, request2, "", bytes);
          });
        }
        return endRequestAndCallback(null, request2, type, bytes);
      };
      var options = {
        uri,
        beforeSend: function beforeSend(request2) {
          request2.overrideMimeType("text/plain; charset=x-user-defined");
          request2.addEventListener("progress", function(_ref) {
            _ref.total;
            _ref.loaded;
            return callbackWrapper(request2, null, {
              statusCode: request2.status
            }, progressListener);
          });
        }
      };
      var request = xhr(options, function(error, response) {
        return callbackWrapper(request, error, response, progressListener);
      });
      return request;
    };
    var EventTarget = videojs3.EventTarget;
    var mergeOptions = videojs3.mergeOptions;
    var dashPlaylistUnchanged = function dashPlaylistUnchanged2(a, b) {
      if (!isPlaylistUnchanged(a, b)) {
        return false;
      }
      if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {
        return false;
      } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {
        return false;
      }
      if (a.segments && !b.segments || !a.segments && b.segments) {
        return false;
      }
      if (!a.segments && !b.segments) {
        return true;
      }
      for (var i2 = 0; i2 < a.segments.length; i2++) {
        var aSegment = a.segments[i2];
        var bSegment = b.segments[i2];
        if (aSegment.uri !== bSegment.uri) {
          return false;
        }
        if (!aSegment.byterange && !bSegment.byterange) {
          continue;
        }
        var aByterange = aSegment.byterange;
        var bByterange = bSegment.byterange;
        if (aByterange && !bByterange || !aByterange && bByterange) {
          return false;
        }
        if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {
          return false;
        }
      }
      return true;
    };
    var dashGroupId = function dashGroupId2(type, group, label, playlist) {
      var playlistId = playlist.attributes.NAME || label;
      return "placeholder-uri-" + type + "-" + group + "-" + playlistId;
    };
    var parseMasterXml = function parseMasterXml2(_ref) {
      var masterXml = _ref.masterXml, srcUrl = _ref.srcUrl, clientOffset = _ref.clientOffset, sidxMapping = _ref.sidxMapping, previousManifest = _ref.previousManifest;
      var manifest = mpdParser.parse(masterXml, {
        manifestUri: srcUrl,
        clientOffset,
        sidxMapping,
        previousManifest
      });
      addPropertiesToMaster(manifest, srcUrl, dashGroupId);
      return manifest;
    };
    var removeOldMediaGroupLabels = function removeOldMediaGroupLabels2(update, newMaster) {
      forEachMediaGroup(update, function(properties, type, group, label) {
        if (!(label in newMaster.mediaGroups[type][group])) {
          delete update.mediaGroups[type][group][label];
        }
      });
    };
    var updateMaster = function updateMaster2(oldMaster, newMaster, sidxMapping) {
      var noChanges = true;
      var update = mergeOptions(oldMaster, {
        duration: newMaster.duration,
        minimumUpdatePeriod: newMaster.minimumUpdatePeriod,
        timelineStarts: newMaster.timelineStarts
      });
      for (var i2 = 0; i2 < newMaster.playlists.length; i2++) {
        var playlist = newMaster.playlists[i2];
        if (playlist.sidx) {
          var sidxKey = mpdParser.generateSidxKey(playlist.sidx);
          if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {
            mpdParser.addSidxSegmentsToPlaylist(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
          }
        }
        var playlistUpdate = updateMaster$1(update, playlist, dashPlaylistUnchanged);
        if (playlistUpdate) {
          update = playlistUpdate;
          noChanges = false;
        }
      }
      forEachMediaGroup(newMaster, function(properties, type, group, label) {
        if (properties.playlists && properties.playlists.length) {
          var id = properties.playlists[0].id;
          var _playlistUpdate = updateMaster$1(update, properties.playlists[0], dashPlaylistUnchanged);
          if (_playlistUpdate) {
            update = _playlistUpdate;
            if (!(label in update.mediaGroups[type][group])) {
              update.mediaGroups[type][group][label] = properties;
            }
            update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];
            noChanges = false;
          }
        }
      });
      removeOldMediaGroupLabels(update, newMaster);
      if (newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
        noChanges = false;
      }
      if (noChanges) {
        return null;
      }
      return update;
    };
    var equivalentSidx = function equivalentSidx2(a, b) {
      var neitherMap = Boolean(!a.map && !b.map);
      var equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);
      return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;
    };
    var compareSidxEntry = function compareSidxEntry2(playlists, oldSidxMapping) {
      var newSidxMapping = {};
      for (var id in playlists) {
        var playlist = playlists[id];
        var currentSidxInfo = playlist.sidx;
        if (currentSidxInfo) {
          var key = mpdParser.generateSidxKey(currentSidxInfo);
          if (!oldSidxMapping[key]) {
            break;
          }
          var savedSidxInfo = oldSidxMapping[key].sidxInfo;
          if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {
            newSidxMapping[key] = oldSidxMapping[key];
          }
        }
      }
      return newSidxMapping;
    };
    var filterChangedSidxMappings = function filterChangedSidxMappings2(master, oldSidxMapping) {
      var videoSidx = compareSidxEntry(master.playlists, oldSidxMapping);
      var mediaGroupSidx = videoSidx;
      forEachMediaGroup(master, function(properties, mediaType, groupKey, labelKey) {
        if (properties.playlists && properties.playlists.length) {
          var playlists = properties.playlists;
          mediaGroupSidx = mergeOptions(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
        }
      });
      return mediaGroupSidx;
    };
    var DashPlaylistLoader = /* @__PURE__ */ function(_EventTarget) {
      _inheritsLoose__default["default"](DashPlaylistLoader2, _EventTarget);
      function DashPlaylistLoader2(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _EventTarget.call(this) || this;
        _this.masterPlaylistLoader_ = masterPlaylistLoader || _assertThisInitialized__default["default"](_this);
        if (!masterPlaylistLoader) {
          _this.isMaster_ = true;
        }
        var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
        _this.vhs_ = vhs;
        _this.withCredentials = withCredentials;
        _this.handleManifestRedirects = handleManifestRedirects;
        if (!srcUrlOrPlaylist) {
          throw new Error("A non-empty playlist URL or object is required");
        }
        _this.on("minimumUpdatePeriod", function() {
          _this.refreshXml_();
        });
        _this.on("mediaupdatetimeout", function() {
          _this.refreshMedia_(_this.media().id);
        });
        _this.state = "HAVE_NOTHING";
        _this.loadedPlaylists_ = {};
        _this.logger_ = logger("DashPlaylistLoader");
        if (_this.isMaster_) {
          _this.masterPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
          _this.masterPlaylistLoader_.sidxMapping_ = {};
        } else {
          _this.childPlaylist_ = srcUrlOrPlaylist;
        }
        return _this;
      }
      var _proto = DashPlaylistLoader2.prototype;
      _proto.requestErrored_ = function requestErrored_(err, request, startingState) {
        if (!this.request) {
          return true;
        }
        this.request = null;
        if (err) {
          this.error = typeof err === "object" && !(err instanceof Error) ? err : {
            status: request.status,
            message: "DASH request error at URL: " + request.uri,
            response: request.response,
            code: 2
          };
          if (startingState) {
            this.state = startingState;
          }
          this.trigger("error");
          return true;
        }
      };
      _proto.addSidxSegments_ = function addSidxSegments_(playlist, startingState, cb) {
        var _this2 = this;
        var sidxKey = playlist.sidx && mpdParser.generateSidxKey(playlist.sidx);
        if (!playlist.sidx || !sidxKey || this.masterPlaylistLoader_.sidxMapping_[sidxKey]) {
          this.mediaRequest_ = window__default["default"].setTimeout(function() {
            return cb(false);
          }, 0);
          return;
        }
        var uri = resolveManifestRedirect(this.handleManifestRedirects, playlist.sidx.resolvedUri);
        var fin = function fin2(err, request) {
          if (_this2.requestErrored_(err, request, startingState)) {
            return;
          }
          var sidxMapping = _this2.masterPlaylistLoader_.sidxMapping_;
          var sidx;
          try {
            sidx = parseSidx__default["default"](byteHelpers.toUint8(request.response).subarray(8));
          } catch (e) {
            _this2.requestErrored_(e, request, startingState);
            return;
          }
          sidxMapping[sidxKey] = {
            sidxInfo: playlist.sidx,
            sidx
          };
          mpdParser.addSidxSegmentsToPlaylist(playlist, sidx, playlist.sidx.resolvedUri);
          return cb(true);
        };
        this.request = containerRequest(uri, this.vhs_.xhr, function(err, request, container, bytes) {
          if (err) {
            return fin(err, request);
          }
          if (!container || container !== "mp4") {
            return fin({
              status: request.status,
              message: "Unsupported " + (container || "unknown") + " container type for sidx segment at URL: " + uri,
              response: "",
              playlist,
              internal: true,
              blacklistDuration: Infinity,
              code: 2
            }, request);
          }
          var _playlist$sidx$bytera = playlist.sidx.byterange, offset = _playlist$sidx$bytera.offset, length = _playlist$sidx$bytera.length;
          if (bytes.length >= length + offset) {
            return fin(err, {
              response: bytes.subarray(offset, offset + length),
              status: request.status,
              uri: request.uri
            });
          }
          _this2.request = _this2.vhs_.xhr({
            uri,
            responseType: "arraybuffer",
            headers: segmentXhrHeaders({
              byterange: playlist.sidx.byterange
            })
          }, fin);
        });
      };
      _proto.dispose = function dispose() {
        this.trigger("dispose");
        this.stopRequest();
        this.loadedPlaylists_ = {};
        window__default["default"].clearTimeout(this.minimumUpdatePeriodTimeout_);
        window__default["default"].clearTimeout(this.mediaRequest_);
        window__default["default"].clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
        this.mediaRequest_ = null;
        this.minimumUpdatePeriodTimeout_ = null;
        if (this.masterPlaylistLoader_.createMupOnMedia_) {
          this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
          this.masterPlaylistLoader_.createMupOnMedia_ = null;
        }
        this.off();
      };
      _proto.hasPendingRequest = function hasPendingRequest() {
        return this.request || this.mediaRequest_;
      };
      _proto.stopRequest = function stopRequest() {
        if (this.request) {
          var oldRequest = this.request;
          this.request = null;
          oldRequest.onreadystatechange = null;
          oldRequest.abort();
        }
      };
      _proto.media = function media(playlist) {
        var _this3 = this;
        if (!playlist) {
          return this.media_;
        }
        if (this.state === "HAVE_NOTHING") {
          throw new Error("Cannot switch media playlist from " + this.state);
        }
        var startingState = this.state;
        if (typeof playlist === "string") {
          if (!this.masterPlaylistLoader_.master.playlists[playlist]) {
            throw new Error("Unknown playlist URI: " + playlist);
          }
          playlist = this.masterPlaylistLoader_.master.playlists[playlist];
        }
        var mediaChange = !this.media_ || playlist.id !== this.media_.id;
        if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
          this.state = "HAVE_METADATA";
          this.media_ = playlist;
          if (mediaChange) {
            this.trigger("mediachanging");
            this.trigger("mediachange");
          }
          return;
        }
        if (!mediaChange) {
          return;
        }
        if (this.media_) {
          this.trigger("mediachanging");
        }
        this.addSidxSegments_(playlist, startingState, function(sidxChanged) {
          _this3.haveMetadata({
            startingState,
            playlist
          });
        });
      };
      _proto.haveMetadata = function haveMetadata(_ref2) {
        var startingState = _ref2.startingState, playlist = _ref2.playlist;
        this.state = "HAVE_METADATA";
        this.loadedPlaylists_[playlist.id] = playlist;
        this.mediaRequest_ = null;
        this.refreshMedia_(playlist.id);
        if (startingState === "HAVE_MASTER") {
          this.trigger("loadedmetadata");
        } else {
          this.trigger("mediachange");
        }
      };
      _proto.pause = function pause() {
        if (this.masterPlaylistLoader_.createMupOnMedia_) {
          this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
          this.masterPlaylistLoader_.createMupOnMedia_ = null;
        }
        this.stopRequest();
        window__default["default"].clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
        if (this.isMaster_) {
          window__default["default"].clearTimeout(this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_);
          this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
        }
        if (this.state === "HAVE_NOTHING") {
          this.started = false;
        }
      };
      _proto.load = function load(isFinalRendition) {
        var _this4 = this;
        window__default["default"].clearTimeout(this.mediaUpdateTimeout);
        this.mediaUpdateTimeout = null;
        var media = this.media();
        if (isFinalRendition) {
          var delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
          this.mediaUpdateTimeout = window__default["default"].setTimeout(function() {
            return _this4.load();
          }, delay);
          return;
        }
        if (!this.started) {
          this.start();
          return;
        }
        if (media && !media.endList) {
          if (this.isMaster_ && !this.minimumUpdatePeriodTimeout_) {
            this.trigger("minimumUpdatePeriod");
            this.updateMinimumUpdatePeriodTimeout_();
          }
          this.trigger("mediaupdatetimeout");
        } else {
          this.trigger("loadedplaylist");
        }
      };
      _proto.start = function start2() {
        var _this5 = this;
        this.started = true;
        if (!this.isMaster_) {
          this.mediaRequest_ = window__default["default"].setTimeout(function() {
            return _this5.haveMaster_();
          }, 0);
          return;
        }
        this.requestMaster_(function(req, masterChanged) {
          _this5.haveMaster_();
          if (!_this5.hasPendingRequest() && !_this5.media_) {
            _this5.media(_this5.masterPlaylistLoader_.master.playlists[0]);
          }
        });
      };
      _proto.requestMaster_ = function requestMaster_(cb) {
        var _this6 = this;
        this.request = this.vhs_.xhr({
          uri: this.masterPlaylistLoader_.srcUrl,
          withCredentials: this.withCredentials
        }, function(error, req) {
          if (_this6.requestErrored_(error, req)) {
            if (_this6.state === "HAVE_NOTHING") {
              _this6.started = false;
            }
            return;
          }
          var masterChanged = req.responseText !== _this6.masterPlaylistLoader_.masterXml_;
          _this6.masterPlaylistLoader_.masterXml_ = req.responseText;
          if (req.responseHeaders && req.responseHeaders.date) {
            _this6.masterLoaded_ = Date.parse(req.responseHeaders.date);
          } else {
            _this6.masterLoaded_ = Date.now();
          }
          _this6.masterPlaylistLoader_.srcUrl = resolveManifestRedirect(_this6.handleManifestRedirects, _this6.masterPlaylistLoader_.srcUrl, req);
          if (masterChanged) {
            _this6.handleMaster_();
            _this6.syncClientServerClock_(function() {
              return cb(req, masterChanged);
            });
            return;
          }
          return cb(req, masterChanged);
        });
      };
      _proto.syncClientServerClock_ = function syncClientServerClock_(done) {
        var _this7 = this;
        var utcTiming = mpdParser.parseUTCTiming(this.masterPlaylistLoader_.masterXml_);
        if (utcTiming === null) {
          this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now();
          return done();
        }
        if (utcTiming.method === "DIRECT") {
          this.masterPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
          return done();
        }
        this.request = this.vhs_.xhr({
          uri: resolveUrl(this.masterPlaylistLoader_.srcUrl, utcTiming.value),
          method: utcTiming.method,
          withCredentials: this.withCredentials
        }, function(error, req) {
          if (!_this7.request) {
            return;
          }
          if (error) {
            _this7.masterPlaylistLoader_.clientOffset_ = _this7.masterLoaded_ - Date.now();
            return done();
          }
          var serverTime;
          if (utcTiming.method === "HEAD") {
            if (!req.responseHeaders || !req.responseHeaders.date) {
              serverTime = _this7.masterLoaded_;
            } else {
              serverTime = Date.parse(req.responseHeaders.date);
            }
          } else {
            serverTime = Date.parse(req.responseText);
          }
          _this7.masterPlaylistLoader_.clientOffset_ = serverTime - Date.now();
          done();
        });
      };
      _proto.haveMaster_ = function haveMaster_() {
        this.state = "HAVE_MASTER";
        if (this.isMaster_) {
          this.trigger("loadedplaylist");
        } else if (!this.media_) {
          this.media(this.childPlaylist_);
        }
      };
      _proto.handleMaster_ = function handleMaster_() {
        this.mediaRequest_ = null;
        var oldMaster = this.masterPlaylistLoader_.master;
        var newMaster = parseMasterXml({
          masterXml: this.masterPlaylistLoader_.masterXml_,
          srcUrl: this.masterPlaylistLoader_.srcUrl,
          clientOffset: this.masterPlaylistLoader_.clientOffset_,
          sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
          previousManifest: oldMaster
        });
        if (oldMaster) {
          newMaster = updateMaster(oldMaster, newMaster, this.masterPlaylistLoader_.sidxMapping_);
        }
        this.masterPlaylistLoader_.master = newMaster ? newMaster : oldMaster;
        var location2 = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
        if (location2 && location2 !== this.masterPlaylistLoader_.srcUrl) {
          this.masterPlaylistLoader_.srcUrl = location2;
        }
        if (!oldMaster || newMaster && newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
          this.updateMinimumUpdatePeriodTimeout_();
        }
        return Boolean(newMaster);
      };
      _proto.updateMinimumUpdatePeriodTimeout_ = function updateMinimumUpdatePeriodTimeout_() {
        var mpl = this.masterPlaylistLoader_;
        if (mpl.createMupOnMedia_) {
          mpl.off("loadedmetadata", mpl.createMupOnMedia_);
          mpl.createMupOnMedia_ = null;
        }
        if (mpl.minimumUpdatePeriodTimeout_) {
          window__default["default"].clearTimeout(mpl.minimumUpdatePeriodTimeout_);
          mpl.minimumUpdatePeriodTimeout_ = null;
        }
        var mup = mpl.master && mpl.master.minimumUpdatePeriod;
        if (mup === 0) {
          if (mpl.media()) {
            mup = mpl.media().targetDuration * 1e3;
          } else {
            mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
            mpl.one("loadedmetadata", mpl.createMupOnMedia_);
          }
        }
        if (typeof mup !== "number" || mup <= 0) {
          if (mup < 0) {
            this.logger_("found invalid minimumUpdatePeriod of " + mup + ", not setting a timeout");
          }
          return;
        }
        this.createMUPTimeout_(mup);
      };
      _proto.createMUPTimeout_ = function createMUPTimeout_(mup) {
        var mpl = this.masterPlaylistLoader_;
        mpl.minimumUpdatePeriodTimeout_ = window__default["default"].setTimeout(function() {
          mpl.minimumUpdatePeriodTimeout_ = null;
          mpl.trigger("minimumUpdatePeriod");
          mpl.createMUPTimeout_(mup);
        }, mup);
      };
      _proto.refreshXml_ = function refreshXml_() {
        var _this8 = this;
        this.requestMaster_(function(req, masterChanged) {
          if (!masterChanged) {
            return;
          }
          if (_this8.media_) {
            _this8.media_ = _this8.masterPlaylistLoader_.master.playlists[_this8.media_.id];
          }
          _this8.masterPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(_this8.masterPlaylistLoader_.master, _this8.masterPlaylistLoader_.sidxMapping_);
          _this8.addSidxSegments_(_this8.media(), _this8.state, function(sidxChanged) {
            _this8.refreshMedia_(_this8.media().id);
          });
        });
      };
      _proto.refreshMedia_ = function refreshMedia_(mediaID) {
        var _this9 = this;
        if (!mediaID) {
          throw new Error("refreshMedia_ must take a media id");
        }
        if (this.media_ && this.isMaster_) {
          this.handleMaster_();
        }
        var playlists = this.masterPlaylistLoader_.master.playlists;
        var mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
        if (mediaChanged) {
          this.media_ = playlists[mediaID];
        } else {
          this.trigger("playlistunchanged");
        }
        if (!this.mediaUpdateTimeout) {
          var createMediaUpdateTimeout = function createMediaUpdateTimeout2() {
            if (_this9.media().endList) {
              return;
            }
            _this9.mediaUpdateTimeout = window__default["default"].setTimeout(function() {
              _this9.trigger("mediaupdatetimeout");
              createMediaUpdateTimeout2();
            }, refreshDelay(_this9.media(), Boolean(mediaChanged)));
          };
          createMediaUpdateTimeout();
        }
        this.trigger("loadedplaylist");
      };
      return DashPlaylistLoader2;
    }(EventTarget);
    var Config = {
      GOAL_BUFFER_LENGTH: 30,
      MAX_GOAL_BUFFER_LENGTH: 60,
      BACK_BUFFER_LENGTH: 30,
      GOAL_BUFFER_LENGTH_RATE: 1,
      INITIAL_BANDWIDTH: 4194304,
      BANDWIDTH_VARIANCE: 1.2,
      BUFFER_LOW_WATER_LINE: 0,
      MAX_BUFFER_LOW_WATER_LINE: 30,
      EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
      BUFFER_LOW_WATER_LINE_RATE: 1,
      BUFFER_HIGH_WATER_LINE: 30
    };
    var stringToArrayBuffer = function stringToArrayBuffer2(string) {
      var view = new Uint8Array(new ArrayBuffer(string.length));
      for (var i2 = 0; i2 < string.length; i2++) {
        view[i2] = string.charCodeAt(i2);
      }
      return view.buffer;
    };
    var browserWorkerPolyFill = function browserWorkerPolyFill2(workerObj) {
      workerObj.on = workerObj.addEventListener;
      workerObj.off = workerObj.removeEventListener;
      return workerObj;
    };
    var createObjectURL = function createObjectURL2(str) {
      try {
        return URL.createObjectURL(new Blob([str], {
          type: "application/javascript"
        }));
      } catch (e) {
        var blob = new BlobBuilder();
        blob.append(str);
        return URL.createObjectURL(blob.getBlob());
      }
    };
    var factory = function factory2(code) {
      return function() {
        var objectUrl = createObjectURL(code);
        var worker = browserWorkerPolyFill(new Worker(objectUrl));
        worker.objURL = objectUrl;
        var terminate = worker.terminate;
        worker.on = worker.addEventListener;
        worker.off = worker.removeEventListener;
        worker.terminate = function() {
          URL.revokeObjectURL(objectUrl);
          return terminate.call(this);
        };
        return worker;
      };
    };
    var transform = function transform2(code) {
      return "var browserWorkerPolyFill = " + browserWorkerPolyFill.toString() + ";\nbrowserWorkerPolyFill(self);\n" + code;
    };
    var getWorkerString = function getWorkerString2(fn) {
      return fn.toString().replace(/^function.+?{/, "").slice(0, -1);
    };
    var workerCode$1 = transform(getWorkerString(function() {
      var Stream = function Stream2() {
        this.init = function() {
          var listeners = {};
          this.on = function(type2, listener) {
            if (!listeners[type2]) {
              listeners[type2] = [];
            }
            listeners[type2] = listeners[type2].concat(listener);
          };
          this.off = function(type2, listener) {
            var index;
            if (!listeners[type2]) {
              return false;
            }
            index = listeners[type2].indexOf(listener);
            listeners[type2] = listeners[type2].slice();
            listeners[type2].splice(index, 1);
            return index > -1;
          };
          this.trigger = function(type2) {
            var callbacks, i2, length, args;
            callbacks = listeners[type2];
            if (!callbacks) {
              return;
            }
            if (arguments.length === 2) {
              length = callbacks.length;
              for (i2 = 0; i2 < length; ++i2) {
                callbacks[i2].call(this, arguments[1]);
              }
            } else {
              args = [];
              i2 = arguments.length;
              for (i2 = 1; i2 < arguments.length; ++i2) {
                args.push(arguments[i2]);
              }
              length = callbacks.length;
              for (i2 = 0; i2 < length; ++i2) {
                callbacks[i2].apply(this, args);
              }
            }
          };
          this.dispose = function() {
            listeners = {};
          };
        };
      };
      Stream.prototype.pipe = function(destination) {
        this.on("data", function(data) {
          destination.push(data);
        });
        this.on("done", function(flushSource) {
          destination.flush(flushSource);
        });
        this.on("partialdone", function(flushSource) {
          destination.partialFlush(flushSource);
        });
        this.on("endedtimeline", function(flushSource) {
          destination.endTimeline(flushSource);
        });
        this.on("reset", function(flushSource) {
          destination.reset(flushSource);
        });
        return destination;
      };
      Stream.prototype.push = function(data) {
        this.trigger("data", data);
      };
      Stream.prototype.flush = function(flushSource) {
        this.trigger("done", flushSource);
      };
      Stream.prototype.partialFlush = function(flushSource) {
        this.trigger("partialdone", flushSource);
      };
      Stream.prototype.endTimeline = function(flushSource) {
        this.trigger("endedtimeline", flushSource);
      };
      Stream.prototype.reset = function(flushSource) {
        this.trigger("reset", flushSource);
      };
      var stream = Stream;
      var MAX_UINT32$1 = Math.pow(2, 32);
      var getUint64$2 = function getUint642(uint8) {
        var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
        var value;
        if (dv.getBigUint64) {
          value = dv.getBigUint64(0);
          if (value < Number.MAX_SAFE_INTEGER) {
            return Number(value);
          }
          return value;
        }
        return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
      };
      var numbers = {
        getUint64: getUint64$2,
        MAX_UINT32: MAX_UINT32$1
      };
      var MAX_UINT32 = numbers.MAX_UINT32;
      var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
      (function() {
        var i2;
        types = {
          avc1: [],
          avcC: [],
          btrt: [],
          dinf: [],
          dref: [],
          esds: [],
          ftyp: [],
          hdlr: [],
          mdat: [],
          mdhd: [],
          mdia: [],
          mfhd: [],
          minf: [],
          moof: [],
          moov: [],
          mp4a: [],
          mvex: [],
          mvhd: [],
          pasp: [],
          sdtp: [],
          smhd: [],
          stbl: [],
          stco: [],
          stsc: [],
          stsd: [],
          stsz: [],
          stts: [],
          styp: [],
          tfdt: [],
          tfhd: [],
          traf: [],
          trak: [],
          trun: [],
          trex: [],
          tkhd: [],
          vmhd: []
        };
        if (typeof Uint8Array === "undefined") {
          return;
        }
        for (i2 in types) {
          if (types.hasOwnProperty(i2)) {
            types[i2] = [i2.charCodeAt(0), i2.charCodeAt(1), i2.charCodeAt(2), i2.charCodeAt(3)];
          }
        }
        MAJOR_BRAND = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]);
        AVC1_BRAND = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]);
        MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
        VIDEO_HDLR = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          118,
          105,
          100,
          101,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          86,
          105,
          100,
          101,
          111,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
        ]);
        AUDIO_HDLR = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          115,
          111,
          117,
          110,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          83,
          111,
          117,
          110,
          100,
          72,
          97,
          110,
          100,
          108,
          101,
          114,
          0
        ]);
        HDLR_TYPES = {
          video: VIDEO_HDLR,
          audio: AUDIO_HDLR
        };
        DREF = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          12,
          117,
          114,
          108,
          32,
          0,
          0,
          0,
          1
        ]);
        SMHD = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]);
        STCO = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]);
        STSC = STCO;
        STSZ = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]);
        STTS = STCO;
        VMHD = new Uint8Array([
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]);
      })();
      box = function box2(type2) {
        var payload = [], size = 0, i2, result, view;
        for (i2 = 1; i2 < arguments.length; i2++) {
          payload.push(arguments[i2]);
        }
        i2 = payload.length;
        while (i2--) {
          size += payload[i2].byteLength;
        }
        result = new Uint8Array(size + 8);
        view = new DataView(result.buffer, result.byteOffset, result.byteLength);
        view.setUint32(0, result.byteLength);
        result.set(type2, 4);
        for (i2 = 0, size = 8; i2 < payload.length; i2++) {
          result.set(payload[i2], size);
          size += payload[i2].byteLength;
        }
        return result;
      };
      dinf = function dinf2() {
        return box(types.dinf, box(types.dref, DREF));
      };
      esds = function esds2(track) {
        return box(types.esds, new Uint8Array([
          0,
          0,
          0,
          0,
          3,
          25,
          0,
          0,
          0,
          4,
          17,
          64,
          21,
          0,
          6,
          0,
          0,
          0,
          218,
          192,
          0,
          0,
          218,
          192,
          5,
          2,
          track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1,
          track.samplingfrequencyindex << 7 | track.channelcount << 3,
          6,
          1,
          2
        ]));
      };
      ftyp = function ftyp2() {
        return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
      };
      hdlr = function hdlr2(type2) {
        return box(types.hdlr, HDLR_TYPES[type2]);
      };
      mdat = function mdat2(data) {
        return box(types.mdat, data);
      };
      mdhd = function mdhd2(track) {
        var result = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          2,
          0,
          0,
          0,
          3,
          0,
          1,
          95,
          144,
          track.duration >>> 24 & 255,
          track.duration >>> 16 & 255,
          track.duration >>> 8 & 255,
          track.duration & 255,
          85,
          196,
          0,
          0
        ]);
        if (track.samplerate) {
          result[12] = track.samplerate >>> 24 & 255;
          result[13] = track.samplerate >>> 16 & 255;
          result[14] = track.samplerate >>> 8 & 255;
          result[15] = track.samplerate & 255;
        }
        return box(types.mdhd, result);
      };
      mdia = function mdia2(track) {
        return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
      };
      mfhd = function mfhd2(sequenceNumber) {
        return box(types.mfhd, new Uint8Array([
          0,
          0,
          0,
          0,
          (sequenceNumber & 4278190080) >> 24,
          (sequenceNumber & 16711680) >> 16,
          (sequenceNumber & 65280) >> 8,
          sequenceNumber & 255
        ]));
      };
      minf = function minf2(track) {
        return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
      };
      moof = function moof2(sequenceNumber, tracks) {
        var trackFragments = [], i2 = tracks.length;
        while (i2--) {
          trackFragments[i2] = traf(tracks[i2]);
        }
        return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
      };
      moov = function moov2(tracks) {
        var i2 = tracks.length, boxes = [];
        while (i2--) {
          boxes[i2] = trak(tracks[i2]);
        }
        return box.apply(null, [types.moov, mvhd(4294967295)].concat(boxes).concat(mvex(tracks)));
      };
      mvex = function mvex2(tracks) {
        var i2 = tracks.length, boxes = [];
        while (i2--) {
          boxes[i2] = trex(tracks[i2]);
        }
        return box.apply(null, [types.mvex].concat(boxes));
      };
      mvhd = function mvhd2(duration2) {
        var bytes = new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          2,
          0,
          1,
          95,
          144,
          (duration2 & 4278190080) >> 24,
          (duration2 & 16711680) >> 16,
          (duration2 & 65280) >> 8,
          duration2 & 255,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          64,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          255,
          255,
          255,
          255
        ]);
        return box(types.mvhd, bytes);
      };
      sdtp = function sdtp2(track) {
        var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i2;
        for (i2 = 0; i2 < samples.length; i2++) {
          flags = samples[i2].flags;
          bytes[i2 + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
        }
        return box(types.sdtp, bytes);
      };
      stbl = function stbl2(track) {
        return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
      };
      (function() {
        var videoSample, audioSample;
        stsd = function stsd2(track) {
          return box(types.stsd, new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
          ]), track.type === "video" ? videoSample(track) : audioSample(track));
        };
        videoSample = function videoSample2(track) {
          var sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [], i2, avc1Box;
          for (i2 = 0; i2 < sps.length; i2++) {
            sequenceParameterSets.push((sps[i2].byteLength & 65280) >>> 8);
            sequenceParameterSets.push(sps[i2].byteLength & 255);
            sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i2]));
          }
          for (i2 = 0; i2 < pps.length; i2++) {
            pictureParameterSets.push((pps[i2].byteLength & 65280) >>> 8);
            pictureParameterSets.push(pps[i2].byteLength & 255);
            pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i2]));
          }
          avc1Box = [types.avc1, new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            (track.width & 65280) >> 8,
            track.width & 255,
            (track.height & 65280) >> 8,
            track.height & 255,
            0,
            72,
            0,
            0,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            19,
            118,
            105,
            100,
            101,
            111,
            106,
            115,
            45,
            99,
            111,
            110,
            116,
            114,
            105,
            98,
            45,
            104,
            108,
            115,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            24,
            17,
            17
          ]), box(types.avcC, new Uint8Array([
            1,
            track.profileIdc,
            track.profileCompatibility,
            track.levelIdc,
            255
          ].concat([sps.length], sequenceParameterSets, [pps.length], pictureParameterSets))), box(types.btrt, new Uint8Array([
            0,
            28,
            156,
            128,
            0,
            45,
            198,
            192,
            0,
            45,
            198,
            192
          ]))];
          if (track.sarRatio) {
            var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
            avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255])));
          }
          return box.apply(null, avc1Box);
        };
        audioSample = function audioSample2(track) {
          return box(types.mp4a, new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            (track.channelcount & 65280) >> 8,
            track.channelcount & 255,
            (track.samplesize & 65280) >> 8,
            track.samplesize & 255,
            0,
            0,
            0,
            0,
            (track.samplerate & 65280) >> 8,
            track.samplerate & 255,
            0,
            0
          ]), esds(track));
        };
      })();
      tkhd = function tkhd2(track) {
        var result = new Uint8Array([
          0,
          0,
          0,
          7,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          (track.id & 4278190080) >> 24,
          (track.id & 16711680) >> 16,
          (track.id & 65280) >> 8,
          track.id & 255,
          0,
          0,
          0,
          0,
          (track.duration & 4278190080) >> 24,
          (track.duration & 16711680) >> 16,
          (track.duration & 65280) >> 8,
          track.duration & 255,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          64,
          0,
          0,
          0,
          (track.width & 65280) >> 8,
          track.width & 255,
          0,
          0,
          (track.height & 65280) >> 8,
          track.height & 255,
          0,
          0
        ]);
        return box(types.tkhd, result);
      };
      traf = function traf2(track) {
        var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
        trackFragmentHeader = box(types.tfhd, new Uint8Array([
          0,
          0,
          0,
          58,
          (track.id & 4278190080) >> 24,
          (track.id & 16711680) >> 16,
          (track.id & 65280) >> 8,
          track.id & 255,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ]));
        upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);
        lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);
        trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
          1,
          0,
          0,
          0,
          upperWordBaseMediaDecodeTime >>> 24 & 255,
          upperWordBaseMediaDecodeTime >>> 16 & 255,
          upperWordBaseMediaDecodeTime >>> 8 & 255,
          upperWordBaseMediaDecodeTime & 255,
          lowerWordBaseMediaDecodeTime >>> 24 & 255,
          lowerWordBaseMediaDecodeTime >>> 16 & 255,
          lowerWordBaseMediaDecodeTime >>> 8 & 255,
          lowerWordBaseMediaDecodeTime & 255
        ]));
        dataOffset = 32 + 20 + 8 + 16 + 8 + 8;
        if (track.type === "audio") {
          trackFragmentRun = trun$1(track, dataOffset);
          return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
        }
        sampleDependencyTable = sdtp(track);
        trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
        return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
      };
      trak = function trak2(track) {
        track.duration = track.duration || 4294967295;
        return box(types.trak, tkhd(track), mdia(track));
      };
      trex = function trex2(track) {
        var result = new Uint8Array([
          0,
          0,
          0,
          0,
          (track.id & 4278190080) >> 24,
          (track.id & 16711680) >> 16,
          (track.id & 65280) >> 8,
          track.id & 255,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          1
        ]);
        if (track.type !== "video") {
          result[result.length - 1] = 0;
        }
        return box(types.trex, result);
      };
      (function() {
        var audioTrun, videoTrun, trunHeader;
        trunHeader = function trunHeader2(samples, offset) {
          var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
          if (samples.length) {
            if (samples[0].duration !== void 0) {
              durationPresent = 1;
            }
            if (samples[0].size !== void 0) {
              sizePresent = 2;
            }
            if (samples[0].flags !== void 0) {
              flagsPresent = 4;
            }
            if (samples[0].compositionTimeOffset !== void 0) {
              compositionTimeOffset = 8;
            }
          }
          return [
            0,
            0,
            durationPresent | sizePresent | flagsPresent | compositionTimeOffset,
            1,
            (samples.length & 4278190080) >>> 24,
            (samples.length & 16711680) >>> 16,
            (samples.length & 65280) >>> 8,
            samples.length & 255,
            (offset & 4278190080) >>> 24,
            (offset & 16711680) >>> 16,
            (offset & 65280) >>> 8,
            offset & 255
          ];
        };
        videoTrun = function videoTrun2(track, offset) {
          var bytesOffest, bytes, header, samples, sample, i2;
          samples = track.samples || [];
          offset += 8 + 12 + 16 * samples.length;
          header = trunHeader(samples, offset);
          bytes = new Uint8Array(header.length + samples.length * 16);
          bytes.set(header);
          bytesOffest = header.length;
          for (i2 = 0; i2 < samples.length; i2++) {
            sample = samples[i2];
            bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
            bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
            bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
            bytes[bytesOffest++] = sample.duration & 255;
            bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
            bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
            bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
            bytes[bytesOffest++] = sample.size & 255;
            bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
            bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
            bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
            bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
            bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
            bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
            bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
            bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
          }
          return box(types.trun, bytes);
        };
        audioTrun = function audioTrun2(track, offset) {
          var bytes, bytesOffest, header, samples, sample, i2;
          samples = track.samples || [];
          offset += 8 + 12 + 8 * samples.length;
          header = trunHeader(samples, offset);
          bytes = new Uint8Array(header.length + samples.length * 8);
          bytes.set(header);
          bytesOffest = header.length;
          for (i2 = 0; i2 < samples.length; i2++) {
            sample = samples[i2];
            bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
            bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
            bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
            bytes[bytesOffest++] = sample.duration & 255;
            bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
            bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
            bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
            bytes[bytesOffest++] = sample.size & 255;
          }
          return box(types.trun, bytes);
        };
        trun$1 = function trun2(track, offset) {
          if (track.type === "audio") {
            return audioTrun(track, offset);
          }
          return videoTrun(track, offset);
        };
      })();
      var mp4Generator = {
        ftyp,
        mdat,
        moof,
        moov,
        initSegment: function initSegment(tracks) {
          var fileType = ftyp(), movie = moov(tracks), result;
          result = new Uint8Array(fileType.byteLength + movie.byteLength);
          result.set(fileType);
          result.set(movie, fileType.byteLength);
          return result;
        }
      };
      var groupNalsIntoFrames = function groupNalsIntoFrames2(nalUnits) {
        var i2, currentNal, currentFrame = [], frames = [];
        frames.byteLength = 0;
        frames.nalCount = 0;
        frames.duration = 0;
        currentFrame.byteLength = 0;
        for (i2 = 0; i2 < nalUnits.length; i2++) {
          currentNal = nalUnits[i2];
          if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
            if (currentFrame.length) {
              currentFrame.duration = currentNal.dts - currentFrame.dts;
              frames.byteLength += currentFrame.byteLength;
              frames.nalCount += currentFrame.length;
              frames.duration += currentFrame.duration;
              frames.push(currentFrame);
            }
            currentFrame = [currentNal];
            currentFrame.byteLength = currentNal.data.byteLength;
            currentFrame.pts = currentNal.pts;
            currentFrame.dts = currentNal.dts;
          } else {
            if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") {
              currentFrame.keyFrame = true;
            }
            currentFrame.duration = currentNal.dts - currentFrame.dts;
            currentFrame.byteLength += currentNal.data.byteLength;
            currentFrame.push(currentNal);
          }
        }
        if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {
          currentFrame.duration = frames[frames.length - 1].duration;
        }
        frames.byteLength += currentFrame.byteLength;
        frames.nalCount += currentFrame.length;
        frames.duration += currentFrame.duration;
        frames.push(currentFrame);
        return frames;
      };
      var groupFramesIntoGops = function groupFramesIntoGops2(frames) {
        var i2, currentFrame, currentGop = [], gops = [];
        currentGop.byteLength = 0;
        currentGop.nalCount = 0;
        currentGop.duration = 0;
        currentGop.pts = frames[0].pts;
        currentGop.dts = frames[0].dts;
        gops.byteLength = 0;
        gops.nalCount = 0;
        gops.duration = 0;
        gops.pts = frames[0].pts;
        gops.dts = frames[0].dts;
        for (i2 = 0; i2 < frames.length; i2++) {
          currentFrame = frames[i2];
          if (currentFrame.keyFrame) {
            if (currentGop.length) {
              gops.push(currentGop);
              gops.byteLength += currentGop.byteLength;
              gops.nalCount += currentGop.nalCount;
              gops.duration += currentGop.duration;
            }
            currentGop = [currentFrame];
            currentGop.nalCount = currentFrame.length;
            currentGop.byteLength = currentFrame.byteLength;
            currentGop.pts = currentFrame.pts;
            currentGop.dts = currentFrame.dts;
            currentGop.duration = currentFrame.duration;
          } else {
            currentGop.duration += currentFrame.duration;
            currentGop.nalCount += currentFrame.length;
            currentGop.byteLength += currentFrame.byteLength;
            currentGop.push(currentFrame);
          }
        }
        if (gops.length && currentGop.duration <= 0) {
          currentGop.duration = gops[gops.length - 1].duration;
        }
        gops.byteLength += currentGop.byteLength;
        gops.nalCount += currentGop.nalCount;
        gops.duration += currentGop.duration;
        gops.push(currentGop);
        return gops;
      };
      var extendFirstKeyFrame = function extendFirstKeyFrame2(gops) {
        var currentGop;
        if (!gops[0][0].keyFrame && gops.length > 1) {
          currentGop = gops.shift();
          gops.byteLength -= currentGop.byteLength;
          gops.nalCount -= currentGop.nalCount;
          gops[0][0].dts = currentGop.dts;
          gops[0][0].pts = currentGop.pts;
          gops[0][0].duration += currentGop.duration;
        }
        return gops;
      };
      var createDefaultSample = function createDefaultSample2() {
        return {
          size: 0,
          flags: {
            isLeading: 0,
            dependsOn: 1,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradationPriority: 0,
            isNonSyncSample: 1
          }
        };
      };
      var sampleForFrame = function sampleForFrame2(frame, dataOffset) {
        var sample = createDefaultSample();
        sample.dataOffset = dataOffset;
        sample.compositionTimeOffset = frame.pts - frame.dts;
        sample.duration = frame.duration;
        sample.size = 4 * frame.length;
        sample.size += frame.byteLength;
        if (frame.keyFrame) {
          sample.flags.dependsOn = 2;
          sample.flags.isNonSyncSample = 0;
        }
        return sample;
      };
      var generateSampleTable$1 = function generateSampleTable2(gops, baseDataOffset) {
        var h, i2, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
        for (h = 0; h < gops.length; h++) {
          currentGop = gops[h];
          for (i2 = 0; i2 < currentGop.length; i2++) {
            currentFrame = currentGop[i2];
            sample = sampleForFrame(currentFrame, dataOffset);
            dataOffset += sample.size;
            samples.push(sample);
          }
        }
        return samples;
      };
      var concatenateNalData = function concatenateNalData2(gops) {
        var h, i2, j, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
        for (h = 0; h < gops.length; h++) {
          currentGop = gops[h];
          for (i2 = 0; i2 < currentGop.length; i2++) {
            currentFrame = currentGop[i2];
            for (j = 0; j < currentFrame.length; j++) {
              currentNal = currentFrame[j];
              view.setUint32(dataOffset, currentNal.data.byteLength);
              dataOffset += 4;
              data.set(currentNal.data, dataOffset);
              dataOffset += currentNal.data.byteLength;
            }
          }
        }
        return data;
      };
      var generateSampleTableForFrame = function generateSampleTableForFrame2(frame, baseDataOffset) {
        var sample, dataOffset = baseDataOffset || 0, samples = [];
        sample = sampleForFrame(frame, dataOffset);
        samples.push(sample);
        return samples;
      };
      var concatenateNalDataForFrame = function concatenateNalDataForFrame2(frame) {
        var i2, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
        for (i2 = 0; i2 < frame.length; i2++) {
          currentNal = frame[i2];
          view.setUint32(dataOffset, currentNal.data.byteLength);
          dataOffset += 4;
          data.set(currentNal.data, dataOffset);
          dataOffset += currentNal.data.byteLength;
        }
        return data;
      };
      var frameUtils = {
        groupNalsIntoFrames,
        groupFramesIntoGops,
        extendFirstKeyFrame,
        generateSampleTable: generateSampleTable$1,
        concatenateNalData,
        generateSampleTableForFrame,
        concatenateNalDataForFrame
      };
      var highPrefix = [33, 16, 5, 32, 164, 27];
      var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];
      var zeroFill = function zeroFill2(count) {
        var a = [];
        while (count--) {
          a.push(0);
        }
        return a;
      };
      var makeTable = function makeTable2(metaTable) {
        return Object.keys(metaTable).reduce(function(obj2, key) {
          obj2[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {
            return arr.concat(part);
          }, []));
          return obj2;
        }, {});
      };
      var silence;
      var silence_1 = function silence_12() {
        if (!silence) {
          var coneOfSilence = {
            96e3: [highPrefix, [227, 64], zeroFill(154), [56]],
            88200: [highPrefix, [231], zeroFill(170), [56]],
            64e3: [highPrefix, [248, 192], zeroFill(240), [56]],
            48e3: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],
            44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],
            32e3: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],
            24e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],
            16e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],
            12e3: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],
            11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],
            8e3: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]
          };
          silence = makeTable(coneOfSilence);
        }
        return silence;
      };
      var ONE_SECOND_IN_TS$4 = 9e4, secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds;
      secondsToVideoTs = function secondsToVideoTs2(seconds) {
        return seconds * ONE_SECOND_IN_TS$4;
      };
      secondsToAudioTs = function secondsToAudioTs2(seconds, sampleRate) {
        return seconds * sampleRate;
      };
      videoTsToSeconds = function videoTsToSeconds2(timestamp) {
        return timestamp / ONE_SECOND_IN_TS$4;
      };
      audioTsToSeconds = function audioTsToSeconds2(timestamp, sampleRate) {
        return timestamp / sampleRate;
      };
      audioTsToVideoTs = function audioTsToVideoTs2(timestamp, sampleRate) {
        return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
      };
      videoTsToAudioTs = function videoTsToAudioTs2(timestamp, sampleRate) {
        return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
      };
      metadataTsToSeconds = function metadataTsToSeconds2(timestamp, timelineStartPts, keepOriginalTimestamps) {
        return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
      };
      var clock2 = {
        ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
        secondsToVideoTs,
        secondsToAudioTs,
        videoTsToSeconds,
        audioTsToSeconds,
        audioTsToVideoTs,
        videoTsToAudioTs,
        metadataTsToSeconds
      };
      var sumFrameByteLengths = function sumFrameByteLengths2(array) {
        var i2, currentObj, sum = 0;
        for (i2 = 0; i2 < array.length; i2++) {
          currentObj = array[i2];
          sum += currentObj.data.byteLength;
        }
        return sum;
      };
      var prefixWithSilence = function prefixWithSilence2(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
        var baseMediaDecodeTimeTs, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0, silentFrame, i2, firstFrame;
        if (!frames.length) {
          return;
        }
        baseMediaDecodeTimeTs = clock2.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
        frameDuration = Math.ceil(clock2.ONE_SECOND_IN_TS / (track.samplerate / 1024));
        if (audioAppendStartTs && videoBaseMediaDecodeTime) {
          audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
          audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
          audioFillDuration = audioFillFrameCount * frameDuration;
        }
        if (audioFillFrameCount < 1 || audioFillDuration > clock2.ONE_SECOND_IN_TS / 2) {
          return;
        }
        silentFrame = silence_1()[track.samplerate];
        if (!silentFrame) {
          silentFrame = frames[0].data;
        }
        for (i2 = 0; i2 < audioFillFrameCount; i2++) {
          firstFrame = frames[0];
          frames.splice(0, 0, {
            data: silentFrame,
            dts: firstFrame.dts - frameDuration,
            pts: firstFrame.pts - frameDuration
          });
        }
        track.baseMediaDecodeTime -= Math.floor(clock2.videoTsToAudioTs(audioFillDuration, track.samplerate));
        return audioFillDuration;
      };
      var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts2(adtsFrames, track, earliestAllowedDts) {
        if (track.minSegmentDts >= earliestAllowedDts) {
          return adtsFrames;
        }
        track.minSegmentDts = Infinity;
        return adtsFrames.filter(function(currentFrame) {
          if (currentFrame.dts >= earliestAllowedDts) {
            track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
            track.minSegmentPts = track.minSegmentDts;
            return true;
          }
          return false;
        });
      };
      var generateSampleTable = function generateSampleTable2(frames) {
        var i2, currentFrame, samples = [];
        for (i2 = 0; i2 < frames.length; i2++) {
          currentFrame = frames[i2];
          samples.push({
            size: currentFrame.data.byteLength,
            duration: 1024
          });
        }
        return samples;
      };
      var concatenateFrameData = function concatenateFrameData2(frames) {
        var i2, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
        for (i2 = 0; i2 < frames.length; i2++) {
          currentFrame = frames[i2];
          data.set(currentFrame.data, dataOffset);
          dataOffset += currentFrame.data.byteLength;
        }
        return data;
      };
      var audioFrameUtils = {
        prefixWithSilence,
        trimAdtsFramesByEarliestDts,
        generateSampleTable,
        concatenateFrameData
      };
      var ONE_SECOND_IN_TS$3 = clock2.ONE_SECOND_IN_TS;
      var collectDtsInfo = function collectDtsInfo2(track, data) {
        if (typeof data.pts === "number") {
          if (track.timelineStartInfo.pts === void 0) {
            track.timelineStartInfo.pts = data.pts;
          }
          if (track.minSegmentPts === void 0) {
            track.minSegmentPts = data.pts;
          } else {
            track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
          }
          if (track.maxSegmentPts === void 0) {
            track.maxSegmentPts = data.pts;
          } else {
            track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
          }
        }
        if (typeof data.dts === "number") {
          if (track.timelineStartInfo.dts === void 0) {
            track.timelineStartInfo.dts = data.dts;
          }
          if (track.minSegmentDts === void 0) {
            track.minSegmentDts = data.dts;
          } else {
            track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
          }
          if (track.maxSegmentDts === void 0) {
            track.maxSegmentDts = data.dts;
          } else {
            track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
          }
        }
      };
      var clearDtsInfo = function clearDtsInfo2(track) {
        delete track.minSegmentDts;
        delete track.maxSegmentDts;
        delete track.minSegmentPts;
        delete track.maxSegmentPts;
      };
      var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime2(track, keepOriginalTimestamps) {
        var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
        if (!keepOriginalTimestamps) {
          minSegmentDts -= track.timelineStartInfo.dts;
        }
        baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
        baseMediaDecodeTime += minSegmentDts;
        baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
        if (track.type === "audio") {
          scale = track.samplerate / ONE_SECOND_IN_TS$3;
          baseMediaDecodeTime *= scale;
          baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
        }
        return baseMediaDecodeTime;
      };
      var trackDecodeInfo = {
        clearDtsInfo,
        calculateTrackBaseMediaDecodeTime,
        collectDtsInfo
      };
      var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
      var parseSei = function parseSei2(bytes) {
        var i2 = 0, result = {
          payloadType: -1,
          payloadSize: 0
        }, payloadType = 0, payloadSize = 0;
        while (i2 < bytes.byteLength) {
          if (bytes[i2] === RBSP_TRAILING_BITS) {
            break;
          }
          while (bytes[i2] === 255) {
            payloadType += 255;
            i2++;
          }
          payloadType += bytes[i2++];
          while (bytes[i2] === 255) {
            payloadSize += 255;
            i2++;
          }
          payloadSize += bytes[i2++];
          if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
            var userIdentifier = String.fromCharCode(bytes[i2 + 3], bytes[i2 + 4], bytes[i2 + 5], bytes[i2 + 6]);
            if (userIdentifier === "GA94") {
              result.payloadType = payloadType;
              result.payloadSize = payloadSize;
              result.payload = bytes.subarray(i2, i2 + payloadSize);
              break;
            } else {
              result.payload = void 0;
            }
          }
          i2 += payloadSize;
          payloadType = 0;
          payloadSize = 0;
        }
        return result;
      };
      var parseUserData = function parseUserData2(sei) {
        if (sei.payload[0] !== 181) {
          return null;
        }
        if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {
          return null;
        }
        if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") {
          return null;
        }
        if (sei.payload[7] !== 3) {
          return null;
        }
        return sei.payload.subarray(8, sei.payload.length - 1);
      };
      var parseCaptionPackets = function parseCaptionPackets2(pts, userData) {
        var results = [], i2, count, offset, data;
        if (!(userData[0] & 64)) {
          return results;
        }
        count = userData[0] & 31;
        for (i2 = 0; i2 < count; i2++) {
          offset = i2 * 3;
          data = {
            type: userData[offset + 2] & 3,
            pts
          };
          if (userData[offset + 2] & 4) {
            data.ccData = userData[offset + 3] << 8 | userData[offset + 4];
            results.push(data);
          }
        }
        return results;
      };
      var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes2(data) {
        var length = data.byteLength, emulationPreventionBytesPositions = [], i2 = 1, newLength, newData;
        while (i2 < length - 2) {
          if (data[i2] === 0 && data[i2 + 1] === 0 && data[i2 + 2] === 3) {
            emulationPreventionBytesPositions.push(i2 + 2);
            i2 += 2;
          } else {
            i2++;
          }
        }
        if (emulationPreventionBytesPositions.length === 0) {
          return data;
        }
        newLength = length - emulationPreventionBytesPositions.length;
        newData = new Uint8Array(newLength);
        var sourceIndex = 0;
        for (i2 = 0; i2 < newLength; sourceIndex++, i2++) {
          if (sourceIndex === emulationPreventionBytesPositions[0]) {
            sourceIndex++;
            emulationPreventionBytesPositions.shift();
          }
          newData[i2] = data[sourceIndex];
        }
        return newData;
      };
      var captionPacketParser = {
        parseSei,
        parseUserData,
        parseCaptionPackets,
        discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
        USER_DATA_REGISTERED_ITU_T_T35
      };
      var CaptionStream$1 = function CaptionStream2(options) {
        options = options || {};
        CaptionStream2.prototype.init.call(this);
        this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
        this.captionPackets_ = [];
        this.ccStreams_ = [
          new Cea608Stream(0, 0),
          new Cea608Stream(0, 1),
          new Cea608Stream(1, 0),
          new Cea608Stream(1, 1)
        ];
        if (this.parse708captions_) {
          this.cc708Stream_ = new Cea708Stream({
            captionServices: options.captionServices
          });
        }
        this.reset();
        this.ccStreams_.forEach(function(cc) {
          cc.on("data", this.trigger.bind(this, "data"));
          cc.on("partialdone", this.trigger.bind(this, "partialdone"));
          cc.on("done", this.trigger.bind(this, "done"));
        }, this);
        if (this.parse708captions_) {
          this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
          this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
          this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
        }
      };
      CaptionStream$1.prototype = new stream();
      CaptionStream$1.prototype.push = function(event2) {
        var sei, userData, newCaptionPackets;
        if (event2.nalUnitType !== "sei_rbsp") {
          return;
        }
        sei = captionPacketParser.parseSei(event2.escapedRBSP);
        if (!sei.payload) {
          return;
        }
        if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {
          return;
        }
        userData = captionPacketParser.parseUserData(sei);
        if (!userData) {
          return;
        }
        if (event2.dts < this.latestDts_) {
          this.ignoreNextEqualDts_ = true;
          return;
        } else if (event2.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
          this.numSameDts_--;
          if (!this.numSameDts_) {
            this.ignoreNextEqualDts_ = false;
          }
          return;
        }
        newCaptionPackets = captionPacketParser.parseCaptionPackets(event2.pts, userData);
        this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
        if (this.latestDts_ !== event2.dts) {
          this.numSameDts_ = 0;
        }
        this.numSameDts_++;
        this.latestDts_ = event2.dts;
      };
      CaptionStream$1.prototype.flushCCStreams = function(flushType) {
        this.ccStreams_.forEach(function(cc) {
          return flushType === "flush" ? cc.flush() : cc.partialFlush();
        }, this);
      };
      CaptionStream$1.prototype.flushStream = function(flushType) {
        if (!this.captionPackets_.length) {
          this.flushCCStreams(flushType);
          return;
        }
        this.captionPackets_.forEach(function(elem, idx) {
          elem.presortIndex = idx;
        });
        this.captionPackets_.sort(function(a, b) {
          if (a.pts === b.pts) {
            return a.presortIndex - b.presortIndex;
          }
          return a.pts - b.pts;
        });
        this.captionPackets_.forEach(function(packet) {
          if (packet.type < 2) {
            this.dispatchCea608Packet(packet);
          } else {
            this.dispatchCea708Packet(packet);
          }
        }, this);
        this.captionPackets_.length = 0;
        this.flushCCStreams(flushType);
      };
      CaptionStream$1.prototype.flush = function() {
        return this.flushStream("flush");
      };
      CaptionStream$1.prototype.partialFlush = function() {
        return this.flushStream("partialFlush");
      };
      CaptionStream$1.prototype.reset = function() {
        this.latestDts_ = null;
        this.ignoreNextEqualDts_ = false;
        this.numSameDts_ = 0;
        this.activeCea608Channel_ = [null, null];
        this.ccStreams_.forEach(function(ccStream) {
          ccStream.reset();
        });
      };
      CaptionStream$1.prototype.dispatchCea608Packet = function(packet) {
        if (this.setsTextOrXDSActive(packet)) {
          this.activeCea608Channel_[packet.type] = null;
        } else if (this.setsChannel1Active(packet)) {
          this.activeCea608Channel_[packet.type] = 0;
        } else if (this.setsChannel2Active(packet)) {
          this.activeCea608Channel_[packet.type] = 1;
        }
        if (this.activeCea608Channel_[packet.type] === null) {
          return;
        }
        this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
      };
      CaptionStream$1.prototype.setsChannel1Active = function(packet) {
        return (packet.ccData & 30720) === 4096;
      };
      CaptionStream$1.prototype.setsChannel2Active = function(packet) {
        return (packet.ccData & 30720) === 6144;
      };
      CaptionStream$1.prototype.setsTextOrXDSActive = function(packet) {
        return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
      };
      CaptionStream$1.prototype.dispatchCea708Packet = function(packet) {
        if (this.parse708captions_) {
          this.cc708Stream_.push(packet);
        }
      };
      var CHARACTER_TRANSLATION_708 = {
        127: 9834,
        4128: 32,
        4129: 160,
        4133: 8230,
        4138: 352,
        4140: 338,
        4144: 9608,
        4145: 8216,
        4146: 8217,
        4147: 8220,
        4148: 8221,
        4149: 8226,
        4153: 8482,
        4154: 353,
        4156: 339,
        4157: 8480,
        4159: 376,
        4214: 8539,
        4215: 8540,
        4216: 8541,
        4217: 8542,
        4218: 9168,
        4219: 9124,
        4220: 9123,
        4221: 9135,
        4222: 9126,
        4223: 9121,
        4256: 12600
      };
      var get708CharFromCode = function get708CharFromCode2(code) {
        var newCode = CHARACTER_TRANSLATION_708[code] || code;
        if (code & 4096 && code === newCode) {
          return "";
        }
        return String.fromCharCode(newCode);
      };
      var within708TextBlock = function within708TextBlock2(b) {
        return 32 <= b && b <= 127 || 160 <= b && b <= 255;
      };
      var Cea708Window = function Cea708Window2(windowNum) {
        this.windowNum = windowNum;
        this.reset();
      };
      Cea708Window.prototype.reset = function() {
        this.clearText();
        this.pendingNewLine = false;
        this.winAttr = {};
        this.penAttr = {};
        this.penLoc = {};
        this.penColor = {};
        this.visible = 0;
        this.rowLock = 0;
        this.columnLock = 0;
        this.priority = 0;
        this.relativePositioning = 0;
        this.anchorVertical = 0;
        this.anchorHorizontal = 0;
        this.anchorPoint = 0;
        this.rowCount = 1;
        this.virtualRowCount = this.rowCount + 1;
        this.columnCount = 41;
        this.windowStyle = 0;
        this.penStyle = 0;
      };
      Cea708Window.prototype.getText = function() {
        return this.rows.join("\n");
      };
      Cea708Window.prototype.clearText = function() {
        this.rows = [""];
        this.rowIdx = 0;
      };
      Cea708Window.prototype.newLine = function(pts) {
        if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") {
          this.beforeRowOverflow(pts);
        }
        if (this.rows.length > 0) {
          this.rows.push("");
          this.rowIdx++;
        }
        while (this.rows.length > this.virtualRowCount) {
          this.rows.shift();
          this.rowIdx--;
        }
      };
      Cea708Window.prototype.isEmpty = function() {
        if (this.rows.length === 0) {
          return true;
        } else if (this.rows.length === 1) {
          return this.rows[0] === "";
        }
        return false;
      };
      Cea708Window.prototype.addText = function(text) {
        this.rows[this.rowIdx] += text;
      };
      Cea708Window.prototype.backspace = function() {
        if (!this.isEmpty()) {
          var row = this.rows[this.rowIdx];
          this.rows[this.rowIdx] = row.substr(0, row.length - 1);
        }
      };
      var Cea708Service = function Cea708Service2(serviceNum, encoding, stream2) {
        this.serviceNum = serviceNum;
        this.text = "";
        this.currentWindow = new Cea708Window(-1);
        this.windows = [];
        this.stream = stream2;
        if (typeof encoding === "string") {
          this.createTextDecoder(encoding);
        }
      };
      Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
        this.startPts = pts;
        for (var win2 = 0; win2 < 8; win2++) {
          this.windows[win2] = new Cea708Window(win2);
          if (typeof beforeRowOverflow === "function") {
            this.windows[win2].beforeRowOverflow = beforeRowOverflow;
          }
        }
      };
      Cea708Service.prototype.setCurrentWindow = function(windowNum) {
        this.currentWindow = this.windows[windowNum];
      };
      Cea708Service.prototype.createTextDecoder = function(encoding) {
        if (typeof TextDecoder === "undefined") {
          this.stream.trigger("log", {
            level: "warn",
            message: "The `encoding` option is unsupported without TextDecoder support"
          });
        } else {
          try {
            this.textDecoder_ = new TextDecoder(encoding);
          } catch (error) {
            this.stream.trigger("log", {
              level: "warn",
              message: "TextDecoder could not be created with " + encoding + " encoding. " + error
            });
          }
        }
      };
      var Cea708Stream = function Cea708Stream2(options) {
        options = options || {};
        Cea708Stream2.prototype.init.call(this);
        var self2 = this;
        var captionServices = options.captionServices || {};
        var captionServiceEncodings = {};
        var serviceProps;
        Object.keys(captionServices).forEach(function(serviceName) {
          serviceProps = captionServices[serviceName];
          if (/^SERVICE/.test(serviceName)) {
            captionServiceEncodings[serviceName] = serviceProps.encoding;
          }
        });
        this.serviceEncodings = captionServiceEncodings;
        this.current708Packet = null;
        this.services = {};
        this.push = function(packet) {
          if (packet.type === 3) {
            self2.new708Packet();
            self2.add708Bytes(packet);
          } else {
            if (self2.current708Packet === null) {
              self2.new708Packet();
            }
            self2.add708Bytes(packet);
          }
        };
      };
      Cea708Stream.prototype = new stream();
      Cea708Stream.prototype.new708Packet = function() {
        if (this.current708Packet !== null) {
          this.push708Packet();
        }
        this.current708Packet = {
          data: [],
          ptsVals: []
        };
      };
      Cea708Stream.prototype.add708Bytes = function(packet) {
        var data = packet.ccData;
        var byte0 = data >>> 8;
        var byte1 = data & 255;
        this.current708Packet.ptsVals.push(packet.pts);
        this.current708Packet.data.push(byte0);
        this.current708Packet.data.push(byte1);
      };
      Cea708Stream.prototype.push708Packet = function() {
        var packet708 = this.current708Packet;
        var packetData = packet708.data;
        var serviceNum = null;
        var blockSize = null;
        var i2 = 0;
        var b = packetData[i2++];
        packet708.seq = b >> 6;
        packet708.sizeCode = b & 63;
        for (; i2 < packetData.length; i2++) {
          b = packetData[i2++];
          serviceNum = b >> 5;
          blockSize = b & 31;
          if (serviceNum === 7 && blockSize > 0) {
            b = packetData[i2++];
            serviceNum = b;
          }
          this.pushServiceBlock(serviceNum, i2, blockSize);
          if (blockSize > 0) {
            i2 += blockSize - 1;
          }
        }
      };
      Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start2, size) {
        var b;
        var i2 = start2;
        var packetData = this.current708Packet.data;
        var service = this.services[serviceNum];
        if (!service) {
          service = this.initService(serviceNum, i2);
        }
        for (; i2 < start2 + size && i2 < packetData.length; i2++) {
          b = packetData[i2];
          if (within708TextBlock(b)) {
            i2 = this.handleText(i2, service);
          } else if (b === 24) {
            i2 = this.multiByteCharacter(i2, service);
          } else if (b === 16) {
            i2 = this.extendedCommands(i2, service);
          } else if (128 <= b && b <= 135) {
            i2 = this.setCurrentWindow(i2, service);
          } else if (152 <= b && b <= 159) {
            i2 = this.defineWindow(i2, service);
          } else if (b === 136) {
            i2 = this.clearWindows(i2, service);
          } else if (b === 140) {
            i2 = this.deleteWindows(i2, service);
          } else if (b === 137) {
            i2 = this.displayWindows(i2, service);
          } else if (b === 138) {
            i2 = this.hideWindows(i2, service);
          } else if (b === 139) {
            i2 = this.toggleWindows(i2, service);
          } else if (b === 151) {
            i2 = this.setWindowAttributes(i2, service);
          } else if (b === 144) {
            i2 = this.setPenAttributes(i2, service);
          } else if (b === 145) {
            i2 = this.setPenColor(i2, service);
          } else if (b === 146) {
            i2 = this.setPenLocation(i2, service);
          } else if (b === 143) {
            service = this.reset(i2, service);
          } else if (b === 8) {
            service.currentWindow.backspace();
          } else if (b === 12) {
            service.currentWindow.clearText();
          } else if (b === 13) {
            service.currentWindow.pendingNewLine = true;
          } else if (b === 14) {
            service.currentWindow.clearText();
          } else if (b === 141) {
            i2++;
          } else
            ;
        }
      };
      Cea708Stream.prototype.extendedCommands = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[++i2];
        if (within708TextBlock(b)) {
          i2 = this.handleText(i2, service, {
            isExtended: true
          });
        }
        return i2;
      };
      Cea708Stream.prototype.getPts = function(byteIndex) {
        return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
      };
      Cea708Stream.prototype.initService = function(serviceNum, i2) {
        var serviceName = "SERVICE" + serviceNum;
        var self2 = this;
        var serviceName;
        var encoding;
        if (serviceName in this.serviceEncodings) {
          encoding = this.serviceEncodings[serviceName];
        }
        this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self2);
        this.services[serviceNum].init(this.getPts(i2), function(pts) {
          self2.flushDisplayed(pts, self2.services[serviceNum]);
        });
        return this.services[serviceNum];
      };
      Cea708Stream.prototype.handleText = function(i2, service, options) {
        var isExtended = options && options.isExtended;
        var isMultiByte = options && options.isMultiByte;
        var packetData = this.current708Packet.data;
        var extended = isExtended ? 4096 : 0;
        var currentByte = packetData[i2];
        var nextByte = packetData[i2 + 1];
        var win2 = service.currentWindow;
        var _char;
        var charCodeArray;
        if (service.textDecoder_ && !isExtended) {
          if (isMultiByte) {
            charCodeArray = [currentByte, nextByte];
            i2++;
          } else {
            charCodeArray = [currentByte];
          }
          _char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
        } else {
          _char = get708CharFromCode(extended | currentByte);
        }
        if (win2.pendingNewLine && !win2.isEmpty()) {
          win2.newLine(this.getPts(i2));
        }
        win2.pendingNewLine = false;
        win2.addText(_char);
        return i2;
      };
      Cea708Stream.prototype.multiByteCharacter = function(i2, service) {
        var packetData = this.current708Packet.data;
        var firstByte = packetData[i2 + 1];
        var secondByte = packetData[i2 + 2];
        if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {
          i2 = this.handleText(++i2, service, {
            isMultiByte: true
          });
        }
        return i2;
      };
      Cea708Stream.prototype.setCurrentWindow = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[i2];
        var windowNum = b & 7;
        service.setCurrentWindow(windowNum);
        return i2;
      };
      Cea708Stream.prototype.defineWindow = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[i2];
        var windowNum = b & 7;
        service.setCurrentWindow(windowNum);
        var win2 = service.currentWindow;
        b = packetData[++i2];
        win2.visible = (b & 32) >> 5;
        win2.rowLock = (b & 16) >> 4;
        win2.columnLock = (b & 8) >> 3;
        win2.priority = b & 7;
        b = packetData[++i2];
        win2.relativePositioning = (b & 128) >> 7;
        win2.anchorVertical = b & 127;
        b = packetData[++i2];
        win2.anchorHorizontal = b;
        b = packetData[++i2];
        win2.anchorPoint = (b & 240) >> 4;
        win2.rowCount = b & 15;
        b = packetData[++i2];
        win2.columnCount = b & 63;
        b = packetData[++i2];
        win2.windowStyle = (b & 56) >> 3;
        win2.penStyle = b & 7;
        win2.virtualRowCount = win2.rowCount + 1;
        return i2;
      };
      Cea708Stream.prototype.setWindowAttributes = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[i2];
        var winAttr = service.currentWindow.winAttr;
        b = packetData[++i2];
        winAttr.fillOpacity = (b & 192) >> 6;
        winAttr.fillRed = (b & 48) >> 4;
        winAttr.fillGreen = (b & 12) >> 2;
        winAttr.fillBlue = b & 3;
        b = packetData[++i2];
        winAttr.borderType = (b & 192) >> 6;
        winAttr.borderRed = (b & 48) >> 4;
        winAttr.borderGreen = (b & 12) >> 2;
        winAttr.borderBlue = b & 3;
        b = packetData[++i2];
        winAttr.borderType += (b & 128) >> 5;
        winAttr.wordWrap = (b & 64) >> 6;
        winAttr.printDirection = (b & 48) >> 4;
        winAttr.scrollDirection = (b & 12) >> 2;
        winAttr.justify = b & 3;
        b = packetData[++i2];
        winAttr.effectSpeed = (b & 240) >> 4;
        winAttr.effectDirection = (b & 12) >> 2;
        winAttr.displayEffect = b & 3;
        return i2;
      };
      Cea708Stream.prototype.flushDisplayed = function(pts, service) {
        var displayedText = [];
        for (var winId = 0; winId < 8; winId++) {
          if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {
            displayedText.push(service.windows[winId].getText());
          }
        }
        service.endPts = pts;
        service.text = displayedText.join("\n\n");
        this.pushCaption(service);
        service.startPts = pts;
      };
      Cea708Stream.prototype.pushCaption = function(service) {
        if (service.text !== "") {
          this.trigger("data", {
            startPts: service.startPts,
            endPts: service.endPts,
            text: service.text,
            stream: "cc708_" + service.serviceNum
          });
          service.text = "";
          service.startPts = service.endPts;
        }
      };
      Cea708Stream.prototype.displayWindows = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[++i2];
        var pts = this.getPts(i2);
        this.flushDisplayed(pts, service);
        for (var winId = 0; winId < 8; winId++) {
          if (b & 1 << winId) {
            service.windows[winId].visible = 1;
          }
        }
        return i2;
      };
      Cea708Stream.prototype.hideWindows = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[++i2];
        var pts = this.getPts(i2);
        this.flushDisplayed(pts, service);
        for (var winId = 0; winId < 8; winId++) {
          if (b & 1 << winId) {
            service.windows[winId].visible = 0;
          }
        }
        return i2;
      };
      Cea708Stream.prototype.toggleWindows = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[++i2];
        var pts = this.getPts(i2);
        this.flushDisplayed(pts, service);
        for (var winId = 0; winId < 8; winId++) {
          if (b & 1 << winId) {
            service.windows[winId].visible ^= 1;
          }
        }
        return i2;
      };
      Cea708Stream.prototype.clearWindows = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[++i2];
        var pts = this.getPts(i2);
        this.flushDisplayed(pts, service);
        for (var winId = 0; winId < 8; winId++) {
          if (b & 1 << winId) {
            service.windows[winId].clearText();
          }
        }
        return i2;
      };
      Cea708Stream.prototype.deleteWindows = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[++i2];
        var pts = this.getPts(i2);
        this.flushDisplayed(pts, service);
        for (var winId = 0; winId < 8; winId++) {
          if (b & 1 << winId) {
            service.windows[winId].reset();
          }
        }
        return i2;
      };
      Cea708Stream.prototype.setPenAttributes = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[i2];
        var penAttr = service.currentWindow.penAttr;
        b = packetData[++i2];
        penAttr.textTag = (b & 240) >> 4;
        penAttr.offset = (b & 12) >> 2;
        penAttr.penSize = b & 3;
        b = packetData[++i2];
        penAttr.italics = (b & 128) >> 7;
        penAttr.underline = (b & 64) >> 6;
        penAttr.edgeType = (b & 56) >> 3;
        penAttr.fontStyle = b & 7;
        return i2;
      };
      Cea708Stream.prototype.setPenColor = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[i2];
        var penColor = service.currentWindow.penColor;
        b = packetData[++i2];
        penColor.fgOpacity = (b & 192) >> 6;
        penColor.fgRed = (b & 48) >> 4;
        penColor.fgGreen = (b & 12) >> 2;
        penColor.fgBlue = b & 3;
        b = packetData[++i2];
        penColor.bgOpacity = (b & 192) >> 6;
        penColor.bgRed = (b & 48) >> 4;
        penColor.bgGreen = (b & 12) >> 2;
        penColor.bgBlue = b & 3;
        b = packetData[++i2];
        penColor.edgeRed = (b & 48) >> 4;
        penColor.edgeGreen = (b & 12) >> 2;
        penColor.edgeBlue = b & 3;
        return i2;
      };
      Cea708Stream.prototype.setPenLocation = function(i2, service) {
        var packetData = this.current708Packet.data;
        var b = packetData[i2];
        var penLoc = service.currentWindow.penLoc;
        service.currentWindow.pendingNewLine = true;
        b = packetData[++i2];
        penLoc.row = b & 15;
        b = packetData[++i2];
        penLoc.column = b & 63;
        return i2;
      };
      Cea708Stream.prototype.reset = function(i2, service) {
        var pts = this.getPts(i2);
        this.flushDisplayed(pts, service);
        return this.initService(service.serviceNum, i2);
      };
      var CHARACTER_TRANSLATION = {
        42: 225,
        92: 233,
        94: 237,
        95: 243,
        96: 250,
        123: 231,
        124: 247,
        125: 209,
        126: 241,
        127: 9608,
        304: 174,
        305: 176,
        306: 189,
        307: 191,
        308: 8482,
        309: 162,
        310: 163,
        311: 9834,
        312: 224,
        313: 160,
        314: 232,
        315: 226,
        316: 234,
        317: 238,
        318: 244,
        319: 251,
        544: 193,
        545: 201,
        546: 211,
        547: 218,
        548: 220,
        549: 252,
        550: 8216,
        551: 161,
        552: 42,
        553: 39,
        554: 8212,
        555: 169,
        556: 8480,
        557: 8226,
        558: 8220,
        559: 8221,
        560: 192,
        561: 194,
        562: 199,
        563: 200,
        564: 202,
        565: 203,
        566: 235,
        567: 206,
        568: 207,
        569: 239,
        570: 212,
        571: 217,
        572: 249,
        573: 219,
        574: 171,
        575: 187,
        800: 195,
        801: 227,
        802: 205,
        803: 204,
        804: 236,
        805: 210,
        806: 242,
        807: 213,
        808: 245,
        809: 123,
        810: 125,
        811: 92,
        812: 94,
        813: 95,
        814: 124,
        815: 126,
        816: 196,
        817: 228,
        818: 214,
        819: 246,
        820: 223,
        821: 165,
        822: 164,
        823: 9474,
        824: 197,
        825: 229,
        826: 216,
        827: 248,
        828: 9484,
        829: 9488,
        830: 9492,
        831: 9496
      };
      var getCharFromCode = function getCharFromCode2(code) {
        if (code === null) {
          return "";
        }
        code = CHARACTER_TRANSLATION[code] || code;
        return String.fromCharCode(code);
      };
      var BOTTOM_ROW = 14;
      var ROWS = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152];
      var createDisplayBuffer = function createDisplayBuffer2() {
        var result = [], i2 = BOTTOM_ROW + 1;
        while (i2--) {
          result.push("");
        }
        return result;
      };
      var Cea608Stream = function Cea608Stream2(field, dataChannel) {
        Cea608Stream2.prototype.init.call(this);
        this.field_ = field || 0;
        this.dataChannel_ = dataChannel || 0;
        this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
        this.setConstants();
        this.reset();
        this.push = function(packet) {
          var data, swap, char0, char1, text;
          data = packet.ccData & 32639;
          if (data === this.lastControlCode_) {
            this.lastControlCode_ = null;
            return;
          }
          if ((data & 61440) === 4096) {
            this.lastControlCode_ = data;
          } else if (data !== this.PADDING_) {
            this.lastControlCode_ = null;
          }
          char0 = data >>> 8;
          char1 = data & 255;
          if (data === this.PADDING_) {
            return;
          } else if (data === this.RESUME_CAPTION_LOADING_) {
            this.mode_ = "popOn";
          } else if (data === this.END_OF_CAPTION_) {
            this.mode_ = "popOn";
            this.clearFormatting(packet.pts);
            this.flushDisplayed(packet.pts);
            swap = this.displayed_;
            this.displayed_ = this.nonDisplayed_;
            this.nonDisplayed_ = swap;
            this.startPts_ = packet.pts;
          } else if (data === this.ROLL_UP_2_ROWS_) {
            this.rollUpRows_ = 2;
            this.setRollUp(packet.pts);
          } else if (data === this.ROLL_UP_3_ROWS_) {
            this.rollUpRows_ = 3;
            this.setRollUp(packet.pts);
          } else if (data === this.ROLL_UP_4_ROWS_) {
            this.rollUpRows_ = 4;
            this.setRollUp(packet.pts);
          } else if (data === this.CARRIAGE_RETURN_) {
            this.clearFormatting(packet.pts);
            this.flushDisplayed(packet.pts);
            this.shiftRowsUp_();
            this.startPts_ = packet.pts;
          } else if (data === this.BACKSPACE_) {
            if (this.mode_ === "popOn") {
              this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
            } else {
              this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
            }
          } else if (data === this.ERASE_DISPLAYED_MEMORY_) {
            this.flushDisplayed(packet.pts);
            this.displayed_ = createDisplayBuffer();
          } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {
            this.nonDisplayed_ = createDisplayBuffer();
          } else if (data === this.RESUME_DIRECT_CAPTIONING_) {
            if (this.mode_ !== "paintOn") {
              this.flushDisplayed(packet.pts);
              this.displayed_ = createDisplayBuffer();
            }
            this.mode_ = "paintOn";
            this.startPts_ = packet.pts;
          } else if (this.isSpecialCharacter(char0, char1)) {
            char0 = (char0 & 3) << 8;
            text = getCharFromCode(char0 | char1);
            this[this.mode_](packet.pts, text);
            this.column_++;
          } else if (this.isExtCharacter(char0, char1)) {
            if (this.mode_ === "popOn") {
              this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
            } else {
              this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
            }
            char0 = (char0 & 3) << 8;
            text = getCharFromCode(char0 | char1);
            this[this.mode_](packet.pts, text);
            this.column_++;
          } else if (this.isMidRowCode(char0, char1)) {
            this.clearFormatting(packet.pts);
            this[this.mode_](packet.pts, " ");
            this.column_++;
            if ((char1 & 14) === 14) {
              this.addFormatting(packet.pts, ["i"]);
            }
            if ((char1 & 1) === 1) {
              this.addFormatting(packet.pts, ["u"]);
            }
          } else if (this.isOffsetControlCode(char0, char1)) {
            this.column_ += char1 & 3;
          } else if (this.isPAC(char0, char1)) {
            var row = ROWS.indexOf(data & 7968);
            if (this.mode_ === "rollUp") {
              if (row - this.rollUpRows_ + 1 < 0) {
                row = this.rollUpRows_ - 1;
              }
              this.setRollUp(packet.pts, row);
            }
            if (row !== this.row_) {
              this.clearFormatting(packet.pts);
              this.row_ = row;
            }
            if (char1 & 1 && this.formatting_.indexOf("u") === -1) {
              this.addFormatting(packet.pts, ["u"]);
            }
            if ((data & 16) === 16) {
              this.column_ = ((data & 14) >> 1) * 4;
            }
            if (this.isColorPAC(char1)) {
              if ((char1 & 14) === 14) {
                this.addFormatting(packet.pts, ["i"]);
              }
            }
          } else if (this.isNormalChar(char0)) {
            if (char1 === 0) {
              char1 = null;
            }
            text = getCharFromCode(char0);
            text += getCharFromCode(char1);
            this[this.mode_](packet.pts, text);
            this.column_ += text.length;
          }
        };
      };
      Cea608Stream.prototype = new stream();
      Cea608Stream.prototype.flushDisplayed = function(pts) {
        var content = this.displayed_.map(function(row, index) {
          try {
            return row.trim();
          } catch (e) {
            this.trigger("log", {
              level: "warn",
              message: "Skipping a malformed 608 caption at index " + index + "."
            });
            return "";
          }
        }, this).join("\n").replace(/^\n+|\n+$/g, "");
        if (content.length) {
          this.trigger("data", {
            startPts: this.startPts_,
            endPts: pts,
            text: content,
            stream: this.name_
          });
        }
      };
      Cea608Stream.prototype.reset = function() {
        this.mode_ = "popOn";
        this.topRow_ = 0;
        this.startPts_ = 0;
        this.displayed_ = createDisplayBuffer();
        this.nonDisplayed_ = createDisplayBuffer();
        this.lastControlCode_ = null;
        this.column_ = 0;
        this.row_ = BOTTOM_ROW;
        this.rollUpRows_ = 2;
        this.formatting_ = [];
      };
      Cea608Stream.prototype.setConstants = function() {
        if (this.dataChannel_ === 0) {
          this.BASE_ = 16;
          this.EXT_ = 17;
          this.CONTROL_ = (20 | this.field_) << 8;
          this.OFFSET_ = 23;
        } else if (this.dataChannel_ === 1) {
          this.BASE_ = 24;
          this.EXT_ = 25;
          this.CONTROL_ = (28 | this.field_) << 8;
          this.OFFSET_ = 31;
        }
        this.PADDING_ = 0;
        this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
        this.END_OF_CAPTION_ = this.CONTROL_ | 47;
        this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
        this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
        this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
        this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
        this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
        this.BACKSPACE_ = this.CONTROL_ | 33;
        this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
        this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
      };
      Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
        return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
      };
      Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
        return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
      };
      Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
        return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
      };
      Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
        return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
      };
      Cea608Stream.prototype.isPAC = function(char0, char1) {
        return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
      };
      Cea608Stream.prototype.isColorPAC = function(char1) {
        return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
      };
      Cea608Stream.prototype.isNormalChar = function(_char2) {
        return _char2 >= 32 && _char2 <= 127;
      };
      Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
        if (this.mode_ !== "rollUp") {
          this.row_ = BOTTOM_ROW;
          this.mode_ = "rollUp";
          this.flushDisplayed(pts);
          this.nonDisplayed_ = createDisplayBuffer();
          this.displayed_ = createDisplayBuffer();
        }
        if (newBaseRow !== void 0 && newBaseRow !== this.row_) {
          for (var i2 = 0; i2 < this.rollUpRows_; i2++) {
            this.displayed_[newBaseRow - i2] = this.displayed_[this.row_ - i2];
            this.displayed_[this.row_ - i2] = "";
          }
        }
        if (newBaseRow === void 0) {
          newBaseRow = this.row_;
        }
        this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
      };
      Cea608Stream.prototype.addFormatting = function(pts, format) {
        this.formatting_ = this.formatting_.concat(format);
        var text = format.reduce(function(text2, format2) {
          return text2 + "<" + format2 + ">";
        }, "");
        this[this.mode_](pts, text);
      };
      Cea608Stream.prototype.clearFormatting = function(pts) {
        if (!this.formatting_.length) {
          return;
        }
        var text = this.formatting_.reverse().reduce(function(text2, format) {
          return text2 + "</" + format + ">";
        }, "");
        this.formatting_ = [];
        this[this.mode_](pts, text);
      };
      Cea608Stream.prototype.popOn = function(pts, text) {
        var baseRow = this.nonDisplayed_[this.row_];
        baseRow += text;
        this.nonDisplayed_[this.row_] = baseRow;
      };
      Cea608Stream.prototype.rollUp = function(pts, text) {
        var baseRow = this.displayed_[this.row_];
        baseRow += text;
        this.displayed_[this.row_] = baseRow;
      };
      Cea608Stream.prototype.shiftRowsUp_ = function() {
        var i2;
        for (i2 = 0; i2 < this.topRow_; i2++) {
          this.displayed_[i2] = "";
        }
        for (i2 = this.row_ + 1; i2 < BOTTOM_ROW + 1; i2++) {
          this.displayed_[i2] = "";
        }
        for (i2 = this.topRow_; i2 < this.row_; i2++) {
          this.displayed_[i2] = this.displayed_[i2 + 1];
        }
        this.displayed_[this.row_] = "";
      };
      Cea608Stream.prototype.paintOn = function(pts, text) {
        var baseRow = this.displayed_[this.row_];
        baseRow += text;
        this.displayed_[this.row_] = baseRow;
      };
      var captionStream = {
        CaptionStream: CaptionStream$1,
        Cea608Stream,
        Cea708Stream
      };
      var streamTypes = {
        H264_STREAM_TYPE: 27,
        ADTS_STREAM_TYPE: 15,
        METADATA_STREAM_TYPE: 21
      };
      var MAX_TS = 8589934592;
      var RO_THRESH = 4294967296;
      var TYPE_SHARED = "shared";
      var handleRollover$1 = function handleRollover2(value, reference) {
        var direction = 1;
        if (value > reference) {
          direction = -1;
        }
        while (Math.abs(reference - value) > RO_THRESH) {
          value += direction * MAX_TS;
        }
        return value;
      };
      var TimestampRolloverStream$1 = function TimestampRolloverStream2(type2) {
        var lastDTS, referenceDTS;
        TimestampRolloverStream2.prototype.init.call(this);
        this.type_ = type2 || TYPE_SHARED;
        this.push = function(data) {
          if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {
            return;
          }
          if (referenceDTS === void 0) {
            referenceDTS = data.dts;
          }
          data.dts = handleRollover$1(data.dts, referenceDTS);
          data.pts = handleRollover$1(data.pts, referenceDTS);
          lastDTS = data.dts;
          this.trigger("data", data);
        };
        this.flush = function() {
          referenceDTS = lastDTS;
          this.trigger("done");
        };
        this.endTimeline = function() {
          this.flush();
          this.trigger("endedtimeline");
        };
        this.discontinuity = function() {
          referenceDTS = void 0;
          lastDTS = void 0;
        };
        this.reset = function() {
          this.discontinuity();
          this.trigger("reset");
        };
      };
      TimestampRolloverStream$1.prototype = new stream();
      var timestampRolloverStream = {
        TimestampRolloverStream: TimestampRolloverStream$1,
        handleRollover: handleRollover$1
      };
      var percentEncode$1 = function percentEncode2(bytes, start2, end2) {
        var i2, result = "";
        for (i2 = start2; i2 < end2; i2++) {
          result += "%" + ("00" + bytes[i2].toString(16)).slice(-2);
        }
        return result;
      }, parseUtf8 = function parseUtf82(bytes, start2, end2) {
        return decodeURIComponent(percentEncode$1(bytes, start2, end2));
      }, parseIso88591$1 = function parseIso885912(bytes, start2, end2) {
        return unescape(percentEncode$1(bytes, start2, end2));
      }, parseSyncSafeInteger$1 = function parseSyncSafeInteger2(data) {
        return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
      }, tagParsers = {
        TXXX: function TXXX(tag) {
          var i2;
          if (tag.data[0] !== 3) {
            return;
          }
          for (i2 = 1; i2 < tag.data.length; i2++) {
            if (tag.data[i2] === 0) {
              tag.description = parseUtf8(tag.data, 1, i2);
              tag.value = parseUtf8(tag.data, i2 + 1, tag.data.length).replace(/\0*$/, "");
              break;
            }
          }
          tag.data = tag.value;
        },
        WXXX: function WXXX(tag) {
          var i2;
          if (tag.data[0] !== 3) {
            return;
          }
          for (i2 = 1; i2 < tag.data.length; i2++) {
            if (tag.data[i2] === 0) {
              tag.description = parseUtf8(tag.data, 1, i2);
              tag.url = parseUtf8(tag.data, i2 + 1, tag.data.length);
              break;
            }
          }
        },
        PRIV: function PRIV(tag) {
          var i2;
          for (i2 = 0; i2 < tag.data.length; i2++) {
            if (tag.data[i2] === 0) {
              tag.owner = parseIso88591$1(tag.data, 0, i2);
              break;
            }
          }
          tag.privateData = tag.data.subarray(i2 + 1);
          tag.data = tag.privateData;
        }
      }, _MetadataStream;
      _MetadataStream = function MetadataStream(options) {
        var settings2 = {
          descriptor: options && options.descriptor
        }, tagSize = 0, buffer = [], bufferSize = 0, i2;
        _MetadataStream.prototype.init.call(this);
        this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);
        if (settings2.descriptor) {
          for (i2 = 0; i2 < settings2.descriptor.length; i2++) {
            this.dispatchType += ("00" + settings2.descriptor[i2].toString(16)).slice(-2);
          }
        }
        this.push = function(chunk) {
          var tag, frameStart, frameSize, frame, i3, frameHeader;
          if (chunk.type !== "timed-metadata") {
            return;
          }
          if (chunk.dataAlignmentIndicator) {
            bufferSize = 0;
            buffer.length = 0;
          }
          if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
            this.trigger("log", {
              level: "warn",
              message: "Skipping unrecognized metadata packet"
            });
            return;
          }
          buffer.push(chunk);
          bufferSize += chunk.data.byteLength;
          if (buffer.length === 1) {
            tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10));
            tagSize += 10;
          }
          if (bufferSize < tagSize) {
            return;
          }
          tag = {
            data: new Uint8Array(tagSize),
            frames: [],
            pts: buffer[0].pts,
            dts: buffer[0].dts
          };
          for (i3 = 0; i3 < tagSize; ) {
            tag.data.set(buffer[0].data.subarray(0, tagSize - i3), i3);
            i3 += buffer[0].data.byteLength;
            bufferSize -= buffer[0].data.byteLength;
            buffer.shift();
          }
          frameStart = 10;
          if (tag.data[5] & 64) {
            frameStart += 4;
            frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14));
            tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));
          }
          do {
            frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));
            if (frameSize < 1) {
              this.trigger("log", {
                level: "warn",
                message: "Malformed ID3 frame encountered. Skipping metadata parsing."
              });
              return;
            }
            frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
            frame = {
              id: frameHeader,
              data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
            };
            frame.key = frame.id;
            if (tagParsers[frame.id]) {
              tagParsers[frame.id](frame);
              if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
                var d = frame.data, size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                size *= 4;
                size += d[7] & 3;
                frame.timeStamp = size;
                if (tag.pts === void 0 && tag.dts === void 0) {
                  tag.pts = frame.timeStamp;
                  tag.dts = frame.timeStamp;
                }
                this.trigger("timestamp", frame);
              }
            }
            tag.frames.push(frame);
            frameStart += 10;
            frameStart += frameSize;
          } while (frameStart < tagSize);
          this.trigger("data", tag);
        };
      };
      _MetadataStream.prototype = new stream();
      var metadataStream = _MetadataStream;
      var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
      var _TransportPacketStream, _TransportParseStream, _ElementaryStream;
      var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
      _TransportPacketStream = function TransportPacketStream() {
        var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
        _TransportPacketStream.prototype.init.call(this);
        this.push = function(bytes) {
          var startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1, everything;
          if (bytesInBuffer) {
            everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
            everything.set(buffer.subarray(0, bytesInBuffer));
            everything.set(bytes, bytesInBuffer);
            bytesInBuffer = 0;
          } else {
            everything = bytes;
          }
          while (endIndex < everything.byteLength) {
            if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
              this.trigger("data", everything.subarray(startIndex, endIndex));
              startIndex += MP2T_PACKET_LENGTH$1;
              endIndex += MP2T_PACKET_LENGTH$1;
              continue;
            }
            startIndex++;
            endIndex++;
          }
          if (startIndex < everything.byteLength) {
            buffer.set(everything.subarray(startIndex), 0);
            bytesInBuffer = everything.byteLength - startIndex;
          }
        };
        this.flush = function() {
          if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
            this.trigger("data", buffer);
            bytesInBuffer = 0;
          }
          this.trigger("done");
        };
        this.endTimeline = function() {
          this.flush();
          this.trigger("endedtimeline");
        };
        this.reset = function() {
          bytesInBuffer = 0;
          this.trigger("reset");
        };
      };
      _TransportPacketStream.prototype = new stream();
      _TransportParseStream = function TransportParseStream() {
        var parsePsi, parsePat2, parsePmt2, self2;
        _TransportParseStream.prototype.init.call(this);
        self2 = this;
        this.packetsWaitingForPmt = [];
        this.programMapTable = void 0;
        parsePsi = function parsePsi2(payload, psi) {
          var offset = 0;
          if (psi.payloadUnitStartIndicator) {
            offset += payload[offset] + 1;
          }
          if (psi.type === "pat") {
            parsePat2(payload.subarray(offset), psi);
          } else {
            parsePmt2(payload.subarray(offset), psi);
          }
        };
        parsePat2 = function parsePat3(payload, pat) {
          pat.section_number = payload[7];
          pat.last_section_number = payload[8];
          self2.pmtPid = (payload[10] & 31) << 8 | payload[11];
          pat.pmtPid = self2.pmtPid;
        };
        parsePmt2 = function parsePmt3(payload, pmt) {
          var sectionLength, tableEnd, programInfoLength, offset;
          if (!(payload[5] & 1)) {
            return;
          }
          self2.programMapTable = {
            video: null,
            audio: null,
            "timed-metadata": {}
          };
          sectionLength = (payload[1] & 15) << 8 | payload[2];
          tableEnd = 3 + sectionLength - 4;
          programInfoLength = (payload[10] & 15) << 8 | payload[11];
          offset = 12 + programInfoLength;
          while (offset < tableEnd) {
            var streamType = payload[offset];
            var pid = (payload[offset + 1] & 31) << 8 | payload[offset + 2];
            if (streamType === streamTypes.H264_STREAM_TYPE && self2.programMapTable.video === null) {
              self2.programMapTable.video = pid;
            } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self2.programMapTable.audio === null) {
              self2.programMapTable.audio = pid;
            } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {
              self2.programMapTable["timed-metadata"][pid] = streamType;
            }
            offset += ((payload[offset + 3] & 15) << 8 | payload[offset + 4]) + 5;
          }
          pmt.programMapTable = self2.programMapTable;
        };
        this.push = function(packet) {
          var result = {}, offset = 4;
          result.payloadUnitStartIndicator = !!(packet[1] & 64);
          result.pid = packet[1] & 31;
          result.pid <<= 8;
          result.pid |= packet[2];
          if ((packet[3] & 48) >>> 4 > 1) {
            offset += packet[offset] + 1;
          }
          if (result.pid === 0) {
            result.type = "pat";
            parsePsi(packet.subarray(offset), result);
            this.trigger("data", result);
          } else if (result.pid === this.pmtPid) {
            result.type = "pmt";
            parsePsi(packet.subarray(offset), result);
            this.trigger("data", result);
            while (this.packetsWaitingForPmt.length) {
              this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
            }
          } else if (this.programMapTable === void 0) {
            this.packetsWaitingForPmt.push([packet, offset, result]);
          } else {
            this.processPes_(packet, offset, result);
          }
        };
        this.processPes_ = function(packet, offset, result) {
          if (result.pid === this.programMapTable.video) {
            result.streamType = streamTypes.H264_STREAM_TYPE;
          } else if (result.pid === this.programMapTable.audio) {
            result.streamType = streamTypes.ADTS_STREAM_TYPE;
          } else {
            result.streamType = this.programMapTable["timed-metadata"][result.pid];
          }
          result.type = "pes";
          result.data = packet.subarray(offset);
          this.trigger("data", result);
        };
      };
      _TransportParseStream.prototype = new stream();
      _TransportParseStream.STREAM_TYPES = {
        h264: 27,
        adts: 15
      };
      _ElementaryStream = function ElementaryStream() {
        var self2 = this, segmentHadPmt = false, video = {
          data: [],
          size: 0
        }, audio = {
          data: [],
          size: 0
        }, timedMetadata = {
          data: [],
          size: 0
        }, programMapTable, parsePes = function parsePes2(payload, pes) {
          var ptsDtsFlags;
          var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
          pes.data = new Uint8Array();
          if (startPrefix !== 1) {
            return;
          }
          pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
          pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
          ptsDtsFlags = payload[7];
          if (ptsDtsFlags & 192) {
            pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
            pes.pts *= 4;
            pes.pts += (payload[13] & 6) >>> 1;
            pes.dts = pes.pts;
            if (ptsDtsFlags & 64) {
              pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
              pes.dts *= 4;
              pes.dts += (payload[18] & 6) >>> 1;
            }
          }
          pes.data = payload.subarray(9 + payload[8]);
        }, flushStream = function flushStream2(stream2, type2, forceFlush) {
          var packetData = new Uint8Array(stream2.size), event2 = {
            type: type2
          }, i2 = 0, offset = 0, packetFlushable = false, fragment;
          if (!stream2.data.length || stream2.size < 9) {
            return;
          }
          event2.trackId = stream2.data[0].pid;
          for (i2 = 0; i2 < stream2.data.length; i2++) {
            fragment = stream2.data[i2];
            packetData.set(fragment.data, offset);
            offset += fragment.data.byteLength;
          }
          parsePes(packetData, event2);
          packetFlushable = type2 === "video" || event2.packetLength <= stream2.size;
          if (forceFlush || packetFlushable) {
            stream2.size = 0;
            stream2.data.length = 0;
          }
          if (packetFlushable) {
            self2.trigger("data", event2);
          }
        };
        _ElementaryStream.prototype.init.call(this);
        this.push = function(data) {
          ({
            pat: function pat() {
            },
            pes: function pes() {
              var stream2, streamType;
              switch (data.streamType) {
                case streamTypes.H264_STREAM_TYPE:
                  stream2 = video;
                  streamType = "video";
                  break;
                case streamTypes.ADTS_STREAM_TYPE:
                  stream2 = audio;
                  streamType = "audio";
                  break;
                case streamTypes.METADATA_STREAM_TYPE:
                  stream2 = timedMetadata;
                  streamType = "timed-metadata";
                  break;
                default:
                  return;
              }
              if (data.payloadUnitStartIndicator) {
                flushStream(stream2, streamType, true);
              }
              stream2.data.push(data);
              stream2.size += data.data.byteLength;
            },
            pmt: function pmt() {
              var event2 = {
                type: "metadata",
                tracks: []
              };
              programMapTable = data.programMapTable;
              if (programMapTable.video !== null) {
                event2.tracks.push({
                  timelineStartInfo: {
                    baseMediaDecodeTime: 0
                  },
                  id: +programMapTable.video,
                  codec: "avc",
                  type: "video"
                });
              }
              if (programMapTable.audio !== null) {
                event2.tracks.push({
                  timelineStartInfo: {
                    baseMediaDecodeTime: 0
                  },
                  id: +programMapTable.audio,
                  codec: "adts",
                  type: "audio"
                });
              }
              segmentHadPmt = true;
              self2.trigger("data", event2);
            }
          })[data.type]();
        };
        this.reset = function() {
          video.size = 0;
          video.data.length = 0;
          audio.size = 0;
          audio.data.length = 0;
          this.trigger("reset");
        };
        this.flushStreams_ = function() {
          flushStream(video, "video");
          flushStream(audio, "audio");
          flushStream(timedMetadata, "timed-metadata");
        };
        this.flush = function() {
          if (!segmentHadPmt && programMapTable) {
            var pmt = {
              type: "metadata",
              tracks: []
            };
            if (programMapTable.video !== null) {
              pmt.tracks.push({
                timelineStartInfo: {
                  baseMediaDecodeTime: 0
                },
                id: +programMapTable.video,
                codec: "avc",
                type: "video"
              });
            }
            if (programMapTable.audio !== null) {
              pmt.tracks.push({
                timelineStartInfo: {
                  baseMediaDecodeTime: 0
                },
                id: +programMapTable.audio,
                codec: "adts",
                type: "audio"
              });
            }
            self2.trigger("data", pmt);
          }
          segmentHadPmt = false;
          this.flushStreams_();
          this.trigger("done");
        };
      };
      _ElementaryStream.prototype = new stream();
      var m2ts = {
        PAT_PID: 0,
        MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
        TransportPacketStream: _TransportPacketStream,
        TransportParseStream: _TransportParseStream,
        ElementaryStream: _ElementaryStream,
        TimestampRolloverStream,
        CaptionStream: captionStream.CaptionStream,
        Cea608Stream: captionStream.Cea608Stream,
        Cea708Stream: captionStream.Cea708Stream,
        MetadataStream: metadataStream
      };
      for (var type in streamTypes) {
        if (streamTypes.hasOwnProperty(type)) {
          m2ts[type] = streamTypes[type];
        }
      }
      var m2ts_1 = m2ts;
      var ONE_SECOND_IN_TS$2 = clock2.ONE_SECOND_IN_TS;
      var _AdtsStream;
      var ADTS_SAMPLING_FREQUENCIES$1 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
      _AdtsStream = function AdtsStream(handlePartialSegments) {
        var buffer, frameNum = 0;
        _AdtsStream.prototype.init.call(this);
        this.skipWarn_ = function(start2, end2) {
          this.trigger("log", {
            level: "warn",
            message: "adts skiping bytes " + start2 + " to " + end2 + " in frame " + frameNum + " outside syncword"
          });
        };
        this.push = function(packet) {
          var i2 = 0, frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration;
          if (!handlePartialSegments) {
            frameNum = 0;
          }
          if (packet.type !== "audio") {
            return;
          }
          if (buffer && buffer.length) {
            oldBuffer = buffer;
            buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
            buffer.set(oldBuffer);
            buffer.set(packet.data, oldBuffer.byteLength);
          } else {
            buffer = packet.data;
          }
          var skip;
          while (i2 + 7 < buffer.length) {
            if (buffer[i2] !== 255 || (buffer[i2 + 1] & 246) !== 240) {
              if (typeof skip !== "number") {
                skip = i2;
              }
              i2++;
              continue;
            }
            if (typeof skip === "number") {
              this.skipWarn_(skip, i2);
              skip = null;
            }
            protectionSkipBytes = (~buffer[i2 + 1] & 1) * 2;
            frameLength = (buffer[i2 + 3] & 3) << 11 | buffer[i2 + 4] << 3 | (buffer[i2 + 5] & 224) >> 5;
            sampleCount = ((buffer[i2 + 6] & 3) + 1) * 1024;
            adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i2 + 2] & 60) >>> 2];
            if (buffer.byteLength - i2 < frameLength) {
              break;
            }
            this.trigger("data", {
              pts: packet.pts + frameNum * adtsFrameDuration,
              dts: packet.dts + frameNum * adtsFrameDuration,
              sampleCount,
              audioobjecttype: (buffer[i2 + 2] >>> 6 & 3) + 1,
              channelcount: (buffer[i2 + 2] & 1) << 2 | (buffer[i2 + 3] & 192) >>> 6,
              samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i2 + 2] & 60) >>> 2],
              samplingfrequencyindex: (buffer[i2 + 2] & 60) >>> 2,
              samplesize: 16,
              data: buffer.subarray(i2 + 7 + protectionSkipBytes, i2 + frameLength)
            });
            frameNum++;
            i2 += frameLength;
          }
          if (typeof skip === "number") {
            this.skipWarn_(skip, i2);
            skip = null;
          }
          buffer = buffer.subarray(i2);
        };
        this.flush = function() {
          frameNum = 0;
          this.trigger("done");
        };
        this.reset = function() {
          buffer = void 0;
          this.trigger("reset");
        };
        this.endTimeline = function() {
          buffer = void 0;
          this.trigger("endedtimeline");
        };
      };
      _AdtsStream.prototype = new stream();
      var adts = _AdtsStream;
      var ExpGolomb;
      ExpGolomb = function ExpGolomb2(workingData) {
        var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
        this.length = function() {
          return 8 * workingBytesAvailable;
        };
        this.bitsAvailable = function() {
          return 8 * workingBytesAvailable + workingBitsAvailable;
        };
        this.loadWord = function() {
          var position = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
          if (availableBytes === 0) {
            throw new Error("no bytes available");
          }
          workingBytes.set(workingData.subarray(position, position + availableBytes));
          workingWord = new DataView(workingBytes.buffer).getUint32(0);
          workingBitsAvailable = availableBytes * 8;
          workingBytesAvailable -= availableBytes;
        };
        this.skipBits = function(count) {
          var skipBytes;
          if (workingBitsAvailable > count) {
            workingWord <<= count;
            workingBitsAvailable -= count;
          } else {
            count -= workingBitsAvailable;
            skipBytes = Math.floor(count / 8);
            count -= skipBytes * 8;
            workingBytesAvailable -= skipBytes;
            this.loadWord();
            workingWord <<= count;
            workingBitsAvailable -= count;
          }
        };
        this.readBits = function(size) {
          var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
          workingBitsAvailable -= bits;
          if (workingBitsAvailable > 0) {
            workingWord <<= bits;
          } else if (workingBytesAvailable > 0) {
            this.loadWord();
          }
          bits = size - bits;
          if (bits > 0) {
            return valu << bits | this.readBits(bits);
          }
          return valu;
        };
        this.skipLeadingZeros = function() {
          var leadingZeroCount;
          for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {
            if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
              workingWord <<= leadingZeroCount;
              workingBitsAvailable -= leadingZeroCount;
              return leadingZeroCount;
            }
          }
          this.loadWord();
          return leadingZeroCount + this.skipLeadingZeros();
        };
        this.skipUnsignedExpGolomb = function() {
          this.skipBits(1 + this.skipLeadingZeros());
        };
        this.skipExpGolomb = function() {
          this.skipBits(1 + this.skipLeadingZeros());
        };
        this.readUnsignedExpGolomb = function() {
          var clz = this.skipLeadingZeros();
          return this.readBits(clz + 1) - 1;
        };
        this.readExpGolomb = function() {
          var valu = this.readUnsignedExpGolomb();
          if (1 & valu) {
            return 1 + valu >>> 1;
          }
          return -1 * (valu >>> 1);
        };
        this.readBoolean = function() {
          return this.readBits(1) === 1;
        };
        this.readUnsignedByte = function() {
          return this.readBits(8);
        };
        this.loadWord();
      };
      var expGolomb = ExpGolomb;
      var _H264Stream, _NalByteStream;
      var PROFILES_WITH_OPTIONAL_SPS_DATA;
      _NalByteStream = function NalByteStream() {
        var syncPoint = 0, i2, buffer;
        _NalByteStream.prototype.init.call(this);
        this.push = function(data) {
          var swapBuffer;
          if (!buffer) {
            buffer = data.data;
          } else {
            swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
            swapBuffer.set(buffer);
            swapBuffer.set(data.data, buffer.byteLength);
            buffer = swapBuffer;
          }
          var len = buffer.byteLength;
          for (; syncPoint < len - 3; syncPoint++) {
            if (buffer[syncPoint + 2] === 1) {
              i2 = syncPoint + 5;
              break;
            }
          }
          while (i2 < len) {
            switch (buffer[i2]) {
              case 0:
                if (buffer[i2 - 1] !== 0) {
                  i2 += 2;
                  break;
                } else if (buffer[i2 - 2] !== 0) {
                  i2++;
                  break;
                }
                if (syncPoint + 3 !== i2 - 2) {
                  this.trigger("data", buffer.subarray(syncPoint + 3, i2 - 2));
                }
                do {
                  i2++;
                } while (buffer[i2] !== 1 && i2 < len);
                syncPoint = i2 - 2;
                i2 += 3;
                break;
              case 1:
                if (buffer[i2 - 1] !== 0 || buffer[i2 - 2] !== 0) {
                  i2 += 3;
                  break;
                }
                this.trigger("data", buffer.subarray(syncPoint + 3, i2 - 2));
                syncPoint = i2 - 2;
                i2 += 3;
                break;
              default:
                i2 += 3;
                break;
            }
          }
          buffer = buffer.subarray(syncPoint);
          i2 -= syncPoint;
          syncPoint = 0;
        };
        this.reset = function() {
          buffer = null;
          syncPoint = 0;
          this.trigger("reset");
        };
        this.flush = function() {
          if (buffer && buffer.byteLength > 3) {
            this.trigger("data", buffer.subarray(syncPoint + 3));
          }
          buffer = null;
          syncPoint = 0;
          this.trigger("done");
        };
        this.endTimeline = function() {
          this.flush();
          this.trigger("endedtimeline");
        };
      };
      _NalByteStream.prototype = new stream();
      PROFILES_WITH_OPTIONAL_SPS_DATA = {
        100: true,
        110: true,
        122: true,
        244: true,
        44: true,
        83: true,
        86: true,
        118: true,
        128: true,
        138: true,
        139: true,
        134: true
      };
      _H264Stream = function H264Stream2() {
        var nalByteStream = new _NalByteStream(), self2, trackId, currentPts, currentDts, discardEmulationPreventionBytes2, readSequenceParameterSet, skipScalingList;
        _H264Stream.prototype.init.call(this);
        self2 = this;
        this.push = function(packet) {
          if (packet.type !== "video") {
            return;
          }
          trackId = packet.trackId;
          currentPts = packet.pts;
          currentDts = packet.dts;
          nalByteStream.push(packet);
        };
        nalByteStream.on("data", function(data) {
          var event2 = {
            trackId,
            pts: currentPts,
            dts: currentDts,
            data,
            nalUnitTypeCode: data[0] & 31
          };
          switch (event2.nalUnitTypeCode) {
            case 5:
              event2.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
              break;
            case 6:
              event2.nalUnitType = "sei_rbsp";
              event2.escapedRBSP = discardEmulationPreventionBytes2(data.subarray(1));
              break;
            case 7:
              event2.nalUnitType = "seq_parameter_set_rbsp";
              event2.escapedRBSP = discardEmulationPreventionBytes2(data.subarray(1));
              event2.config = readSequenceParameterSet(event2.escapedRBSP);
              break;
            case 8:
              event2.nalUnitType = "pic_parameter_set_rbsp";
              break;
            case 9:
              event2.nalUnitType = "access_unit_delimiter_rbsp";
              break;
          }
          self2.trigger("data", event2);
        });
        nalByteStream.on("done", function() {
          self2.trigger("done");
        });
        nalByteStream.on("partialdone", function() {
          self2.trigger("partialdone");
        });
        nalByteStream.on("reset", function() {
          self2.trigger("reset");
        });
        nalByteStream.on("endedtimeline", function() {
          self2.trigger("endedtimeline");
        });
        this.flush = function() {
          nalByteStream.flush();
        };
        this.partialFlush = function() {
          nalByteStream.partialFlush();
        };
        this.reset = function() {
          nalByteStream.reset();
        };
        this.endTimeline = function() {
          nalByteStream.endTimeline();
        };
        skipScalingList = function skipScalingList2(count, expGolombDecoder) {
          var lastScale = 8, nextScale = 8, j, deltaScale;
          for (j = 0; j < count; j++) {
            if (nextScale !== 0) {
              deltaScale = expGolombDecoder.readExpGolomb();
              nextScale = (lastScale + deltaScale + 256) % 256;
            }
            lastScale = nextScale === 0 ? lastScale : nextScale;
          }
        };
        discardEmulationPreventionBytes2 = function discardEmulationPreventionBytes3(data) {
          var length = data.byteLength, emulationPreventionBytesPositions = [], i2 = 1, newLength, newData;
          while (i2 < length - 2) {
            if (data[i2] === 0 && data[i2 + 1] === 0 && data[i2 + 2] === 3) {
              emulationPreventionBytesPositions.push(i2 + 2);
              i2 += 2;
            } else {
              i2++;
            }
          }
          if (emulationPreventionBytesPositions.length === 0) {
            return data;
          }
          newLength = length - emulationPreventionBytesPositions.length;
          newData = new Uint8Array(newLength);
          var sourceIndex = 0;
          for (i2 = 0; i2 < newLength; sourceIndex++, i2++) {
            if (sourceIndex === emulationPreventionBytesPositions[0]) {
              sourceIndex++;
              emulationPreventionBytesPositions.shift();
            }
            newData[i2] = data[sourceIndex];
          }
          return newData;
        };
        readSequenceParameterSet = function readSequenceParameterSet2(data) {
          var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, sarRatio = [1, 1], aspectRatioIdc, i2;
          expGolombDecoder = new expGolomb(data);
          profileIdc = expGolombDecoder.readUnsignedByte();
          profileCompatibility = expGolombDecoder.readUnsignedByte();
          levelIdc = expGolombDecoder.readUnsignedByte();
          expGolombDecoder.skipUnsignedExpGolomb();
          if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
            chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
            if (chromaFormatIdc === 3) {
              expGolombDecoder.skipBits(1);
            }
            expGolombDecoder.skipUnsignedExpGolomb();
            expGolombDecoder.skipUnsignedExpGolomb();
            expGolombDecoder.skipBits(1);
            if (expGolombDecoder.readBoolean()) {
              scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
              for (i2 = 0; i2 < scalingListCount; i2++) {
                if (expGolombDecoder.readBoolean()) {
                  if (i2 < 6) {
                    skipScalingList(16, expGolombDecoder);
                  } else {
                    skipScalingList(64, expGolombDecoder);
                  }
                }
              }
            }
          }
          expGolombDecoder.skipUnsignedExpGolomb();
          picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
          if (picOrderCntType === 0) {
            expGolombDecoder.readUnsignedExpGolomb();
          } else if (picOrderCntType === 1) {
            expGolombDecoder.skipBits(1);
            expGolombDecoder.skipExpGolomb();
            expGolombDecoder.skipExpGolomb();
            numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
            for (i2 = 0; i2 < numRefFramesInPicOrderCntCycle; i2++) {
              expGolombDecoder.skipExpGolomb();
            }
          }
          expGolombDecoder.skipUnsignedExpGolomb();
          expGolombDecoder.skipBits(1);
          picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
          picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
          frameMbsOnlyFlag = expGolombDecoder.readBits(1);
          if (frameMbsOnlyFlag === 0) {
            expGolombDecoder.skipBits(1);
          }
          expGolombDecoder.skipBits(1);
          if (expGolombDecoder.readBoolean()) {
            frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
            frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
            frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
            frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
          }
          if (expGolombDecoder.readBoolean()) {
            if (expGolombDecoder.readBoolean()) {
              aspectRatioIdc = expGolombDecoder.readUnsignedByte();
              switch (aspectRatioIdc) {
                case 1:
                  sarRatio = [1, 1];
                  break;
                case 2:
                  sarRatio = [12, 11];
                  break;
                case 3:
                  sarRatio = [10, 11];
                  break;
                case 4:
                  sarRatio = [16, 11];
                  break;
                case 5:
                  sarRatio = [40, 33];
                  break;
                case 6:
                  sarRatio = [24, 11];
                  break;
                case 7:
                  sarRatio = [20, 11];
                  break;
                case 8:
                  sarRatio = [32, 11];
                  break;
                case 9:
                  sarRatio = [80, 33];
                  break;
                case 10:
                  sarRatio = [18, 11];
                  break;
                case 11:
                  sarRatio = [15, 11];
                  break;
                case 12:
                  sarRatio = [64, 33];
                  break;
                case 13:
                  sarRatio = [160, 99];
                  break;
                case 14:
                  sarRatio = [4, 3];
                  break;
                case 15:
                  sarRatio = [3, 2];
                  break;
                case 16:
                  sarRatio = [2, 1];
                  break;
                case 255: {
                  sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];
                  break;
                }
              }
              if (sarRatio) {
                sarRatio[0] / sarRatio[1];
              }
            }
          }
          return {
            profileIdc,
            levelIdc,
            profileCompatibility,
            width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
            height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
            sarRatio
          };
        };
      };
      _H264Stream.prototype = new stream();
      var h264 = {
        H264Stream: _H264Stream,
        NalByteStream: _NalByteStream
      };
      var ADTS_SAMPLING_FREQUENCIES = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
      var parseId3TagSize = function parseId3TagSize2(header, byteIndex) {
        var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
        returnSize = returnSize >= 0 ? returnSize : 0;
        if (footerPresent) {
          return returnSize + 20;
        }
        return returnSize + 10;
      };
      var getId3Offset = function getId3Offset2(data, offset) {
        if (data.length - offset < 10 || data[offset] !== "I".charCodeAt(0) || data[offset + 1] !== "D".charCodeAt(0) || data[offset + 2] !== "3".charCodeAt(0)) {
          return offset;
        }
        offset += parseId3TagSize(data, offset);
        return getId3Offset2(data, offset);
      };
      var isLikelyAacData$1 = function isLikelyAacData2(data) {
        var offset = getId3Offset(data, 0);
        return data.length >= offset + 2 && (data[offset] & 255) === 255 && (data[offset + 1] & 240) === 240 && (data[offset + 1] & 22) === 16;
      };
      var parseSyncSafeInteger = function parseSyncSafeInteger2(data) {
        return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
      };
      var percentEncode = function percentEncode2(bytes, start2, end2) {
        var i2, result = "";
        for (i2 = start2; i2 < end2; i2++) {
          result += "%" + ("00" + bytes[i2].toString(16)).slice(-2);
        }
        return result;
      };
      var parseIso88591 = function parseIso885912(bytes, start2, end2) {
        return unescape(percentEncode(bytes, start2, end2));
      };
      var parseAdtsSize = function parseAdtsSize2(header, byteIndex) {
        var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
        return highTwo | middle | lowThree;
      };
      var parseType$2 = function parseType2(header, byteIndex) {
        if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) {
          return "timed-metadata";
        } else if (header[byteIndex] & true && (header[byteIndex + 1] & 240) === 240) {
          return "audio";
        }
        return null;
      };
      var parseSampleRate = function parseSampleRate2(packet) {
        var i2 = 0;
        while (i2 + 5 < packet.length) {
          if (packet[i2] !== 255 || (packet[i2 + 1] & 246) !== 240) {
            i2++;
            continue;
          }
          return ADTS_SAMPLING_FREQUENCIES[(packet[i2 + 2] & 60) >>> 2];
        }
        return null;
      };
      var parseAacTimestamp = function parseAacTimestamp2(packet) {
        var frameStart, frameSize, frame, frameHeader;
        frameStart = 10;
        if (packet[5] & 64) {
          frameStart += 4;
          frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
        }
        do {
          frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
          if (frameSize < 1) {
            return null;
          }
          frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
          if (frameHeader === "PRIV") {
            frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
            for (var i2 = 0; i2 < frame.byteLength; i2++) {
              if (frame[i2] === 0) {
                var owner = parseIso88591(frame, 0, i2);
                if (owner === "com.apple.streaming.transportStreamTimestamp") {
                  var d = frame.subarray(i2 + 1);
                  var size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                  size *= 4;
                  size += d[7] & 3;
                  return size;
                }
                break;
              }
            }
          }
          frameStart += 10;
          frameStart += frameSize;
        } while (frameStart < packet.byteLength);
        return null;
      };
      var utils2 = {
        isLikelyAacData: isLikelyAacData$1,
        parseId3TagSize,
        parseAdtsSize,
        parseType: parseType$2,
        parseSampleRate,
        parseAacTimestamp
      };
      var _AacStream;
      _AacStream = function AacStream() {
        var everything = new Uint8Array(), timeStamp = 0;
        _AacStream.prototype.init.call(this);
        this.setTimestamp = function(timestamp) {
          timeStamp = timestamp;
        };
        this.push = function(bytes) {
          var frameSize = 0, byteIndex = 0, bytesLeft, chunk, packet, tempLength;
          if (everything.length) {
            tempLength = everything.length;
            everything = new Uint8Array(bytes.byteLength + tempLength);
            everything.set(everything.subarray(0, tempLength));
            everything.set(bytes, tempLength);
          } else {
            everything = bytes;
          }
          while (everything.length - byteIndex >= 3) {
            if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
              if (everything.length - byteIndex < 10) {
                break;
              }
              frameSize = utils2.parseId3TagSize(everything, byteIndex);
              if (byteIndex + frameSize > everything.length) {
                break;
              }
              chunk = {
                type: "timed-metadata",
                data: everything.subarray(byteIndex, byteIndex + frameSize)
              };
              this.trigger("data", chunk);
              byteIndex += frameSize;
              continue;
            } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
              if (everything.length - byteIndex < 7) {
                break;
              }
              frameSize = utils2.parseAdtsSize(everything, byteIndex);
              if (byteIndex + frameSize > everything.length) {
                break;
              }
              packet = {
                type: "audio",
                data: everything.subarray(byteIndex, byteIndex + frameSize),
                pts: timeStamp,
                dts: timeStamp
              };
              this.trigger("data", packet);
              byteIndex += frameSize;
              continue;
            }
            byteIndex++;
          }
          bytesLeft = everything.length - byteIndex;
          if (bytesLeft > 0) {
            everything = everything.subarray(byteIndex);
          } else {
            everything = new Uint8Array();
          }
        };
        this.reset = function() {
          everything = new Uint8Array();
          this.trigger("reset");
        };
        this.endTimeline = function() {
          everything = new Uint8Array();
          this.trigger("endedtimeline");
        };
      };
      _AacStream.prototype = new stream();
      var aac = _AacStream;
      var AUDIO_PROPERTIES = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"];
      var audioProperties = AUDIO_PROPERTIES;
      var VIDEO_PROPERTIES = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"];
      var videoProperties = VIDEO_PROPERTIES;
      var H264Stream = h264.H264Stream;
      var isLikelyAacData = utils2.isLikelyAacData;
      var ONE_SECOND_IN_TS$1 = clock2.ONE_SECOND_IN_TS;
      var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;
      var retriggerForStream = function retriggerForStream2(key, event2) {
        event2.stream = key;
        this.trigger("log", event2);
      };
      var addPipelineLogRetriggers = function addPipelineLogRetriggers2(transmuxer2, pipeline) {
        var keys2 = Object.keys(pipeline);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var key = keys2[i2];
          if (key === "headOfPipeline" || !pipeline[key].on) {
            continue;
          }
          pipeline[key].on("log", retriggerForStream.bind(transmuxer2, key));
        }
      };
      var arrayEquals = function arrayEquals2(a, b) {
        var i2;
        if (a.length !== b.length) {
          return false;
        }
        for (i2 = 0; i2 < a.length; i2++) {
          if (a[i2] !== b[i2]) {
            return false;
          }
        }
        return true;
      };
      var generateSegmentTimingInfo = function generateSegmentTimingInfo2(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
        var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
        return {
          start: {
            dts: baseMediaDecodeTime,
            pts: baseMediaDecodeTime + ptsOffsetFromDts
          },
          end: {
            dts: baseMediaDecodeTime + decodeDuration,
            pts: baseMediaDecodeTime + presentationDuration
          },
          prependedContentDuration,
          baseMediaDecodeTime
        };
      };
      _AudioSegmentStream = function AudioSegmentStream(track, options) {
        var adtsFrames = [], sequenceNumber, earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = Infinity;
        options = options || {};
        sequenceNumber = options.firstSequenceNumber || 0;
        _AudioSegmentStream.prototype.init.call(this);
        this.push = function(data) {
          trackDecodeInfo.collectDtsInfo(track, data);
          if (track) {
            audioProperties.forEach(function(prop) {
              track[prop] = data[prop];
            });
          }
          adtsFrames.push(data);
        };
        this.setEarliestDts = function(earliestDts) {
          earliestAllowedDts = earliestDts;
        };
        this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
          videoBaseMediaDecodeTime = baseMediaDecodeTime;
        };
        this.setAudioAppendStart = function(timestamp) {
          audioAppendStartTs = timestamp;
        };
        this.flush = function() {
          var frames, moof2, mdat2, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
          if (adtsFrames.length === 0) {
            this.trigger("done", "AudioSegmentStream");
            return;
          }
          frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
          track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
          videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
          track.samples = audioFrameUtils.generateSampleTable(frames);
          mdat2 = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));
          adtsFrames = [];
          moof2 = mp4Generator.moof(sequenceNumber, [track]);
          boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
          sequenceNumber++;
          boxes.set(moof2);
          boxes.set(mdat2, moof2.byteLength);
          trackDecodeInfo.clearDtsInfo(track);
          frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
          if (frames.length) {
            segmentDuration = frames.length * frameDuration;
            this.trigger("segmentTimingInfo", generateSegmentTimingInfo(clock2.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));
            this.trigger("timingInfo", {
              start: frames[0].pts,
              end: frames[0].pts + segmentDuration
            });
          }
          this.trigger("data", {
            track,
            boxes
          });
          this.trigger("done", "AudioSegmentStream");
        };
        this.reset = function() {
          trackDecodeInfo.clearDtsInfo(track);
          adtsFrames = [];
          this.trigger("reset");
        };
      };
      _AudioSegmentStream.prototype = new stream();
      _VideoSegmentStream = function VideoSegmentStream(track, options) {
        var sequenceNumber, nalUnits = [], gopsToAlignWith = [], config, pps;
        options = options || {};
        sequenceNumber = options.firstSequenceNumber || 0;
        _VideoSegmentStream.prototype.init.call(this);
        delete track.minPTS;
        this.gopCache_ = [];
        this.push = function(nalUnit) {
          trackDecodeInfo.collectDtsInfo(track, nalUnit);
          if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config) {
            config = nalUnit.config;
            track.sps = [nalUnit.data];
            videoProperties.forEach(function(prop) {
              track[prop] = config[prop];
            }, this);
          }
          if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
            pps = nalUnit.data;
            track.pps = [nalUnit.data];
          }
          nalUnits.push(nalUnit);
        };
        this.flush = function() {
          var frames, gopForFusion, gops, moof2, mdat2, boxes, prependedContentDuration = 0, firstGop, lastGop;
          while (nalUnits.length) {
            if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") {
              break;
            }
            nalUnits.shift();
          }
          if (nalUnits.length === 0) {
            this.resetStream_();
            this.trigger("done", "VideoSegmentStream");
            return;
          }
          frames = frameUtils.groupNalsIntoFrames(nalUnits);
          gops = frameUtils.groupFramesIntoGops(frames);
          if (!gops[0][0].keyFrame) {
            gopForFusion = this.getGopForFusion_(nalUnits[0], track);
            if (gopForFusion) {
              prependedContentDuration = gopForFusion.duration;
              gops.unshift(gopForFusion);
              gops.byteLength += gopForFusion.byteLength;
              gops.nalCount += gopForFusion.nalCount;
              gops.pts = gopForFusion.pts;
              gops.dts = gopForFusion.dts;
              gops.duration += gopForFusion.duration;
            } else {
              gops = frameUtils.extendFirstKeyFrame(gops);
            }
          }
          if (gopsToAlignWith.length) {
            var alignedGops;
            if (options.alignGopsAtEnd) {
              alignedGops = this.alignGopsAtEnd_(gops);
            } else {
              alignedGops = this.alignGopsAtStart_(gops);
            }
            if (!alignedGops) {
              this.gopCache_.unshift({
                gop: gops.pop(),
                pps: track.pps,
                sps: track.sps
              });
              this.gopCache_.length = Math.min(6, this.gopCache_.length);
              nalUnits = [];
              this.resetStream_();
              this.trigger("done", "VideoSegmentStream");
              return;
            }
            trackDecodeInfo.clearDtsInfo(track);
            gops = alignedGops;
          }
          trackDecodeInfo.collectDtsInfo(track, gops);
          track.samples = frameUtils.generateSampleTable(gops);
          mdat2 = mp4Generator.mdat(frameUtils.concatenateNalData(gops));
          track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
          this.trigger("processedGopsInfo", gops.map(function(gop) {
            return {
              pts: gop.pts,
              dts: gop.dts,
              byteLength: gop.byteLength
            };
          }));
          firstGop = gops[0];
          lastGop = gops[gops.length - 1];
          this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
          this.trigger("timingInfo", {
            start: gops[0].pts,
            end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
          });
          this.gopCache_.unshift({
            gop: gops.pop(),
            pps: track.pps,
            sps: track.sps
          });
          this.gopCache_.length = Math.min(6, this.gopCache_.length);
          nalUnits = [];
          this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
          this.trigger("timelineStartInfo", track.timelineStartInfo);
          moof2 = mp4Generator.moof(sequenceNumber, [track]);
          boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
          sequenceNumber++;
          boxes.set(moof2);
          boxes.set(mdat2, moof2.byteLength);
          this.trigger("data", {
            track,
            boxes
          });
          this.resetStream_();
          this.trigger("done", "VideoSegmentStream");
        };
        this.reset = function() {
          this.resetStream_();
          nalUnits = [];
          this.gopCache_.length = 0;
          gopsToAlignWith.length = 0;
          this.trigger("reset");
        };
        this.resetStream_ = function() {
          trackDecodeInfo.clearDtsInfo(track);
          config = void 0;
          pps = void 0;
        };
        this.getGopForFusion_ = function(nalUnit) {
          var halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = Infinity, dtsDistance, nearestGopObj, currentGop, currentGopObj, i2;
          for (i2 = 0; i2 < this.gopCache_.length; i2++) {
            currentGopObj = this.gopCache_[i2];
            currentGop = currentGopObj.gop;
            if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {
              continue;
            }
            if (currentGop.dts < track.timelineStartInfo.dts) {
              continue;
            }
            dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
            if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {
              if (!nearestGopObj || nearestDistance > dtsDistance) {
                nearestGopObj = currentGopObj;
                nearestDistance = dtsDistance;
              }
            }
          }
          if (nearestGopObj) {
            return nearestGopObj.gop;
          }
          return null;
        };
        this.alignGopsAtStart_ = function(gops) {
          var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration2, alignedGops;
          byteLength = gops.byteLength;
          nalCount = gops.nalCount;
          duration2 = gops.duration;
          alignIndex = gopIndex = 0;
          while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
            align = gopsToAlignWith[alignIndex];
            gop = gops[gopIndex];
            if (align.pts === gop.pts) {
              break;
            }
            if (gop.pts > align.pts) {
              alignIndex++;
              continue;
            }
            gopIndex++;
            byteLength -= gop.byteLength;
            nalCount -= gop.nalCount;
            duration2 -= gop.duration;
          }
          if (gopIndex === 0) {
            return gops;
          }
          if (gopIndex === gops.length) {
            return null;
          }
          alignedGops = gops.slice(gopIndex);
          alignedGops.byteLength = byteLength;
          alignedGops.duration = duration2;
          alignedGops.nalCount = nalCount;
          alignedGops.pts = alignedGops[0].pts;
          alignedGops.dts = alignedGops[0].dts;
          return alignedGops;
        };
        this.alignGopsAtEnd_ = function(gops) {
          var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
          alignIndex = gopsToAlignWith.length - 1;
          gopIndex = gops.length - 1;
          alignEndIndex = null;
          matchFound = false;
          while (alignIndex >= 0 && gopIndex >= 0) {
            align = gopsToAlignWith[alignIndex];
            gop = gops[gopIndex];
            if (align.pts === gop.pts) {
              matchFound = true;
              break;
            }
            if (align.pts > gop.pts) {
              alignIndex--;
              continue;
            }
            if (alignIndex === gopsToAlignWith.length - 1) {
              alignEndIndex = gopIndex;
            }
            gopIndex--;
          }
          if (!matchFound && alignEndIndex === null) {
            return null;
          }
          var trimIndex;
          if (matchFound) {
            trimIndex = gopIndex;
          } else {
            trimIndex = alignEndIndex;
          }
          if (trimIndex === 0) {
            return gops;
          }
          var alignedGops = gops.slice(trimIndex);
          var metadata = alignedGops.reduce(function(total, gop2) {
            total.byteLength += gop2.byteLength;
            total.duration += gop2.duration;
            total.nalCount += gop2.nalCount;
            return total;
          }, {
            byteLength: 0,
            duration: 0,
            nalCount: 0
          });
          alignedGops.byteLength = metadata.byteLength;
          alignedGops.duration = metadata.duration;
          alignedGops.nalCount = metadata.nalCount;
          alignedGops.pts = alignedGops[0].pts;
          alignedGops.dts = alignedGops[0].dts;
          return alignedGops;
        };
        this.alignGopsWith = function(newGopsToAlignWith) {
          gopsToAlignWith = newGopsToAlignWith;
        };
      };
      _VideoSegmentStream.prototype = new stream();
      _CoalesceStream = function CoalesceStream(options, metadataStream2) {
        this.numberOfTracks = 0;
        this.metadataStream = metadataStream2;
        options = options || {};
        if (typeof options.remux !== "undefined") {
          this.remuxTracks = !!options.remux;
        } else {
          this.remuxTracks = true;
        }
        if (typeof options.keepOriginalTimestamps === "boolean") {
          this.keepOriginalTimestamps = options.keepOriginalTimestamps;
        } else {
          this.keepOriginalTimestamps = false;
        }
        this.pendingTracks = [];
        this.videoTrack = null;
        this.pendingBoxes = [];
        this.pendingCaptions = [];
        this.pendingMetadata = [];
        this.pendingBytes = 0;
        this.emittedTracks = 0;
        _CoalesceStream.prototype.init.call(this);
        this.push = function(output) {
          if (output.text) {
            return this.pendingCaptions.push(output);
          }
          if (output.frames) {
            return this.pendingMetadata.push(output);
          }
          this.pendingTracks.push(output.track);
          this.pendingBytes += output.boxes.byteLength;
          if (output.track.type === "video") {
            this.videoTrack = output.track;
            this.pendingBoxes.push(output.boxes);
          }
          if (output.track.type === "audio") {
            this.audioTrack = output.track;
            this.pendingBoxes.unshift(output.boxes);
          }
        };
      };
      _CoalesceStream.prototype = new stream();
      _CoalesceStream.prototype.flush = function(flushSource) {
        var offset = 0, event2 = {
          captions: [],
          captionStreams: {},
          metadata: [],
          info: {}
        }, caption, id3, initSegment, timelineStartPts = 0, i2;
        if (this.pendingTracks.length < this.numberOfTracks) {
          if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") {
            return;
          } else if (this.remuxTracks) {
            return;
          } else if (this.pendingTracks.length === 0) {
            this.emittedTracks++;
            if (this.emittedTracks >= this.numberOfTracks) {
              this.trigger("done");
              this.emittedTracks = 0;
            }
            return;
          }
        }
        if (this.videoTrack) {
          timelineStartPts = this.videoTrack.timelineStartInfo.pts;
          videoProperties.forEach(function(prop) {
            event2.info[prop] = this.videoTrack[prop];
          }, this);
        } else if (this.audioTrack) {
          timelineStartPts = this.audioTrack.timelineStartInfo.pts;
          audioProperties.forEach(function(prop) {
            event2.info[prop] = this.audioTrack[prop];
          }, this);
        }
        if (this.videoTrack || this.audioTrack) {
          if (this.pendingTracks.length === 1) {
            event2.type = this.pendingTracks[0].type;
          } else {
            event2.type = "combined";
          }
          this.emittedTracks += this.pendingTracks.length;
          initSegment = mp4Generator.initSegment(this.pendingTracks);
          event2.initSegment = new Uint8Array(initSegment.byteLength);
          event2.initSegment.set(initSegment);
          event2.data = new Uint8Array(this.pendingBytes);
          for (i2 = 0; i2 < this.pendingBoxes.length; i2++) {
            event2.data.set(this.pendingBoxes[i2], offset);
            offset += this.pendingBoxes[i2].byteLength;
          }
          for (i2 = 0; i2 < this.pendingCaptions.length; i2++) {
            caption = this.pendingCaptions[i2];
            caption.startTime = clock2.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
            caption.endTime = clock2.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
            event2.captionStreams[caption.stream] = true;
            event2.captions.push(caption);
          }
          for (i2 = 0; i2 < this.pendingMetadata.length; i2++) {
            id3 = this.pendingMetadata[i2];
            id3.cueTime = clock2.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);
            event2.metadata.push(id3);
          }
          event2.metadata.dispatchType = this.metadataStream.dispatchType;
          this.pendingTracks.length = 0;
          this.videoTrack = null;
          this.pendingBoxes.length = 0;
          this.pendingCaptions.length = 0;
          this.pendingBytes = 0;
          this.pendingMetadata.length = 0;
          this.trigger("data", event2);
          for (i2 = 0; i2 < event2.captions.length; i2++) {
            caption = event2.captions[i2];
            this.trigger("caption", caption);
          }
          for (i2 = 0; i2 < event2.metadata.length; i2++) {
            id3 = event2.metadata[i2];
            this.trigger("id3Frame", id3);
          }
        }
        if (this.emittedTracks >= this.numberOfTracks) {
          this.trigger("done");
          this.emittedTracks = 0;
        }
      };
      _CoalesceStream.prototype.setRemux = function(val) {
        this.remuxTracks = val;
      };
      _Transmuxer = function Transmuxer(options) {
        var self2 = this, hasFlushed = true, videoTrack, audioTrack;
        _Transmuxer.prototype.init.call(this);
        options = options || {};
        this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
        this.transmuxPipeline_ = {};
        this.setupAacPipeline = function() {
          var pipeline = {};
          this.transmuxPipeline_ = pipeline;
          pipeline.type = "aac";
          pipeline.metadataStream = new m2ts_1.MetadataStream();
          pipeline.aacStream = new aac();
          pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("audio");
          pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("timed-metadata");
          pipeline.adtsStream = new adts();
          pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
          pipeline.headOfPipeline = pipeline.aacStream;
          pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
          pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
          pipeline.metadataStream.on("timestamp", function(frame) {
            pipeline.aacStream.setTimestamp(frame.timeStamp);
          });
          pipeline.aacStream.on("data", function(data) {
            if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) {
              return;
            }
            audioTrack = audioTrack || {
              timelineStartInfo: {
                baseMediaDecodeTime: self2.baseMediaDecodeTime
              },
              codec: "adts",
              type: "audio"
            };
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
            pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
            pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
            self2.trigger("trackinfo", {
              hasAudio: !!audioTrack,
              hasVideo: !!videoTrack
            });
          });
          pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
          pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
          addPipelineLogRetriggers(this, pipeline);
        };
        this.setupTsPipeline = function() {
          var pipeline = {};
          this.transmuxPipeline_ = pipeline;
          pipeline.type = "ts";
          pipeline.metadataStream = new m2ts_1.MetadataStream();
          pipeline.packetStream = new m2ts_1.TransportPacketStream();
          pipeline.parseStream = new m2ts_1.TransportParseStream();
          pipeline.elementaryStream = new m2ts_1.ElementaryStream();
          pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();
          pipeline.adtsStream = new adts();
          pipeline.h264Stream = new H264Stream();
          pipeline.captionStream = new m2ts_1.CaptionStream(options);
          pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
          pipeline.headOfPipeline = pipeline.packetStream;
          pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
          pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
          pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
          pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
          pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
          pipeline.elementaryStream.on("data", function(data) {
            var i2;
            if (data.type === "metadata") {
              i2 = data.tracks.length;
              while (i2--) {
                if (!videoTrack && data.tracks[i2].type === "video") {
                  videoTrack = data.tracks[i2];
                  videoTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
                } else if (!audioTrack && data.tracks[i2].type === "audio") {
                  audioTrack = data.tracks[i2];
                  audioTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
                }
              }
              if (videoTrack && !pipeline.videoSegmentStream) {
                pipeline.coalesceStream.numberOfTracks++;
                pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);
                pipeline.videoSegmentStream.on("log", self2.getLogTrigger_("videoSegmentStream"));
                pipeline.videoSegmentStream.on("timelineStartInfo", function(timelineStartInfo) {
                  if (audioTrack && !options.keepOriginalTimestamps) {
                    audioTrack.timelineStartInfo = timelineStartInfo;
                    pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self2.baseMediaDecodeTime);
                  }
                });
                pipeline.videoSegmentStream.on("processedGopsInfo", self2.trigger.bind(self2, "gopInfo"));
                pipeline.videoSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "videoSegmentTimingInfo"));
                pipeline.videoSegmentStream.on("baseMediaDecodeTime", function(baseMediaDecodeTime) {
                  if (audioTrack) {
                    pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
                  }
                });
                pipeline.videoSegmentStream.on("timingInfo", self2.trigger.bind(self2, "videoTimingInfo"));
                pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
              }
              if (audioTrack && !pipeline.audioSegmentStream) {
                pipeline.coalesceStream.numberOfTracks++;
                pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
                pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
                pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
                pipeline.audioSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "audioSegmentTimingInfo"));
                pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
              }
              self2.trigger("trackinfo", {
                hasAudio: !!audioTrack,
                hasVideo: !!videoTrack
              });
            }
          });
          pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
          pipeline.coalesceStream.on("id3Frame", function(id3Frame) {
            id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
            self2.trigger("id3Frame", id3Frame);
          });
          pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
          pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
          addPipelineLogRetriggers(this, pipeline);
        };
        this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
          var pipeline = this.transmuxPipeline_;
          if (!options.keepOriginalTimestamps) {
            this.baseMediaDecodeTime = baseMediaDecodeTime;
          }
          if (audioTrack) {
            audioTrack.timelineStartInfo.dts = void 0;
            audioTrack.timelineStartInfo.pts = void 0;
            trackDecodeInfo.clearDtsInfo(audioTrack);
            if (pipeline.audioTimestampRolloverStream) {
              pipeline.audioTimestampRolloverStream.discontinuity();
            }
          }
          if (videoTrack) {
            if (pipeline.videoSegmentStream) {
              pipeline.videoSegmentStream.gopCache_ = [];
            }
            videoTrack.timelineStartInfo.dts = void 0;
            videoTrack.timelineStartInfo.pts = void 0;
            trackDecodeInfo.clearDtsInfo(videoTrack);
            pipeline.captionStream.reset();
          }
          if (pipeline.timestampRolloverStream) {
            pipeline.timestampRolloverStream.discontinuity();
          }
        };
        this.setAudioAppendStart = function(timestamp) {
          if (audioTrack) {
            this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
          }
        };
        this.setRemux = function(val) {
          var pipeline = this.transmuxPipeline_;
          options.remux = val;
          if (pipeline && pipeline.coalesceStream) {
            pipeline.coalesceStream.setRemux(val);
          }
        };
        this.alignGopsWith = function(gopsToAlignWith) {
          if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {
            this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
          }
        };
        this.getLogTrigger_ = function(key) {
          var self3 = this;
          return function(event2) {
            event2.stream = key;
            self3.trigger("log", event2);
          };
        };
        this.push = function(data) {
          if (hasFlushed) {
            var isAac = isLikelyAacData(data);
            if (isAac && this.transmuxPipeline_.type !== "aac") {
              this.setupAacPipeline();
            } else if (!isAac && this.transmuxPipeline_.type !== "ts") {
              this.setupTsPipeline();
            }
            hasFlushed = false;
          }
          this.transmuxPipeline_.headOfPipeline.push(data);
        };
        this.flush = function() {
          hasFlushed = true;
          this.transmuxPipeline_.headOfPipeline.flush();
        };
        this.endTimeline = function() {
          this.transmuxPipeline_.headOfPipeline.endTimeline();
        };
        this.reset = function() {
          if (this.transmuxPipeline_.headOfPipeline) {
            this.transmuxPipeline_.headOfPipeline.reset();
          }
        };
        this.resetCaptions = function() {
          if (this.transmuxPipeline_.captionStream) {
            this.transmuxPipeline_.captionStream.reset();
          }
        };
      };
      _Transmuxer.prototype = new stream();
      var transmuxer = {
        Transmuxer: _Transmuxer,
        VideoSegmentStream: _VideoSegmentStream,
        AudioSegmentStream: _AudioSegmentStream,
        AUDIO_PROPERTIES: audioProperties,
        VIDEO_PROPERTIES: videoProperties,
        generateSegmentTimingInfo
      };
      var toUnsigned$3 = function toUnsigned2(value) {
        return value >>> 0;
      };
      var toHexString$1 = function toHexString2(value) {
        return ("00" + value.toString(16)).slice(-2);
      };
      var bin = {
        toUnsigned: toUnsigned$3,
        toHexString: toHexString$1
      };
      var parseType$1 = function parseType2(buffer) {
        var result = "";
        result += String.fromCharCode(buffer[0]);
        result += String.fromCharCode(buffer[1]);
        result += String.fromCharCode(buffer[2]);
        result += String.fromCharCode(buffer[3]);
        return result;
      };
      var parseType_1 = parseType$1;
      var toUnsigned$2 = bin.toUnsigned;
      var findBox = function findBox2(data, path) {
        var results = [], i2, size, type2, end2, subresults;
        if (!path.length) {
          return null;
        }
        for (i2 = 0; i2 < data.byteLength; ) {
          size = toUnsigned$2(data[i2] << 24 | data[i2 + 1] << 16 | data[i2 + 2] << 8 | data[i2 + 3]);
          type2 = parseType_1(data.subarray(i2 + 4, i2 + 8));
          end2 = size > 1 ? i2 + size : data.byteLength;
          if (type2 === path[0]) {
            if (path.length === 1) {
              results.push(data.subarray(i2 + 8, end2));
            } else {
              subresults = findBox2(data.subarray(i2 + 8, end2), path.slice(1));
              if (subresults.length) {
                results = results.concat(subresults);
              }
            }
          }
          i2 = end2;
        }
        return results;
      };
      var findBox_1 = findBox;
      var toUnsigned$1 = bin.toUnsigned;
      var getUint64$1 = numbers.getUint64;
      var tfdt = function tfdt2(data) {
        var result = {
          version: data[0],
          flags: new Uint8Array(data.subarray(1, 4))
        };
        if (result.version === 1) {
          result.baseMediaDecodeTime = getUint64$1(data.subarray(4));
        } else {
          result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
        }
        return result;
      };
      var parseTfdt = tfdt;
      var parseSampleFlags = function parseSampleFlags2(flags) {
        return {
          isLeading: (flags[0] & 12) >>> 2,
          dependsOn: flags[0] & 3,
          isDependedOn: (flags[1] & 192) >>> 6,
          hasRedundancy: (flags[1] & 48) >>> 4,
          paddingValue: (flags[1] & 14) >>> 1,
          isNonSyncSample: flags[1] & 1,
          degradationPriority: flags[2] << 8 | flags[3]
        };
      };
      var parseSampleFlags_1 = parseSampleFlags;
      var trun = function trun2(data) {
        var result = {
          version: data[0],
          flags: new Uint8Array(data.subarray(1, 4)),
          samples: []
        }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset = 8, sample;
        if (dataOffsetPresent) {
          result.dataOffset = view.getInt32(offset);
          offset += 4;
        }
        if (firstSampleFlagsPresent && sampleCount) {
          sample = {
            flags: parseSampleFlags_1(data.subarray(offset, offset + 4))
          };
          offset += 4;
          if (sampleDurationPresent) {
            sample.duration = view.getUint32(offset);
            offset += 4;
          }
          if (sampleSizePresent) {
            sample.size = view.getUint32(offset);
            offset += 4;
          }
          if (sampleCompositionTimeOffsetPresent) {
            if (result.version === 1) {
              sample.compositionTimeOffset = view.getInt32(offset);
            } else {
              sample.compositionTimeOffset = view.getUint32(offset);
            }
            offset += 4;
          }
          result.samples.push(sample);
          sampleCount--;
        }
        while (sampleCount--) {
          sample = {};
          if (sampleDurationPresent) {
            sample.duration = view.getUint32(offset);
            offset += 4;
          }
          if (sampleSizePresent) {
            sample.size = view.getUint32(offset);
            offset += 4;
          }
          if (sampleFlagsPresent) {
            sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));
            offset += 4;
          }
          if (sampleCompositionTimeOffsetPresent) {
            if (result.version === 1) {
              sample.compositionTimeOffset = view.getInt32(offset);
            } else {
              sample.compositionTimeOffset = view.getUint32(offset);
            }
            offset += 4;
          }
          result.samples.push(sample);
        }
        return result;
      };
      var parseTrun = trun;
      var tfhd = function tfhd2(data) {
        var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
          version: data[0],
          flags: new Uint8Array(data.subarray(1, 4)),
          trackId: view.getUint32(4)
        }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072, i2;
        i2 = 8;
        if (baseDataOffsetPresent) {
          i2 += 4;
          result.baseDataOffset = view.getUint32(12);
          i2 += 4;
        }
        if (sampleDescriptionIndexPresent) {
          result.sampleDescriptionIndex = view.getUint32(i2);
          i2 += 4;
        }
        if (defaultSampleDurationPresent) {
          result.defaultSampleDuration = view.getUint32(i2);
          i2 += 4;
        }
        if (defaultSampleSizePresent) {
          result.defaultSampleSize = view.getUint32(i2);
          i2 += 4;
        }
        if (defaultSampleFlagsPresent) {
          result.defaultSampleFlags = view.getUint32(i2);
        }
        if (durationIsEmpty) {
          result.durationIsEmpty = true;
        }
        if (!baseDataOffsetPresent && defaultBaseIsMoof) {
          result.baseDataOffsetIsMoof = true;
        }
        return result;
      };
      var parseTfhd = tfhd;
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
      var win;
      if (typeof window !== "undefined") {
        win = window;
      } else if (typeof commonjsGlobal !== "undefined") {
        win = commonjsGlobal;
      } else if (typeof self !== "undefined") {
        win = self;
      } else {
        win = {};
      }
      var window_1 = win;
      var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;
      var CaptionStream = captionStream.CaptionStream;
      var mapToSample = function mapToSample2(offset, samples) {
        var approximateOffset = offset;
        for (var i2 = 0; i2 < samples.length; i2++) {
          var sample = samples[i2];
          if (approximateOffset < sample.size) {
            return sample;
          }
          approximateOffset -= sample.size;
        }
        return null;
      };
      var findSeiNals = function findSeiNals2(avcStream, samples, trackId) {
        var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
          logs: [],
          seiNals: []
        }, seiNal, i2, length, lastMatchedSample;
        for (i2 = 0; i2 + 4 < avcStream.length; i2 += length) {
          length = avcView.getUint32(i2);
          i2 += 4;
          if (length <= 0) {
            continue;
          }
          switch (avcStream[i2] & 31) {
            case 6:
              var data = avcStream.subarray(i2 + 1, i2 + 1 + length);
              var matchingSample = mapToSample(i2, samples);
              seiNal = {
                nalUnitType: "sei_rbsp",
                size: length,
                data,
                escapedRBSP: discardEmulationPreventionBytes(data),
                trackId
              };
              if (matchingSample) {
                seiNal.pts = matchingSample.pts;
                seiNal.dts = matchingSample.dts;
                lastMatchedSample = matchingSample;
              } else if (lastMatchedSample) {
                seiNal.pts = lastMatchedSample.pts;
                seiNal.dts = lastMatchedSample.dts;
              } else {
                result.logs.push({
                  level: "warn",
                  message: "We've encountered a nal unit without data at " + i2 + " for trackId " + trackId + ". See mux.js#223."
                });
                break;
              }
              result.seiNals.push(seiNal);
              break;
          }
        }
        return result;
      };
      var parseSamples = function parseSamples2(truns, baseMediaDecodeTime, tfhd2) {
        var currentDts = baseMediaDecodeTime;
        var defaultSampleDuration = tfhd2.defaultSampleDuration || 0;
        var defaultSampleSize = tfhd2.defaultSampleSize || 0;
        var trackId = tfhd2.trackId;
        var allSamples = [];
        truns.forEach(function(trun2) {
          var trackRun = parseTrun(trun2);
          var samples = trackRun.samples;
          samples.forEach(function(sample) {
            if (sample.duration === void 0) {
              sample.duration = defaultSampleDuration;
            }
            if (sample.size === void 0) {
              sample.size = defaultSampleSize;
            }
            sample.trackId = trackId;
            sample.dts = currentDts;
            if (sample.compositionTimeOffset === void 0) {
              sample.compositionTimeOffset = 0;
            }
            if (typeof currentDts === "bigint") {
              sample.pts = currentDts + window_1.BigInt(sample.compositionTimeOffset);
              currentDts += window_1.BigInt(sample.duration);
            } else {
              sample.pts = currentDts + sample.compositionTimeOffset;
              currentDts += sample.duration;
            }
          });
          allSamples = allSamples.concat(samples);
        });
        return allSamples;
      };
      var parseCaptionNals = function parseCaptionNals2(segment, videoTrackId) {
        var trafs = findBox_1(segment, ["moof", "traf"]);
        var mdats = findBox_1(segment, ["mdat"]);
        var captionNals = {};
        var mdatTrafPairs = [];
        mdats.forEach(function(mdat2, index) {
          var matchingTraf = trafs[index];
          mdatTrafPairs.push({
            mdat: mdat2,
            traf: matchingTraf
          });
        });
        mdatTrafPairs.forEach(function(pair) {
          var mdat2 = pair.mdat;
          var traf2 = pair.traf;
          var tfhd2 = findBox_1(traf2, ["tfhd"]);
          var headerInfo = parseTfhd(tfhd2[0]);
          var trackId = headerInfo.trackId;
          var tfdt2 = findBox_1(traf2, ["tfdt"]);
          var baseMediaDecodeTime = tfdt2.length > 0 ? parseTfdt(tfdt2[0]).baseMediaDecodeTime : 0;
          var truns = findBox_1(traf2, ["trun"]);
          var samples;
          var result;
          if (videoTrackId === trackId && truns.length > 0) {
            samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);
            result = findSeiNals(mdat2, samples, trackId);
            if (!captionNals[trackId]) {
              captionNals[trackId] = {
                seiNals: [],
                logs: []
              };
            }
            captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
            captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
          }
        });
        return captionNals;
      };
      var parseEmbeddedCaptions = function parseEmbeddedCaptions2(segment, trackId, timescale2) {
        var captionNals;
        if (trackId === null) {
          return null;
        }
        captionNals = parseCaptionNals(segment, trackId);
        var trackNals = captionNals[trackId] || {};
        return {
          seiNals: trackNals.seiNals,
          logs: trackNals.logs,
          timescale: timescale2
        };
      };
      var CaptionParser = function CaptionParser2() {
        var isInitialized = false;
        var captionStream2;
        var segmentCache;
        var trackId;
        var timescale2;
        var parsedCaptions;
        var parsingPartial;
        this.isInitialized = function() {
          return isInitialized;
        };
        this.init = function(options) {
          captionStream2 = new CaptionStream();
          isInitialized = true;
          parsingPartial = options ? options.isPartial : false;
          captionStream2.on("data", function(event2) {
            event2.startTime = event2.startPts / timescale2;
            event2.endTime = event2.endPts / timescale2;
            parsedCaptions.captions.push(event2);
            parsedCaptions.captionStreams[event2.stream] = true;
          });
          captionStream2.on("log", function(log3) {
            parsedCaptions.logs.push(log3);
          });
        };
        this.isNewInit = function(videoTrackIds, timescales) {
          if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) {
            return false;
          }
          return trackId !== videoTrackIds[0] || timescale2 !== timescales[trackId];
        };
        this.parse = function(segment, videoTrackIds, timescales) {
          var parsedData;
          if (!this.isInitialized()) {
            return null;
          } else if (!videoTrackIds || !timescales) {
            return null;
          } else if (this.isNewInit(videoTrackIds, timescales)) {
            trackId = videoTrackIds[0];
            timescale2 = timescales[trackId];
          } else if (trackId === null || !timescale2) {
            segmentCache.push(segment);
            return null;
          }
          while (segmentCache.length > 0) {
            var cachedSegment = segmentCache.shift();
            this.parse(cachedSegment, videoTrackIds, timescales);
          }
          parsedData = parseEmbeddedCaptions(segment, trackId, timescale2);
          if (parsedData && parsedData.logs) {
            parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
          }
          if (parsedData === null || !parsedData.seiNals) {
            if (parsedCaptions.logs.length) {
              return {
                logs: parsedCaptions.logs,
                captions: [],
                captionStreams: []
              };
            }
            return null;
          }
          this.pushNals(parsedData.seiNals);
          this.flushStream();
          return parsedCaptions;
        };
        this.pushNals = function(nals) {
          if (!this.isInitialized() || !nals || nals.length === 0) {
            return null;
          }
          nals.forEach(function(nal) {
            captionStream2.push(nal);
          });
        };
        this.flushStream = function() {
          if (!this.isInitialized()) {
            return null;
          }
          if (!parsingPartial) {
            captionStream2.flush();
          } else {
            captionStream2.partialFlush();
          }
        };
        this.clearParsedCaptions = function() {
          parsedCaptions.captions = [];
          parsedCaptions.captionStreams = {};
          parsedCaptions.logs = [];
        };
        this.resetCaptionStream = function() {
          if (!this.isInitialized()) {
            return null;
          }
          captionStream2.reset();
        };
        this.clearAllCaptions = function() {
          this.clearParsedCaptions();
          this.resetCaptionStream();
        };
        this.reset = function() {
          segmentCache = [];
          trackId = null;
          timescale2 = null;
          if (!parsedCaptions) {
            parsedCaptions = {
              captions: [],
              captionStreams: {},
              logs: []
            };
          } else {
            this.clearParsedCaptions();
          }
          this.resetCaptionStream();
        };
        this.reset();
      };
      var captionParser = CaptionParser;
      var toUnsigned = bin.toUnsigned;
      var toHexString = bin.toHexString;
      var getUint64 = numbers.getUint64;
      var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;
      timescale = function timescale2(init) {
        var result = {}, traks = findBox_1(init, ["moov", "trak"]);
        return traks.reduce(function(result2, trak2) {
          var tkhd2, version3, index, id, mdhd2;
          tkhd2 = findBox_1(trak2, ["tkhd"])[0];
          if (!tkhd2) {
            return null;
          }
          version3 = tkhd2[0];
          index = version3 === 0 ? 12 : 20;
          id = toUnsigned(tkhd2[index] << 24 | tkhd2[index + 1] << 16 | tkhd2[index + 2] << 8 | tkhd2[index + 3]);
          mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
          if (!mdhd2) {
            return null;
          }
          version3 = mdhd2[0];
          index = version3 === 0 ? 12 : 20;
          result2[id] = toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
          return result2;
        }, result);
      };
      startTime = function startTime2(timescale2, fragment) {
        var trafs;
        trafs = findBox_1(fragment, ["moof", "traf"]);
        var lowestTime = trafs.reduce(function(acc, traf2) {
          var tfhd2 = findBox_1(traf2, ["tfhd"])[0];
          var id = toUnsigned(tfhd2[4] << 24 | tfhd2[5] << 16 | tfhd2[6] << 8 | tfhd2[7]);
          var scale = timescale2[id] || 9e4;
          var tfdt2 = findBox_1(traf2, ["tfdt"])[0];
          var dv = new DataView(tfdt2.buffer, tfdt2.byteOffset, tfdt2.byteLength);
          var baseTime;
          if (tfdt2[0] === 1) {
            baseTime = getUint64(tfdt2.subarray(4, 12));
          } else {
            baseTime = dv.getUint32(4);
          }
          var seconds;
          if (typeof baseTime === "bigint") {
            seconds = baseTime / window_1.BigInt(scale);
          } else if (typeof baseTime === "number" && !isNaN(baseTime)) {
            seconds = baseTime / scale;
          }
          if (seconds < Number.MAX_SAFE_INTEGER) {
            seconds = Number(seconds);
          }
          if (seconds < acc) {
            acc = seconds;
          }
          return acc;
        }, Infinity);
        return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
      };
      compositionStartTime = function compositionStartTime2(timescales, fragment) {
        var trafBoxes = findBox_1(fragment, ["moof", "traf"]);
        var baseMediaDecodeTime = 0;
        var compositionTimeOffset = 0;
        var trackId;
        if (trafBoxes && trafBoxes.length) {
          var tfhd2 = findBox_1(trafBoxes[0], ["tfhd"])[0];
          var trun2 = findBox_1(trafBoxes[0], ["trun"])[0];
          var tfdt2 = findBox_1(trafBoxes[0], ["tfdt"])[0];
          if (tfhd2) {
            var parsedTfhd = parseTfhd(tfhd2);
            trackId = parsedTfhd.trackId;
          }
          if (tfdt2) {
            var parsedTfdt = parseTfdt(tfdt2);
            baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
          }
          if (trun2) {
            var parsedTrun = parseTrun(trun2);
            if (parsedTrun.samples && parsedTrun.samples.length) {
              compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
            }
          }
        }
        var timescale2 = timescales[trackId] || 9e4;
        if (typeof baseMediaDecodeTime === "bigint") {
          compositionTimeOffset = window_1.BigInt(compositionTimeOffset);
          timescale2 = window_1.BigInt(timescale2);
        }
        var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale2;
        if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) {
          result = Number(result);
        }
        return result;
      };
      getVideoTrackIds = function getVideoTrackIds2(init) {
        var traks = findBox_1(init, ["moov", "trak"]);
        var videoTrackIds = [];
        traks.forEach(function(trak2) {
          var hdlrs = findBox_1(trak2, ["mdia", "hdlr"]);
          var tkhds = findBox_1(trak2, ["tkhd"]);
          hdlrs.forEach(function(hdlr2, index) {
            var handlerType = parseType_1(hdlr2.subarray(8, 12));
            var tkhd2 = tkhds[index];
            var view;
            var version3;
            var trackId;
            if (handlerType === "vide") {
              view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
              version3 = view.getUint8(0);
              trackId = version3 === 0 ? view.getUint32(12) : view.getUint32(20);
              videoTrackIds.push(trackId);
            }
          });
        });
        return videoTrackIds;
      };
      getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader2(mdhd2) {
        var version3 = mdhd2[0];
        var index = version3 === 0 ? 12 : 20;
        return toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
      };
      getTracks = function getTracks2(init) {
        var traks = findBox_1(init, ["moov", "trak"]);
        var tracks = [];
        traks.forEach(function(trak2) {
          var track = {};
          var tkhd2 = findBox_1(trak2, ["tkhd"])[0];
          var view, tkhdVersion;
          if (tkhd2) {
            view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
            tkhdVersion = view.getUint8(0);
            track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
          }
          var hdlr2 = findBox_1(trak2, ["mdia", "hdlr"])[0];
          if (hdlr2) {
            var type2 = parseType_1(hdlr2.subarray(8, 12));
            if (type2 === "vide") {
              track.type = "video";
            } else if (type2 === "soun") {
              track.type = "audio";
            } else {
              track.type = type2;
            }
          }
          var stsd2 = findBox_1(trak2, ["mdia", "minf", "stbl", "stsd"])[0];
          if (stsd2) {
            var sampleDescriptions = stsd2.subarray(8);
            track.codec = parseType_1(sampleDescriptions.subarray(4, 8));
            var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];
            var codecConfig, codecConfigType;
            if (codecBox) {
              if (/^[asm]vc[1-9]$/i.test(track.codec)) {
                codecConfig = codecBox.subarray(78);
                codecConfigType = parseType_1(codecConfig.subarray(4, 8));
                if (codecConfigType === "avcC" && codecConfig.length > 11) {
                  track.codec += ".";
                  track.codec += toHexString(codecConfig[9]);
                  track.codec += toHexString(codecConfig[10]);
                  track.codec += toHexString(codecConfig[11]);
                } else {
                  track.codec = "avc1.4d400d";
                }
              } else if (/^mp4[a,v]$/i.test(track.codec)) {
                codecConfig = codecBox.subarray(28);
                codecConfigType = parseType_1(codecConfig.subarray(4, 8));
                if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
                  track.codec += "." + toHexString(codecConfig[19]);
                  track.codec += "." + toHexString(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
                } else {
                  track.codec = "mp4a.40.2";
                }
              } else {
                track.codec = track.codec.toLowerCase();
              }
            }
          }
          var mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
          if (mdhd2) {
            track.timescale = getTimescaleFromMediaHeader(mdhd2);
          }
          tracks.push(track);
        });
        return tracks;
      };
      var probe$2 = {
        findBox: findBox_1,
        parseType: parseType_1,
        timescale,
        startTime,
        compositionStartTime,
        videoTrackIds: getVideoTrackIds,
        tracks: getTracks,
        getTimescaleFromMediaHeader
      };
      var parsePid = function parsePid2(packet) {
        var pid = packet[1] & 31;
        pid <<= 8;
        pid |= packet[2];
        return pid;
      };
      var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator2(packet) {
        return !!(packet[1] & 64);
      };
      var parseAdaptionField = function parseAdaptionField2(packet) {
        var offset = 0;
        if ((packet[3] & 48) >>> 4 > 1) {
          offset += packet[4] + 1;
        }
        return offset;
      };
      var parseType = function parseType2(packet, pmtPid) {
        var pid = parsePid(packet);
        if (pid === 0) {
          return "pat";
        } else if (pid === pmtPid) {
          return "pmt";
        } else if (pmtPid) {
          return "pes";
        }
        return null;
      };
      var parsePat = function parsePat2(packet) {
        var pusi = parsePayloadUnitStartIndicator(packet);
        var offset = 4 + parseAdaptionField(packet);
        if (pusi) {
          offset += packet[offset] + 1;
        }
        return (packet[offset + 10] & 31) << 8 | packet[offset + 11];
      };
      var parsePmt = function parsePmt2(packet) {
        var programMapTable = {};
        var pusi = parsePayloadUnitStartIndicator(packet);
        var payloadOffset = 4 + parseAdaptionField(packet);
        if (pusi) {
          payloadOffset += packet[payloadOffset] + 1;
        }
        if (!(packet[payloadOffset + 5] & 1)) {
          return;
        }
        var sectionLength, tableEnd, programInfoLength;
        sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
        tableEnd = 3 + sectionLength - 4;
        programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
        var offset = 12 + programInfoLength;
        while (offset < tableEnd) {
          var i2 = payloadOffset + offset;
          programMapTable[(packet[i2 + 1] & 31) << 8 | packet[i2 + 2]] = packet[i2];
          offset += ((packet[i2 + 3] & 15) << 8 | packet[i2 + 4]) + 5;
        }
        return programMapTable;
      };
      var parsePesType = function parsePesType2(packet, programMapTable) {
        var pid = parsePid(packet);
        var type2 = programMapTable[pid];
        switch (type2) {
          case streamTypes.H264_STREAM_TYPE:
            return "video";
          case streamTypes.ADTS_STREAM_TYPE:
            return "audio";
          case streamTypes.METADATA_STREAM_TYPE:
            return "timed-metadata";
          default:
            return null;
        }
      };
      var parsePesTime = function parsePesTime2(packet) {
        var pusi = parsePayloadUnitStartIndicator(packet);
        if (!pusi) {
          return null;
        }
        var offset = 4 + parseAdaptionField(packet);
        if (offset >= packet.byteLength) {
          return null;
        }
        var pes = null;
        var ptsDtsFlags;
        ptsDtsFlags = packet[offset + 7];
        if (ptsDtsFlags & 192) {
          pes = {};
          pes.pts = (packet[offset + 9] & 14) << 27 | (packet[offset + 10] & 255) << 20 | (packet[offset + 11] & 254) << 12 | (packet[offset + 12] & 255) << 5 | (packet[offset + 13] & 254) >>> 3;
          pes.pts *= 4;
          pes.pts += (packet[offset + 13] & 6) >>> 1;
          pes.dts = pes.pts;
          if (ptsDtsFlags & 64) {
            pes.dts = (packet[offset + 14] & 14) << 27 | (packet[offset + 15] & 255) << 20 | (packet[offset + 16] & 254) << 12 | (packet[offset + 17] & 255) << 5 | (packet[offset + 18] & 254) >>> 3;
            pes.dts *= 4;
            pes.dts += (packet[offset + 18] & 6) >>> 1;
          }
        }
        return pes;
      };
      var parseNalUnitType = function parseNalUnitType2(type2) {
        switch (type2) {
          case 5:
            return "slice_layer_without_partitioning_rbsp_idr";
          case 6:
            return "sei_rbsp";
          case 7:
            return "seq_parameter_set_rbsp";
          case 8:
            return "pic_parameter_set_rbsp";
          case 9:
            return "access_unit_delimiter_rbsp";
          default:
            return null;
        }
      };
      var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame2(packet) {
        var offset = 4 + parseAdaptionField(packet);
        var frameBuffer = packet.subarray(offset);
        var frameI = 0;
        var frameSyncPoint = 0;
        var foundKeyFrame = false;
        var nalType;
        for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {
          if (frameBuffer[frameSyncPoint + 2] === 1) {
            frameI = frameSyncPoint + 5;
            break;
          }
        }
        while (frameI < frameBuffer.byteLength) {
          switch (frameBuffer[frameI]) {
            case 0:
              if (frameBuffer[frameI - 1] !== 0) {
                frameI += 2;
                break;
              } else if (frameBuffer[frameI - 2] !== 0) {
                frameI++;
                break;
              }
              if (frameSyncPoint + 3 !== frameI - 2) {
                nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
                if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
                  foundKeyFrame = true;
                }
              }
              do {
                frameI++;
              } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
              frameSyncPoint = frameI - 2;
              frameI += 3;
              break;
            case 1:
              if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
                frameI += 3;
                break;
              }
              nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
              if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
                foundKeyFrame = true;
              }
              frameSyncPoint = frameI - 2;
              frameI += 3;
              break;
            default:
              frameI += 3;
              break;
          }
        }
        frameBuffer = frameBuffer.subarray(frameSyncPoint);
        frameI -= frameSyncPoint;
        frameSyncPoint = 0;
        if (frameBuffer && frameBuffer.byteLength > 3) {
          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
          if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
            foundKeyFrame = true;
          }
        }
        return foundKeyFrame;
      };
      var probe$1 = {
        parseType,
        parsePat,
        parsePmt,
        parsePayloadUnitStartIndicator,
        parsePesType,
        parsePesTime,
        videoPacketContainsKeyFrame
      };
      var handleRollover = timestampRolloverStream.handleRollover;
      var probe = {};
      probe.ts = probe$1;
      probe.aac = utils2;
      var ONE_SECOND_IN_TS = clock2.ONE_SECOND_IN_TS;
      var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
      var parsePsi_ = function parsePsi_2(bytes, pmt) {
        var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2;
        while (endIndex < bytes.byteLength) {
          if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
            packet = bytes.subarray(startIndex, endIndex);
            type2 = probe.ts.parseType(packet, pmt.pid);
            switch (type2) {
              case "pat":
                pmt.pid = probe.ts.parsePat(packet);
                break;
              case "pmt":
                var table = probe.ts.parsePmt(packet);
                pmt.table = pmt.table || {};
                Object.keys(table).forEach(function(key) {
                  pmt.table[key] = table[key];
                });
                break;
            }
            startIndex += MP2T_PACKET_LENGTH;
            endIndex += MP2T_PACKET_LENGTH;
            continue;
          }
          startIndex++;
          endIndex++;
        }
      };
      var parseAudioPes_ = function parseAudioPes_2(bytes, pmt, result) {
        var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2, pesType, pusi, parsed;
        var endLoop = false;
        while (endIndex <= bytes.byteLength) {
          if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
            packet = bytes.subarray(startIndex, endIndex);
            type2 = probe.ts.parseType(packet, pmt.pid);
            switch (type2) {
              case "pes":
                pesType = probe.ts.parsePesType(packet, pmt.table);
                pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                if (pesType === "audio" && pusi) {
                  parsed = probe.ts.parsePesTime(packet);
                  if (parsed) {
                    parsed.type = "audio";
                    result.audio.push(parsed);
                    endLoop = true;
                  }
                }
                break;
            }
            if (endLoop) {
              break;
            }
            startIndex += MP2T_PACKET_LENGTH;
            endIndex += MP2T_PACKET_LENGTH;
            continue;
          }
          startIndex++;
          endIndex++;
        }
        endIndex = bytes.byteLength;
        startIndex = endIndex - MP2T_PACKET_LENGTH;
        endLoop = false;
        while (startIndex >= 0) {
          if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
            packet = bytes.subarray(startIndex, endIndex);
            type2 = probe.ts.parseType(packet, pmt.pid);
            switch (type2) {
              case "pes":
                pesType = probe.ts.parsePesType(packet, pmt.table);
                pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                if (pesType === "audio" && pusi) {
                  parsed = probe.ts.parsePesTime(packet);
                  if (parsed) {
                    parsed.type = "audio";
                    result.audio.push(parsed);
                    endLoop = true;
                  }
                }
                break;
            }
            if (endLoop) {
              break;
            }
            startIndex -= MP2T_PACKET_LENGTH;
            endIndex -= MP2T_PACKET_LENGTH;
            continue;
          }
          startIndex--;
          endIndex--;
        }
      };
      var parseVideoPes_ = function parseVideoPes_2(bytes, pmt, result) {
        var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2, pesType, pusi, parsed, frame, i2, pes;
        var endLoop = false;
        var currentFrame = {
          data: [],
          size: 0
        };
        while (endIndex < bytes.byteLength) {
          if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
            packet = bytes.subarray(startIndex, endIndex);
            type2 = probe.ts.parseType(packet, pmt.pid);
            switch (type2) {
              case "pes":
                pesType = probe.ts.parsePesType(packet, pmt.table);
                pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                if (pesType === "video") {
                  if (pusi && !endLoop) {
                    parsed = probe.ts.parsePesTime(packet);
                    if (parsed) {
                      parsed.type = "video";
                      result.video.push(parsed);
                      endLoop = true;
                    }
                  }
                  if (!result.firstKeyFrame) {
                    if (pusi) {
                      if (currentFrame.size !== 0) {
                        frame = new Uint8Array(currentFrame.size);
                        i2 = 0;
                        while (currentFrame.data.length) {
                          pes = currentFrame.data.shift();
                          frame.set(pes, i2);
                          i2 += pes.byteLength;
                        }
                        if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                          var firstKeyFrame = probe.ts.parsePesTime(frame);
                          if (firstKeyFrame) {
                            result.firstKeyFrame = firstKeyFrame;
                            result.firstKeyFrame.type = "video";
                          } else {
                            console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                          }
                        }
                        currentFrame.size = 0;
                      }
                    }
                    currentFrame.data.push(packet);
                    currentFrame.size += packet.byteLength;
                  }
                }
                break;
            }
            if (endLoop && result.firstKeyFrame) {
              break;
            }
            startIndex += MP2T_PACKET_LENGTH;
            endIndex += MP2T_PACKET_LENGTH;
            continue;
          }
          startIndex++;
          endIndex++;
        }
        endIndex = bytes.byteLength;
        startIndex = endIndex - MP2T_PACKET_LENGTH;
        endLoop = false;
        while (startIndex >= 0) {
          if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
            packet = bytes.subarray(startIndex, endIndex);
            type2 = probe.ts.parseType(packet, pmt.pid);
            switch (type2) {
              case "pes":
                pesType = probe.ts.parsePesType(packet, pmt.table);
                pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                if (pesType === "video" && pusi) {
                  parsed = probe.ts.parsePesTime(packet);
                  if (parsed) {
                    parsed.type = "video";
                    result.video.push(parsed);
                    endLoop = true;
                  }
                }
                break;
            }
            if (endLoop) {
              break;
            }
            startIndex -= MP2T_PACKET_LENGTH;
            endIndex -= MP2T_PACKET_LENGTH;
            continue;
          }
          startIndex--;
          endIndex--;
        }
      };
      var adjustTimestamp_ = function adjustTimestamp_2(segmentInfo, baseTimestamp) {
        if (segmentInfo.audio && segmentInfo.audio.length) {
          var audioBaseTimestamp = baseTimestamp;
          if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) {
            audioBaseTimestamp = segmentInfo.audio[0].dts;
          }
          segmentInfo.audio.forEach(function(info) {
            info.dts = handleRollover(info.dts, audioBaseTimestamp);
            info.pts = handleRollover(info.pts, audioBaseTimestamp);
            info.dtsTime = info.dts / ONE_SECOND_IN_TS;
            info.ptsTime = info.pts / ONE_SECOND_IN_TS;
          });
        }
        if (segmentInfo.video && segmentInfo.video.length) {
          var videoBaseTimestamp = baseTimestamp;
          if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) {
            videoBaseTimestamp = segmentInfo.video[0].dts;
          }
          segmentInfo.video.forEach(function(info) {
            info.dts = handleRollover(info.dts, videoBaseTimestamp);
            info.pts = handleRollover(info.pts, videoBaseTimestamp);
            info.dtsTime = info.dts / ONE_SECOND_IN_TS;
            info.ptsTime = info.pts / ONE_SECOND_IN_TS;
          });
          if (segmentInfo.firstKeyFrame) {
            var frame = segmentInfo.firstKeyFrame;
            frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
            frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
            frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;
            frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;
          }
        }
      };
      var inspectAac_ = function inspectAac_2(bytes) {
        var endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0, packet;
        while (bytes.length - byteIndex >= 3) {
          var type2 = probe.aac.parseType(bytes, byteIndex);
          switch (type2) {
            case "timed-metadata":
              if (bytes.length - byteIndex < 10) {
                endLoop = true;
                break;
              }
              frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
              if (frameSize > bytes.length) {
                endLoop = true;
                break;
              }
              if (timestamp === null) {
                packet = bytes.subarray(byteIndex, byteIndex + frameSize);
                timestamp = probe.aac.parseAacTimestamp(packet);
              }
              byteIndex += frameSize;
              break;
            case "audio":
              if (bytes.length - byteIndex < 7) {
                endLoop = true;
                break;
              }
              frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
              if (frameSize > bytes.length) {
                endLoop = true;
                break;
              }
              if (sampleRate === null) {
                packet = bytes.subarray(byteIndex, byteIndex + frameSize);
                sampleRate = probe.aac.parseSampleRate(packet);
              }
              audioCount++;
              byteIndex += frameSize;
              break;
            default:
              byteIndex++;
              break;
          }
          if (endLoop) {
            return null;
          }
        }
        if (sampleRate === null || timestamp === null) {
          return null;
        }
        var audioTimescale = ONE_SECOND_IN_TS / sampleRate;
        var result = {
          audio: [{
            type: "audio",
            dts: timestamp,
            pts: timestamp
          }, {
            type: "audio",
            dts: timestamp + audioCount * 1024 * audioTimescale,
            pts: timestamp + audioCount * 1024 * audioTimescale
          }]
        };
        return result;
      };
      var inspectTs_ = function inspectTs_2(bytes) {
        var pmt = {
          pid: null,
          table: null
        };
        var result = {};
        parsePsi_(bytes, pmt);
        for (var pid in pmt.table) {
          if (pmt.table.hasOwnProperty(pid)) {
            var type2 = pmt.table[pid];
            switch (type2) {
              case streamTypes.H264_STREAM_TYPE:
                result.video = [];
                parseVideoPes_(bytes, pmt, result);
                if (result.video.length === 0) {
                  delete result.video;
                }
                break;
              case streamTypes.ADTS_STREAM_TYPE:
                result.audio = [];
                parseAudioPes_(bytes, pmt, result);
                if (result.audio.length === 0) {
                  delete result.audio;
                }
                break;
            }
          }
        }
        return result;
      };
      var inspect = function inspect2(bytes, baseTimestamp) {
        var isAacData = probe.aac.isLikelyAacData(bytes);
        var result;
        if (isAacData) {
          result = inspectAac_(bytes);
        } else {
          result = inspectTs_(bytes);
        }
        if (!result || !result.audio && !result.video) {
          return null;
        }
        adjustTimestamp_(result, baseTimestamp);
        return result;
      };
      var tsInspector = {
        inspect,
        parseAudioPes_
      };
      var wireTransmuxerEvents = function wireTransmuxerEvents2(self2, transmuxer2) {
        transmuxer2.on("data", function(segment) {
          var initArray = segment.initSegment;
          segment.initSegment = {
            data: initArray.buffer,
            byteOffset: initArray.byteOffset,
            byteLength: initArray.byteLength
          };
          var typedArray = segment.data;
          segment.data = typedArray.buffer;
          self2.postMessage({
            action: "data",
            segment,
            byteOffset: typedArray.byteOffset,
            byteLength: typedArray.byteLength
          }, [segment.data]);
        });
        transmuxer2.on("done", function(data) {
          self2.postMessage({
            action: "done"
          });
        });
        transmuxer2.on("gopInfo", function(gopInfo) {
          self2.postMessage({
            action: "gopInfo",
            gopInfo
          });
        });
        transmuxer2.on("videoSegmentTimingInfo", function(timingInfo) {
          var videoSegmentTimingInfo = {
            start: {
              decode: clock2.videoTsToSeconds(timingInfo.start.dts),
              presentation: clock2.videoTsToSeconds(timingInfo.start.pts)
            },
            end: {
              decode: clock2.videoTsToSeconds(timingInfo.end.dts),
              presentation: clock2.videoTsToSeconds(timingInfo.end.pts)
            },
            baseMediaDecodeTime: clock2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
          };
          if (timingInfo.prependedContentDuration) {
            videoSegmentTimingInfo.prependedContentDuration = clock2.videoTsToSeconds(timingInfo.prependedContentDuration);
          }
          self2.postMessage({
            action: "videoSegmentTimingInfo",
            videoSegmentTimingInfo
          });
        });
        transmuxer2.on("audioSegmentTimingInfo", function(timingInfo) {
          var audioSegmentTimingInfo = {
            start: {
              decode: clock2.videoTsToSeconds(timingInfo.start.dts),
              presentation: clock2.videoTsToSeconds(timingInfo.start.pts)
            },
            end: {
              decode: clock2.videoTsToSeconds(timingInfo.end.dts),
              presentation: clock2.videoTsToSeconds(timingInfo.end.pts)
            },
            baseMediaDecodeTime: clock2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
          };
          if (timingInfo.prependedContentDuration) {
            audioSegmentTimingInfo.prependedContentDuration = clock2.videoTsToSeconds(timingInfo.prependedContentDuration);
          }
          self2.postMessage({
            action: "audioSegmentTimingInfo",
            audioSegmentTimingInfo
          });
        });
        transmuxer2.on("id3Frame", function(id3Frame) {
          self2.postMessage({
            action: "id3Frame",
            id3Frame
          });
        });
        transmuxer2.on("caption", function(caption) {
          self2.postMessage({
            action: "caption",
            caption
          });
        });
        transmuxer2.on("trackinfo", function(trackInfo) {
          self2.postMessage({
            action: "trackinfo",
            trackInfo
          });
        });
        transmuxer2.on("audioTimingInfo", function(audioTimingInfo) {
          self2.postMessage({
            action: "audioTimingInfo",
            audioTimingInfo: {
              start: clock2.videoTsToSeconds(audioTimingInfo.start),
              end: clock2.videoTsToSeconds(audioTimingInfo.end)
            }
          });
        });
        transmuxer2.on("videoTimingInfo", function(videoTimingInfo) {
          self2.postMessage({
            action: "videoTimingInfo",
            videoTimingInfo: {
              start: clock2.videoTsToSeconds(videoTimingInfo.start),
              end: clock2.videoTsToSeconds(videoTimingInfo.end)
            }
          });
        });
        transmuxer2.on("log", function(log3) {
          self2.postMessage({
            action: "log",
            log: log3
          });
        });
      };
      var MessageHandlers = /* @__PURE__ */ function() {
        function MessageHandlers2(self2, options) {
          this.options = options || {};
          this.self = self2;
          this.init();
        }
        var _proto = MessageHandlers2.prototype;
        _proto.init = function init() {
          if (this.transmuxer) {
            this.transmuxer.dispose();
          }
          this.transmuxer = new transmuxer.Transmuxer(this.options);
          wireTransmuxerEvents(this.self, this.transmuxer);
        };
        _proto.pushMp4Captions = function pushMp4Captions(data) {
          if (!this.captionParser) {
            this.captionParser = new captionParser();
            this.captionParser.init();
          }
          var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
          var parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
          this.self.postMessage({
            action: "mp4Captions",
            captions: parsed && parsed.captions || [],
            logs: parsed && parsed.logs || [],
            data: segment.buffer
          }, [segment.buffer]);
        };
        _proto.probeMp4StartTime = function probeMp4StartTime(_ref) {
          var timescales = _ref.timescales, data = _ref.data;
          var startTime2 = probe$2.startTime(timescales, data);
          this.self.postMessage({
            action: "probeMp4StartTime",
            startTime: startTime2,
            data
          }, [data.buffer]);
        };
        _proto.probeMp4Tracks = function probeMp4Tracks(_ref2) {
          var data = _ref2.data;
          var tracks = probe$2.tracks(data);
          this.self.postMessage({
            action: "probeMp4Tracks",
            tracks,
            data
          }, [data.buffer]);
        };
        _proto.probeTs = function probeTs(_ref3) {
          var data = _ref3.data, baseStartTime = _ref3.baseStartTime;
          var tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock2.ONE_SECOND_IN_TS : void 0;
          var timeInfo = tsInspector.inspect(data, tsStartTime);
          var result = null;
          if (timeInfo) {
            result = {
              hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
              hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
            };
            if (result.hasVideo) {
              result.videoStart = timeInfo.video[0].ptsTime;
            }
            if (result.hasAudio) {
              result.audioStart = timeInfo.audio[0].ptsTime;
            }
          }
          this.self.postMessage({
            action: "probeTs",
            result,
            data
          }, [data.buffer]);
        };
        _proto.clearAllMp4Captions = function clearAllMp4Captions() {
          if (this.captionParser) {
            this.captionParser.clearAllCaptions();
          }
        };
        _proto.clearParsedMp4Captions = function clearParsedMp4Captions() {
          if (this.captionParser) {
            this.captionParser.clearParsedCaptions();
          }
        };
        _proto.push = function push(data) {
          var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
          this.transmuxer.push(segment);
        };
        _proto.reset = function reset2() {
          this.transmuxer.reset();
        };
        _proto.setTimestampOffset = function setTimestampOffset(data) {
          var timestampOffset = data.timestampOffset || 0;
          this.transmuxer.setBaseMediaDecodeTime(Math.round(clock2.secondsToVideoTs(timestampOffset)));
        };
        _proto.setAudioAppendStart = function setAudioAppendStart(data) {
          this.transmuxer.setAudioAppendStart(Math.ceil(clock2.secondsToVideoTs(data.appendStart)));
        };
        _proto.setRemux = function setRemux(data) {
          this.transmuxer.setRemux(data.remux);
        };
        _proto.flush = function flush(data) {
          this.transmuxer.flush();
          self.postMessage({
            action: "done",
            type: "transmuxed"
          });
        };
        _proto.endTimeline = function endTimeline2() {
          this.transmuxer.endTimeline();
          self.postMessage({
            action: "endedtimeline",
            type: "transmuxed"
          });
        };
        _proto.alignGopsWith = function alignGopsWith(data) {
          this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
        };
        return MessageHandlers2;
      }();
      self.onmessage = function(event2) {
        if (event2.data.action === "init" && event2.data.options) {
          this.messageHandlers = new MessageHandlers(self, event2.data.options);
          return;
        }
        if (!this.messageHandlers) {
          this.messageHandlers = new MessageHandlers(self);
        }
        if (event2.data && event2.data.action && event2.data.action !== "init") {
          if (this.messageHandlers[event2.data.action]) {
            this.messageHandlers[event2.data.action](event2.data);
          }
        }
      };
    }));
    var TransmuxWorker = factory(workerCode$1);
    var handleData_ = function handleData_2(event2, transmuxedData, callback) {
      var _event$data$segment = event2.data.segment, type = _event$data$segment.type, initSegment = _event$data$segment.initSegment, captions = _event$data$segment.captions, captionStreams = _event$data$segment.captionStreams, metadata = _event$data$segment.metadata, videoFrameDtsTime = _event$data$segment.videoFrameDtsTime, videoFramePtsTime = _event$data$segment.videoFramePtsTime;
      transmuxedData.buffer.push({
        captions,
        captionStreams,
        metadata
      });
      var boxes = event2.data.segment.boxes || {
        data: event2.data.segment.data
      };
      var result = {
        type,
        data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
        initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
      };
      if (typeof videoFrameDtsTime !== "undefined") {
        result.videoFrameDtsTime = videoFrameDtsTime;
      }
      if (typeof videoFramePtsTime !== "undefined") {
        result.videoFramePtsTime = videoFramePtsTime;
      }
      callback(result);
    };
    var handleDone_ = function handleDone_2(_ref) {
      var transmuxedData = _ref.transmuxedData, callback = _ref.callback;
      transmuxedData.buffer = [];
      callback(transmuxedData);
    };
    var handleGopInfo_ = function handleGopInfo_2(event2, transmuxedData) {
      transmuxedData.gopInfo = event2.data.gopInfo;
    };
    var processTransmux = function processTransmux2(options) {
      var transmuxer = options.transmuxer, bytes = options.bytes, audioAppendStart = options.audioAppendStart, gopsToAlignWith = options.gopsToAlignWith, remux = options.remux, onData = options.onData, onTrackInfo = options.onTrackInfo, onAudioTimingInfo = options.onAudioTimingInfo, onVideoTimingInfo = options.onVideoTimingInfo, onVideoSegmentTimingInfo = options.onVideoSegmentTimingInfo, onAudioSegmentTimingInfo = options.onAudioSegmentTimingInfo, onId3 = options.onId3, onCaptions = options.onCaptions, onDone = options.onDone, onEndedTimeline = options.onEndedTimeline, onTransmuxerLog = options.onTransmuxerLog, isEndOfTimeline = options.isEndOfTimeline;
      var transmuxedData = {
        buffer: []
      };
      var waitForEndedTimelineEvent = isEndOfTimeline;
      var handleMessage = function handleMessage2(event2) {
        if (transmuxer.currentTransmux !== options) {
          return;
        }
        if (event2.data.action === "data") {
          handleData_(event2, transmuxedData, onData);
        }
        if (event2.data.action === "trackinfo") {
          onTrackInfo(event2.data.trackInfo);
        }
        if (event2.data.action === "gopInfo") {
          handleGopInfo_(event2, transmuxedData);
        }
        if (event2.data.action === "audioTimingInfo") {
          onAudioTimingInfo(event2.data.audioTimingInfo);
        }
        if (event2.data.action === "videoTimingInfo") {
          onVideoTimingInfo(event2.data.videoTimingInfo);
        }
        if (event2.data.action === "videoSegmentTimingInfo") {
          onVideoSegmentTimingInfo(event2.data.videoSegmentTimingInfo);
        }
        if (event2.data.action === "audioSegmentTimingInfo") {
          onAudioSegmentTimingInfo(event2.data.audioSegmentTimingInfo);
        }
        if (event2.data.action === "id3Frame") {
          onId3([event2.data.id3Frame], event2.data.id3Frame.dispatchType);
        }
        if (event2.data.action === "caption") {
          onCaptions(event2.data.caption);
        }
        if (event2.data.action === "endedtimeline") {
          waitForEndedTimelineEvent = false;
          onEndedTimeline();
        }
        if (event2.data.action === "log") {
          onTransmuxerLog(event2.data.log);
        }
        if (event2.data.type !== "transmuxed") {
          return;
        }
        if (waitForEndedTimelineEvent) {
          return;
        }
        transmuxer.onmessage = null;
        handleDone_({
          transmuxedData,
          callback: onDone
        });
        dequeue(transmuxer);
      };
      transmuxer.onmessage = handleMessage;
      if (audioAppendStart) {
        transmuxer.postMessage({
          action: "setAudioAppendStart",
          appendStart: audioAppendStart
        });
      }
      if (Array.isArray(gopsToAlignWith)) {
        transmuxer.postMessage({
          action: "alignGopsWith",
          gopsToAlignWith
        });
      }
      if (typeof remux !== "undefined") {
        transmuxer.postMessage({
          action: "setRemux",
          remux
        });
      }
      if (bytes.byteLength) {
        var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
        var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
        transmuxer.postMessage({
          action: "push",
          data: buffer,
          byteOffset,
          byteLength: bytes.byteLength
        }, [buffer]);
      }
      if (isEndOfTimeline) {
        transmuxer.postMessage({
          action: "endTimeline"
        });
      }
      transmuxer.postMessage({
        action: "flush"
      });
    };
    var dequeue = function dequeue2(transmuxer) {
      transmuxer.currentTransmux = null;
      if (transmuxer.transmuxQueue.length) {
        transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
        if (typeof transmuxer.currentTransmux === "function") {
          transmuxer.currentTransmux();
        } else {
          processTransmux(transmuxer.currentTransmux);
        }
      }
    };
    var processAction = function processAction2(transmuxer, action) {
      transmuxer.postMessage({
        action
      });
      dequeue(transmuxer);
    };
    var enqueueAction = function enqueueAction2(action, transmuxer) {
      if (!transmuxer.currentTransmux) {
        transmuxer.currentTransmux = action;
        processAction(transmuxer, action);
        return;
      }
      transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
    };
    var reset = function reset2(transmuxer) {
      enqueueAction("reset", transmuxer);
    };
    var endTimeline = function endTimeline2(transmuxer) {
      enqueueAction("endTimeline", transmuxer);
    };
    var transmux = function transmux2(options) {
      if (!options.transmuxer.currentTransmux) {
        options.transmuxer.currentTransmux = options;
        processTransmux(options);
        return;
      }
      options.transmuxer.transmuxQueue.push(options);
    };
    var createTransmuxer = function createTransmuxer2(options) {
      var transmuxer = new TransmuxWorker();
      transmuxer.currentTransmux = null;
      transmuxer.transmuxQueue = [];
      var term = transmuxer.terminate;
      transmuxer.terminate = function() {
        transmuxer.currentTransmux = null;
        transmuxer.transmuxQueue.length = 0;
        return term.call(transmuxer);
      };
      transmuxer.postMessage({
        action: "init",
        options
      });
      return transmuxer;
    };
    var segmentTransmuxer = {
      reset,
      endTimeline,
      transmux,
      createTransmuxer
    };
    var workerCallback = function workerCallback2(options) {
      var transmuxer = options.transmuxer;
      var endAction = options.endAction || options.action;
      var callback = options.callback;
      var message = _extends__default["default"]({}, options, {
        endAction: null,
        transmuxer: null,
        callback: null
      });
      var listenForEndEvent = function listenForEndEvent2(event2) {
        if (event2.data.action !== endAction) {
          return;
        }
        transmuxer.removeEventListener("message", listenForEndEvent2);
        if (event2.data.data) {
          event2.data.data = new Uint8Array(event2.data.data, options.byteOffset || 0, options.byteLength || event2.data.data.byteLength);
          if (options.data) {
            options.data = event2.data.data;
          }
        }
        callback(event2.data);
      };
      transmuxer.addEventListener("message", listenForEndEvent);
      if (options.data) {
        var isArrayBuffer = options.data instanceof ArrayBuffer;
        message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
        message.byteLength = options.data.byteLength;
        var transfers = [isArrayBuffer ? options.data : options.data.buffer];
        transmuxer.postMessage(message, transfers);
      } else {
        transmuxer.postMessage(message);
      }
    };
    var REQUEST_ERRORS = {
      FAILURE: 2,
      TIMEOUT: -101,
      ABORTED: -102
    };
    var abortAll = function abortAll2(activeXhrs) {
      activeXhrs.forEach(function(xhr) {
        xhr.abort();
      });
    };
    var getRequestStats = function getRequestStats2(request) {
      return {
        bandwidth: request.bandwidth,
        bytesReceived: request.bytesReceived || 0,
        roundTripTime: request.roundTripTime || 0
      };
    };
    var getProgressStats = function getProgressStats2(progressEvent) {
      var request = progressEvent.target;
      var roundTripTime = Date.now() - request.requestTime;
      var stats = {
        bandwidth: Infinity,
        bytesReceived: 0,
        roundTripTime: roundTripTime || 0
      };
      stats.bytesReceived = progressEvent.loaded;
      stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
      return stats;
    };
    var handleErrors = function handleErrors2(error, request) {
      if (request.timedout) {
        return {
          status: request.status,
          message: "HLS request timed-out at URL: " + request.uri,
          code: REQUEST_ERRORS.TIMEOUT,
          xhr: request
        };
      }
      if (request.aborted) {
        return {
          status: request.status,
          message: "HLS request aborted at URL: " + request.uri,
          code: REQUEST_ERRORS.ABORTED,
          xhr: request
        };
      }
      if (error) {
        return {
          status: request.status,
          message: "HLS request errored at URL: " + request.uri,
          code: REQUEST_ERRORS.FAILURE,
          xhr: request
        };
      }
      if (request.responseType === "arraybuffer" && request.response.byteLength === 0) {
        return {
          status: request.status,
          message: "Empty HLS response at URL: " + request.uri,
          code: REQUEST_ERRORS.FAILURE,
          xhr: request
        };
      }
      return null;
    };
    var handleKeyResponse = function handleKeyResponse2(segment, objects, finishProcessingFn) {
      return function(error, request) {
        var response = request.response;
        var errorObj = handleErrors(error, request);
        if (errorObj) {
          return finishProcessingFn(errorObj, segment);
        }
        if (response.byteLength !== 16) {
          return finishProcessingFn({
            status: request.status,
            message: "Invalid HLS key at URL: " + request.uri,
            code: REQUEST_ERRORS.FAILURE,
            xhr: request
          }, segment);
        }
        var view = new DataView(response);
        var bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);
        for (var i2 = 0; i2 < objects.length; i2++) {
          objects[i2].bytes = bytes;
        }
        return finishProcessingFn(null, segment);
      };
    };
    var parseInitSegment = function parseInitSegment2(segment, _callback) {
      var type = containers.detectContainerForBytes(segment.map.bytes);
      if (type !== "mp4") {
        var uri = segment.map.resolvedUri || segment.map.uri;
        return _callback({
          internal: true,
          message: "Found unsupported " + (type || "unknown") + " container for initialization segment at URL: " + uri,
          code: REQUEST_ERRORS.FAILURE
        });
      }
      workerCallback({
        action: "probeMp4Tracks",
        data: segment.map.bytes,
        transmuxer: segment.transmuxer,
        callback: function callback(_ref) {
          var tracks = _ref.tracks, data = _ref.data;
          segment.map.bytes = data;
          tracks.forEach(function(track) {
            segment.map.tracks = segment.map.tracks || {};
            if (segment.map.tracks[track.type]) {
              return;
            }
            segment.map.tracks[track.type] = track;
            if (typeof track.id === "number" && track.timescale) {
              segment.map.timescales = segment.map.timescales || {};
              segment.map.timescales[track.id] = track.timescale;
            }
          });
          return _callback(null);
        }
      });
    };
    var handleInitSegmentResponse = function handleInitSegmentResponse2(_ref2) {
      var segment = _ref2.segment, finishProcessingFn = _ref2.finishProcessingFn;
      return function(error, request) {
        var errorObj = handleErrors(error, request);
        if (errorObj) {
          return finishProcessingFn(errorObj, segment);
        }
        var bytes = new Uint8Array(request.response);
        if (segment.map.key) {
          segment.map.encryptedBytes = bytes;
          return finishProcessingFn(null, segment);
        }
        segment.map.bytes = bytes;
        parseInitSegment(segment, function(parseError) {
          if (parseError) {
            parseError.xhr = request;
            parseError.status = request.status;
            return finishProcessingFn(parseError, segment);
          }
          finishProcessingFn(null, segment);
        });
      };
    };
    var handleSegmentResponse = function handleSegmentResponse2(_ref3) {
      var segment = _ref3.segment, finishProcessingFn = _ref3.finishProcessingFn, responseType = _ref3.responseType;
      return function(error, request) {
        var errorObj = handleErrors(error, request);
        if (errorObj) {
          return finishProcessingFn(errorObj, segment);
        }
        var newBytes = responseType === "arraybuffer" || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));
        segment.stats = getRequestStats(request);
        if (segment.key) {
          segment.encryptedBytes = new Uint8Array(newBytes);
        } else {
          segment.bytes = new Uint8Array(newBytes);
        }
        return finishProcessingFn(null, segment);
      };
    };
    var transmuxAndNotify = function transmuxAndNotify2(_ref4) {
      var segment = _ref4.segment, bytes = _ref4.bytes, trackInfoFn = _ref4.trackInfoFn, timingInfoFn = _ref4.timingInfoFn, videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref4.audioSegmentTimingInfoFn, id3Fn = _ref4.id3Fn, captionsFn = _ref4.captionsFn, isEndOfTimeline = _ref4.isEndOfTimeline, endedTimelineFn = _ref4.endedTimelineFn, dataFn = _ref4.dataFn, doneFn = _ref4.doneFn, onTransmuxerLog = _ref4.onTransmuxerLog;
      var fmp4Tracks = segment.map && segment.map.tracks || {};
      var isMuxed2 = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
      var audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
      var audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
      var videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
      var videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
      var finish = function finish2() {
        return transmux({
          bytes,
          transmuxer: segment.transmuxer,
          audioAppendStart: segment.audioAppendStart,
          gopsToAlignWith: segment.gopsToAlignWith,
          remux: isMuxed2,
          onData: function onData(result) {
            result.type = result.type === "combined" ? "video" : result.type;
            dataFn(segment, result);
          },
          onTrackInfo: function onTrackInfo(trackInfo) {
            if (trackInfoFn) {
              if (isMuxed2) {
                trackInfo.isMuxed = true;
              }
              trackInfoFn(segment, trackInfo);
            }
          },
          onAudioTimingInfo: function onAudioTimingInfo(audioTimingInfo) {
            if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
              audioStartFn(audioTimingInfo.start);
              audioStartFn = null;
            }
            if (audioEndFn && typeof audioTimingInfo.end !== "undefined") {
              audioEndFn(audioTimingInfo.end);
            }
          },
          onVideoTimingInfo: function onVideoTimingInfo(videoTimingInfo) {
            if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
              videoStartFn(videoTimingInfo.start);
              videoStartFn = null;
            }
            if (videoEndFn && typeof videoTimingInfo.end !== "undefined") {
              videoEndFn(videoTimingInfo.end);
            }
          },
          onVideoSegmentTimingInfo: function onVideoSegmentTimingInfo(videoSegmentTimingInfo) {
            videoSegmentTimingInfoFn(videoSegmentTimingInfo);
          },
          onAudioSegmentTimingInfo: function onAudioSegmentTimingInfo(audioSegmentTimingInfo) {
            audioSegmentTimingInfoFn(audioSegmentTimingInfo);
          },
          onId3: function onId3(id3Frames, dispatchType) {
            id3Fn(segment, id3Frames, dispatchType);
          },
          onCaptions: function onCaptions(captions) {
            captionsFn(segment, [captions]);
          },
          isEndOfTimeline,
          onEndedTimeline: function onEndedTimeline() {
            endedTimelineFn();
          },
          onTransmuxerLog,
          onDone: function onDone(result) {
            if (!doneFn) {
              return;
            }
            result.type = result.type === "combined" ? "video" : result.type;
            doneFn(null, segment, result);
          }
        });
      };
      workerCallback({
        action: "probeTs",
        transmuxer: segment.transmuxer,
        data: bytes,
        baseStartTime: segment.baseStartTime,
        callback: function callback(data) {
          segment.bytes = bytes = data.data;
          var probeResult = data.result;
          if (probeResult) {
            trackInfoFn(segment, {
              hasAudio: probeResult.hasAudio,
              hasVideo: probeResult.hasVideo,
              isMuxed: isMuxed2
            });
            trackInfoFn = null;
            if (probeResult.hasAudio && !isMuxed2) {
              audioStartFn(probeResult.audioStart);
            }
            if (probeResult.hasVideo) {
              videoStartFn(probeResult.videoStart);
            }
            audioStartFn = null;
            videoStartFn = null;
          }
          finish();
        }
      });
    };
    var handleSegmentBytes = function handleSegmentBytes2(_ref5) {
      var segment = _ref5.segment, bytes = _ref5.bytes, trackInfoFn = _ref5.trackInfoFn, timingInfoFn = _ref5.timingInfoFn, videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref5.audioSegmentTimingInfoFn, id3Fn = _ref5.id3Fn, captionsFn = _ref5.captionsFn, isEndOfTimeline = _ref5.isEndOfTimeline, endedTimelineFn = _ref5.endedTimelineFn, dataFn = _ref5.dataFn, doneFn = _ref5.doneFn, onTransmuxerLog = _ref5.onTransmuxerLog;
      var bytesAsUint8Array = new Uint8Array(bytes);
      if (containers.isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
        segment.isFmp4 = true;
        var tracks = segment.map.tracks;
        var trackInfo = {
          isFmp4: true,
          hasVideo: !!tracks.video,
          hasAudio: !!tracks.audio
        };
        if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") {
          trackInfo.audioCodec = tracks.audio.codec;
        }
        if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") {
          trackInfo.videoCodec = tracks.video.codec;
        }
        if (tracks.video && tracks.audio) {
          trackInfo.isMuxed = true;
        }
        trackInfoFn(segment, trackInfo);
        var finishLoading = function finishLoading2(captions) {
          dataFn(segment, {
            data: bytesAsUint8Array,
            type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
          });
          if (captions && captions.length) {
            captionsFn(segment, captions);
          }
          doneFn(null, segment, {});
        };
        workerCallback({
          action: "probeMp4StartTime",
          timescales: segment.map.timescales,
          data: bytesAsUint8Array,
          transmuxer: segment.transmuxer,
          callback: function callback(_ref6) {
            var data = _ref6.data, startTime = _ref6.startTime;
            bytes = data.buffer;
            segment.bytes = bytesAsUint8Array = data;
            if (trackInfo.hasAudio && !trackInfo.isMuxed) {
              timingInfoFn(segment, "audio", "start", startTime);
            }
            if (trackInfo.hasVideo) {
              timingInfoFn(segment, "video", "start", startTime);
            }
            if (!tracks.video || !data.byteLength || !segment.transmuxer) {
              finishLoading();
              return;
            }
            workerCallback({
              action: "pushMp4Captions",
              endAction: "mp4Captions",
              transmuxer: segment.transmuxer,
              data: bytesAsUint8Array,
              timescales: segment.map.timescales,
              trackIds: [tracks.video.id],
              callback: function callback2(message) {
                bytes = message.data.buffer;
                segment.bytes = bytesAsUint8Array = message.data;
                message.logs.forEach(function(log3) {
                  onTransmuxerLog(videojs3.mergeOptions(log3, {
                    stream: "mp4CaptionParser"
                  }));
                });
                finishLoading(message.captions);
              }
            });
          }
        });
        return;
      }
      if (!segment.transmuxer) {
        doneFn(null, segment, {});
        return;
      }
      if (typeof segment.container === "undefined") {
        segment.container = containers.detectContainerForBytes(bytesAsUint8Array);
      }
      if (segment.container !== "ts" && segment.container !== "aac") {
        trackInfoFn(segment, {
          hasAudio: false,
          hasVideo: false
        });
        doneFn(null, segment, {});
        return;
      }
      transmuxAndNotify({
        segment,
        bytes,
        trackInfoFn,
        timingInfoFn,
        videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn,
        id3Fn,
        captionsFn,
        isEndOfTimeline,
        endedTimelineFn,
        dataFn,
        doneFn,
        onTransmuxerLog
      });
    };
    var decrypt = function decrypt2(_ref7, callback) {
      var id = _ref7.id, key = _ref7.key, encryptedBytes = _ref7.encryptedBytes, decryptionWorker = _ref7.decryptionWorker;
      var decryptionHandler = function decryptionHandler2(event2) {
        if (event2.data.source === id) {
          decryptionWorker.removeEventListener("message", decryptionHandler2);
          var decrypted = event2.data.decrypted;
          callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
        }
      };
      decryptionWorker.addEventListener("message", decryptionHandler);
      var keyBytes;
      if (key.bytes.slice) {
        keyBytes = key.bytes.slice();
      } else {
        keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
      }
      decryptionWorker.postMessage(createTransferableMessage({
        source: id,
        encrypted: encryptedBytes,
        key: keyBytes,
        iv: key.iv
      }), [encryptedBytes.buffer, keyBytes.buffer]);
    };
    var decryptSegment = function decryptSegment2(_ref8) {
      var decryptionWorker = _ref8.decryptionWorker, segment = _ref8.segment, trackInfoFn = _ref8.trackInfoFn, timingInfoFn = _ref8.timingInfoFn, videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref8.audioSegmentTimingInfoFn, id3Fn = _ref8.id3Fn, captionsFn = _ref8.captionsFn, isEndOfTimeline = _ref8.isEndOfTimeline, endedTimelineFn = _ref8.endedTimelineFn, dataFn = _ref8.dataFn, doneFn = _ref8.doneFn, onTransmuxerLog = _ref8.onTransmuxerLog;
      decrypt({
        id: segment.requestId,
        key: segment.key,
        encryptedBytes: segment.encryptedBytes,
        decryptionWorker
      }, function(decryptedBytes) {
        segment.bytes = decryptedBytes;
        handleSegmentBytes({
          segment,
          bytes: segment.bytes,
          trackInfoFn,
          timingInfoFn,
          videoSegmentTimingInfoFn,
          audioSegmentTimingInfoFn,
          id3Fn,
          captionsFn,
          isEndOfTimeline,
          endedTimelineFn,
          dataFn,
          doneFn,
          onTransmuxerLog
        });
      });
    };
    var waitForCompletion = function waitForCompletion2(_ref9) {
      var activeXhrs = _ref9.activeXhrs, decryptionWorker = _ref9.decryptionWorker, trackInfoFn = _ref9.trackInfoFn, timingInfoFn = _ref9.timingInfoFn, videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref9.audioSegmentTimingInfoFn, id3Fn = _ref9.id3Fn, captionsFn = _ref9.captionsFn, isEndOfTimeline = _ref9.isEndOfTimeline, endedTimelineFn = _ref9.endedTimelineFn, dataFn = _ref9.dataFn, doneFn = _ref9.doneFn, onTransmuxerLog = _ref9.onTransmuxerLog;
      var count = 0;
      var didError = false;
      return function(error, segment) {
        if (didError) {
          return;
        }
        if (error) {
          didError = true;
          abortAll(activeXhrs);
          return doneFn(error, segment);
        }
        count += 1;
        if (count === activeXhrs.length) {
          var segmentFinish = function segmentFinish2() {
            if (segment.encryptedBytes) {
              return decryptSegment({
                decryptionWorker,
                segment,
                trackInfoFn,
                timingInfoFn,
                videoSegmentTimingInfoFn,
                audioSegmentTimingInfoFn,
                id3Fn,
                captionsFn,
                isEndOfTimeline,
                endedTimelineFn,
                dataFn,
                doneFn,
                onTransmuxerLog
              });
            }
            handleSegmentBytes({
              segment,
              bytes: segment.bytes,
              trackInfoFn,
              timingInfoFn,
              videoSegmentTimingInfoFn,
              audioSegmentTimingInfoFn,
              id3Fn,
              captionsFn,
              isEndOfTimeline,
              endedTimelineFn,
              dataFn,
              doneFn,
              onTransmuxerLog
            });
          };
          segment.endOfAllRequests = Date.now();
          if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
            return decrypt({
              decryptionWorker,
              id: segment.requestId + "-init",
              encryptedBytes: segment.map.encryptedBytes,
              key: segment.map.key
            }, function(decryptedBytes) {
              segment.map.bytes = decryptedBytes;
              parseInitSegment(segment, function(parseError) {
                if (parseError) {
                  abortAll(activeXhrs);
                  return doneFn(parseError, segment);
                }
                segmentFinish();
              });
            });
          }
          segmentFinish();
        }
      };
    };
    var handleLoadEnd = function handleLoadEnd2(_ref10) {
      var loadendState = _ref10.loadendState, abortFn = _ref10.abortFn;
      return function(event2) {
        var request = event2.target;
        if (request.aborted && abortFn && !loadendState.calledAbortFn) {
          abortFn();
          loadendState.calledAbortFn = true;
        }
      };
    };
    var handleProgress = function handleProgress2(_ref11) {
      var segment = _ref11.segment, progressFn = _ref11.progressFn;
      _ref11.trackInfoFn;
      _ref11.timingInfoFn;
      _ref11.videoSegmentTimingInfoFn;
      _ref11.audioSegmentTimingInfoFn;
      _ref11.id3Fn;
      _ref11.captionsFn;
      _ref11.isEndOfTimeline;
      _ref11.endedTimelineFn;
      _ref11.dataFn;
      return function(event2) {
        var request = event2.target;
        if (request.aborted) {
          return;
        }
        segment.stats = videojs3.mergeOptions(segment.stats, getProgressStats(event2));
        if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {
          segment.stats.firstBytesReceivedAt = Date.now();
        }
        return progressFn(event2, segment);
      };
    };
    var mediaSegmentRequest = function mediaSegmentRequest2(_ref12) {
      var xhr = _ref12.xhr, xhrOptions = _ref12.xhrOptions, decryptionWorker = _ref12.decryptionWorker, segment = _ref12.segment, abortFn = _ref12.abortFn, progressFn = _ref12.progressFn, trackInfoFn = _ref12.trackInfoFn, timingInfoFn = _ref12.timingInfoFn, videoSegmentTimingInfoFn = _ref12.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref12.audioSegmentTimingInfoFn, id3Fn = _ref12.id3Fn, captionsFn = _ref12.captionsFn, isEndOfTimeline = _ref12.isEndOfTimeline, endedTimelineFn = _ref12.endedTimelineFn, dataFn = _ref12.dataFn, doneFn = _ref12.doneFn, onTransmuxerLog = _ref12.onTransmuxerLog;
      var activeXhrs = [];
      var finishProcessingFn = waitForCompletion({
        activeXhrs,
        decryptionWorker,
        trackInfoFn,
        timingInfoFn,
        videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn,
        id3Fn,
        captionsFn,
        isEndOfTimeline,
        endedTimelineFn,
        dataFn,
        doneFn,
        onTransmuxerLog
      });
      if (segment.key && !segment.key.bytes) {
        var objects = [segment.key];
        if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {
          objects.push(segment.map.key);
        }
        var keyRequestOptions = videojs3.mergeOptions(xhrOptions, {
          uri: segment.key.resolvedUri,
          responseType: "arraybuffer"
        });
        var keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);
        var keyXhr = xhr(keyRequestOptions, keyRequestCallback);
        activeXhrs.push(keyXhr);
      }
      if (segment.map && !segment.map.bytes) {
        var differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
        if (differentMapKey) {
          var mapKeyRequestOptions = videojs3.mergeOptions(xhrOptions, {
            uri: segment.map.key.resolvedUri,
            responseType: "arraybuffer"
          });
          var mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);
          var mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
          activeXhrs.push(mapKeyXhr);
        }
        var initSegmentOptions = videojs3.mergeOptions(xhrOptions, {
          uri: segment.map.resolvedUri,
          responseType: "arraybuffer",
          headers: segmentXhrHeaders(segment.map)
        });
        var initSegmentRequestCallback = handleInitSegmentResponse({
          segment,
          finishProcessingFn
        });
        var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
        activeXhrs.push(initSegmentXhr);
      }
      var segmentRequestOptions = videojs3.mergeOptions(xhrOptions, {
        uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
        responseType: "arraybuffer",
        headers: segmentXhrHeaders(segment)
      });
      var segmentRequestCallback = handleSegmentResponse({
        segment,
        finishProcessingFn,
        responseType: segmentRequestOptions.responseType
      });
      var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
      segmentXhr.addEventListener("progress", handleProgress({
        segment,
        progressFn,
        trackInfoFn,
        timingInfoFn,
        videoSegmentTimingInfoFn,
        audioSegmentTimingInfoFn,
        id3Fn,
        captionsFn,
        isEndOfTimeline,
        endedTimelineFn,
        dataFn
      }));
      activeXhrs.push(segmentXhr);
      var loadendState = {};
      activeXhrs.forEach(function(activeXhr) {
        activeXhr.addEventListener("loadend", handleLoadEnd({
          loadendState,
          abortFn
        }));
      });
      return function() {
        return abortAll(activeXhrs);
      };
    };
    var logFn$1 = logger("CodecUtils");
    var getCodecs = function getCodecs2(media) {
      var mediaAttributes = media.attributes || {};
      if (mediaAttributes.CODECS) {
        return codecs_js.parseCodecs(mediaAttributes.CODECS);
      }
    };
    var isMaat = function isMaat2(master, media) {
      var mediaAttributes = media.attributes || {};
      return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
    };
    var isMuxed = function isMuxed2(master, media) {
      if (!isMaat(master, media)) {
        return true;
      }
      var mediaAttributes = media.attributes || {};
      var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
      for (var groupId in audioGroup) {
        if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {
          return true;
        }
      }
      return false;
    };
    var unwrapCodecList = function unwrapCodecList2(codecList) {
      var codecs = {};
      codecList.forEach(function(_ref) {
        var mediaType = _ref.mediaType, type = _ref.type, details = _ref.details;
        codecs[mediaType] = codecs[mediaType] || [];
        codecs[mediaType].push(codecs_js.translateLegacyCodec("" + type + details));
      });
      Object.keys(codecs).forEach(function(mediaType) {
        if (codecs[mediaType].length > 1) {
          logFn$1("multiple " + mediaType + " codecs found as attributes: " + codecs[mediaType].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.");
          codecs[mediaType] = null;
          return;
        }
        codecs[mediaType] = codecs[mediaType][0];
      });
      return codecs;
    };
    var codecCount = function codecCount2(codecObj) {
      var count = 0;
      if (codecObj.audio) {
        count++;
      }
      if (codecObj.video) {
        count++;
      }
      return count;
    };
    var codecsForPlaylist = function codecsForPlaylist2(master, media) {
      var mediaAttributes = media.attributes || {};
      var codecInfo = unwrapCodecList(getCodecs(media) || []);
      if (isMaat(master, media) && !codecInfo.audio) {
        if (!isMuxed(master, media)) {
          var defaultCodecs = unwrapCodecList(codecs_js.codecsFromDefault(master, mediaAttributes.AUDIO) || []);
          if (defaultCodecs.audio) {
            codecInfo.audio = defaultCodecs.audio;
          }
        }
      }
      return codecInfo;
    };
    var logFn = logger("PlaylistSelector");
    var representationToString = function representationToString2(representation) {
      if (!representation || !representation.playlist) {
        return;
      }
      var playlist = representation.playlist;
      return JSON.stringify({
        id: playlist.id,
        bandwidth: representation.bandwidth,
        width: representation.width,
        height: representation.height,
        codecs: playlist.attributes && playlist.attributes.CODECS || ""
      });
    };
    var safeGetComputedStyle = function safeGetComputedStyle2(el, property) {
      if (!el) {
        return "";
      }
      var result = window__default["default"].getComputedStyle(el);
      if (!result) {
        return "";
      }
      return result[property];
    };
    var stableSort = function stableSort2(array, sortFn) {
      var newArray = array.slice();
      array.sort(function(left, right) {
        var cmp = sortFn(left, right);
        if (cmp === 0) {
          return newArray.indexOf(left) - newArray.indexOf(right);
        }
        return cmp;
      });
    };
    var comparePlaylistBandwidth = function comparePlaylistBandwidth2(left, right) {
      var leftBandwidth;
      var rightBandwidth;
      if (left.attributes.BANDWIDTH) {
        leftBandwidth = left.attributes.BANDWIDTH;
      }
      leftBandwidth = leftBandwidth || window__default["default"].Number.MAX_VALUE;
      if (right.attributes.BANDWIDTH) {
        rightBandwidth = right.attributes.BANDWIDTH;
      }
      rightBandwidth = rightBandwidth || window__default["default"].Number.MAX_VALUE;
      return leftBandwidth - rightBandwidth;
    };
    var comparePlaylistResolution = function comparePlaylistResolution2(left, right) {
      var leftWidth;
      var rightWidth;
      if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {
        leftWidth = left.attributes.RESOLUTION.width;
      }
      leftWidth = leftWidth || window__default["default"].Number.MAX_VALUE;
      if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {
        rightWidth = right.attributes.RESOLUTION.width;
      }
      rightWidth = rightWidth || window__default["default"].Number.MAX_VALUE;
      if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {
        return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;
      }
      return leftWidth - rightWidth;
    };
    var simpleSelector = function simpleSelector2(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, masterPlaylistController) {
      if (!master) {
        return;
      }
      var options = {
        bandwidth: playerBandwidth,
        width: playerWidth,
        height: playerHeight,
        limitRenditionByPlayerDimensions
      };
      var playlists = master.playlists;
      if (Playlist.isAudioOnly(master)) {
        playlists = masterPlaylistController.getAudioTrackPlaylists_();
        options.audioOnly = true;
      }
      var sortedPlaylistReps = playlists.map(function(playlist) {
        var bandwidth;
        var width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
        var height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
        bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;
        bandwidth = bandwidth || window__default["default"].Number.MAX_VALUE;
        return {
          bandwidth,
          width,
          height,
          playlist
        };
      });
      stableSort(sortedPlaylistReps, function(left, right) {
        return left.bandwidth - right.bandwidth;
      });
      sortedPlaylistReps = sortedPlaylistReps.filter(function(rep) {
        return !Playlist.isIncompatible(rep.playlist);
      });
      var enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
        return Playlist.isEnabled(rep.playlist);
      });
      if (!enabledPlaylistReps.length) {
        enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
          return !Playlist.isDisabled(rep.playlist);
        });
      }
      var bandwidthPlaylistReps = enabledPlaylistReps.filter(function(rep) {
        return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;
      });
      var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
      var bandwidthBestRep = bandwidthPlaylistReps.filter(function(rep) {
        return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
      })[0];
      if (limitRenditionByPlayerDimensions === false) {
        var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
        if (_chosenRep && _chosenRep.playlist) {
          var type = "sortedPlaylistReps";
          if (bandwidthBestRep) {
            type = "bandwidthBestRep";
          }
          if (enabledPlaylistReps[0]) {
            type = "enabledPlaylistReps";
          }
          logFn("choosing " + representationToString(_chosenRep) + " using " + type + " with options", options);
          return _chosenRep.playlist;
        }
        logFn("could not choose a playlist with options", options);
        return null;
      }
      var haveResolution = bandwidthPlaylistReps.filter(function(rep) {
        return rep.width && rep.height;
      });
      stableSort(haveResolution, function(left, right) {
        return left.width - right.width;
      });
      var resolutionBestRepList = haveResolution.filter(function(rep) {
        return rep.width === playerWidth && rep.height === playerHeight;
      });
      highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
      var resolutionBestRep = resolutionBestRepList.filter(function(rep) {
        return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
      })[0];
      var resolutionPlusOneList;
      var resolutionPlusOneSmallest;
      var resolutionPlusOneRep;
      if (!resolutionBestRep) {
        resolutionPlusOneList = haveResolution.filter(function(rep) {
          return rep.width > playerWidth || rep.height > playerHeight;
        });
        resolutionPlusOneSmallest = resolutionPlusOneList.filter(function(rep) {
          return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;
        });
        highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
        resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function(rep) {
          return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
        })[0];
      }
      var leastPixelDiffRep;
      if (masterPlaylistController.experimentalLeastPixelDiffSelector) {
        var leastPixelDiffList = haveResolution.map(function(rep) {
          rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
          return rep;
        });
        stableSort(leastPixelDiffList, function(left, right) {
          if (left.pixelDiff === right.pixelDiff) {
            return right.bandwidth - left.bandwidth;
          }
          return left.pixelDiff - right.pixelDiff;
        });
        leastPixelDiffRep = leastPixelDiffList[0];
      }
      var chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
      if (chosenRep && chosenRep.playlist) {
        var _type = "sortedPlaylistReps";
        if (leastPixelDiffRep) {
          _type = "leastPixelDiffRep";
        } else if (resolutionPlusOneRep) {
          _type = "resolutionPlusOneRep";
        } else if (resolutionBestRep) {
          _type = "resolutionBestRep";
        } else if (bandwidthBestRep) {
          _type = "bandwidthBestRep";
        } else if (enabledPlaylistReps[0]) {
          _type = "enabledPlaylistReps";
        }
        logFn("choosing " + representationToString(chosenRep) + " using " + _type + " with options", options);
        return chosenRep.playlist;
      }
      logFn("could not choose a playlist with options", options);
      return null;
    };
    var lastBandwidthSelector = function lastBandwidthSelector2() {
      var pixelRatio = this.useDevicePixelRatio ? window__default["default"].devicePixelRatio || 1 : 1;
      return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
    };
    var movingAverageBandwidthSelector = function movingAverageBandwidthSelector2(decay) {
      var average = -1;
      var lastSystemBandwidth = -1;
      if (decay < 0 || decay > 1) {
        throw new Error("Moving average bandwidth decay must be between 0 and 1.");
      }
      return function() {
        var pixelRatio = this.useDevicePixelRatio ? window__default["default"].devicePixelRatio || 1 : 1;
        if (average < 0) {
          average = this.systemBandwidth;
          lastSystemBandwidth = this.systemBandwidth;
        }
        if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
          average = decay * this.systemBandwidth + (1 - decay) * average;
          lastSystemBandwidth = this.systemBandwidth;
        }
        return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
      };
    };
    var minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector2(settings2) {
      var master = settings2.master, currentTime = settings2.currentTime, bandwidth = settings2.bandwidth, duration2 = settings2.duration, segmentDuration = settings2.segmentDuration, timeUntilRebuffer2 = settings2.timeUntilRebuffer, currentTimeline = settings2.currentTimeline, syncController = settings2.syncController;
      var compatiblePlaylists = master.playlists.filter(function(playlist) {
        return !Playlist.isIncompatible(playlist);
      });
      var enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
      if (!enabledPlaylists.length) {
        enabledPlaylists = compatiblePlaylists.filter(function(playlist) {
          return !Playlist.isDisabled(playlist);
        });
      }
      var bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, "BANDWIDTH"));
      var rebufferingEstimates = bandwidthPlaylists.map(function(playlist) {
        var syncPoint = syncController.getSyncPoint(playlist, duration2, currentTimeline, currentTime);
        var numRequests = syncPoint ? 1 : 2;
        var requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);
        var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer2;
        return {
          playlist,
          rebufferingImpact
        };
      });
      var noRebufferingPlaylists = rebufferingEstimates.filter(function(estimate) {
        return estimate.rebufferingImpact <= 0;
      });
      stableSort(noRebufferingPlaylists, function(a, b) {
        return comparePlaylistBandwidth(b.playlist, a.playlist);
      });
      if (noRebufferingPlaylists.length) {
        return noRebufferingPlaylists[0];
      }
      stableSort(rebufferingEstimates, function(a, b) {
        return a.rebufferingImpact - b.rebufferingImpact;
      });
      return rebufferingEstimates[0] || null;
    };
    var lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector2() {
      var _this = this;
      var playlists = this.playlists.master.playlists.filter(Playlist.isEnabled);
      stableSort(playlists, function(a, b) {
        return comparePlaylistBandwidth(a, b);
      });
      var playlistsWithVideo = playlists.filter(function(playlist) {
        return !!codecsForPlaylist(_this.playlists.master, playlist).video;
      });
      return playlistsWithVideo[0] || null;
    };
    var concatSegments = function concatSegments2(segmentObj) {
      var offset = 0;
      var tempBuffer;
      if (segmentObj.bytes) {
        tempBuffer = new Uint8Array(segmentObj.bytes);
        segmentObj.segments.forEach(function(segment) {
          tempBuffer.set(segment, offset);
          offset += segment.byteLength;
        });
      }
      return tempBuffer;
    };
    var createCaptionsTrackIfNotExists = function createCaptionsTrackIfNotExists2(inbandTextTracks, tech, captionStream) {
      if (!inbandTextTracks[captionStream]) {
        tech.trigger({
          type: "usage",
          name: "vhs-608"
        });
        tech.trigger({
          type: "usage",
          name: "hls-608"
        });
        var instreamId = captionStream;
        if (/^cc708_/.test(captionStream)) {
          instreamId = "SERVICE" + captionStream.split("_")[1];
        }
        var track = tech.textTracks().getTrackById(instreamId);
        if (track) {
          inbandTextTracks[captionStream] = track;
        } else {
          var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
          var label = captionStream;
          var language = captionStream;
          var def = false;
          var captionService = captionServices[instreamId];
          if (captionService) {
            label = captionService.label;
            language = captionService.language;
            def = captionService["default"];
          }
          inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
            kind: "captions",
            id: instreamId,
            "default": def,
            label,
            language
          }, false).track;
        }
      }
    };
    var addCaptionData = function addCaptionData2(_ref) {
      var inbandTextTracks = _ref.inbandTextTracks, captionArray = _ref.captionArray, timestampOffset = _ref.timestampOffset;
      if (!captionArray) {
        return;
      }
      var Cue = window__default["default"].WebKitDataCue || window__default["default"].VTTCue;
      captionArray.forEach(function(caption) {
        var track = caption.stream;
        inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));
      });
    };
    var deprecateOldCue = function deprecateOldCue2(cue) {
      Object.defineProperties(cue.frame, {
        id: {
          get: function get2() {
            videojs3.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
            return cue.value.key;
          }
        },
        value: {
          get: function get2() {
            videojs3.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
            return cue.value.data;
          }
        },
        privateData: {
          get: function get2() {
            videojs3.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
            return cue.value.data;
          }
        }
      });
    };
    var addMetadata = function addMetadata2(_ref2) {
      var inbandTextTracks = _ref2.inbandTextTracks, metadataArray = _ref2.metadataArray, timestampOffset = _ref2.timestampOffset, videoDuration = _ref2.videoDuration;
      if (!metadataArray) {
        return;
      }
      var Cue = window__default["default"].WebKitDataCue || window__default["default"].VTTCue;
      var metadataTrack = inbandTextTracks.metadataTrack_;
      if (!metadataTrack) {
        return;
      }
      metadataArray.forEach(function(metadata) {
        var time = metadata.cueTime + timestampOffset;
        if (typeof time !== "number" || window__default["default"].isNaN(time) || time < 0 || !(time < Infinity)) {
          return;
        }
        metadata.frames.forEach(function(frame) {
          var cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
          cue.frame = frame;
          cue.value = frame;
          deprecateOldCue(cue);
          metadataTrack.addCue(cue);
        });
      });
      if (!metadataTrack.cues || !metadataTrack.cues.length) {
        return;
      }
      var cues = metadataTrack.cues;
      var cuesArray = [];
      for (var i2 = 0; i2 < cues.length; i2++) {
        if (cues[i2]) {
          cuesArray.push(cues[i2]);
        }
      }
      var cuesGroupedByStartTime = cuesArray.reduce(function(obj2, cue) {
        var timeSlot = obj2[cue.startTime] || [];
        timeSlot.push(cue);
        obj2[cue.startTime] = timeSlot;
        return obj2;
      }, {});
      var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function(a, b) {
        return Number(a) - Number(b);
      });
      sortedStartTimes.forEach(function(startTime, idx) {
        var cueGroup = cuesGroupedByStartTime[startTime];
        var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;
        cueGroup.forEach(function(cue) {
          cue.endTime = nextTime;
        });
      });
    };
    var createMetadataTrackIfNotExists = function createMetadataTrackIfNotExists2(inbandTextTracks, dispatchType, tech) {
      if (inbandTextTracks.metadataTrack_) {
        return;
      }
      inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
        kind: "metadata",
        label: "Timed Metadata"
      }, false).track;
      inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
    };
    var removeCuesFromTrack = function removeCuesFromTrack2(start2, end2, track) {
      var i2;
      var cue;
      if (!track) {
        return;
      }
      if (!track.cues) {
        return;
      }
      i2 = track.cues.length;
      while (i2--) {
        cue = track.cues[i2];
        if (cue.startTime >= start2 && cue.endTime <= end2) {
          track.removeCue(cue);
        }
      }
    };
    var removeDuplicateCuesFromTrack = function removeDuplicateCuesFromTrack2(track) {
      var cues = track.cues;
      if (!cues) {
        return;
      }
      for (var i2 = 0; i2 < cues.length; i2++) {
        var duplicates = [];
        var occurrences = 0;
        for (var j = 0; j < cues.length; j++) {
          if (cues[i2].startTime === cues[j].startTime && cues[i2].endTime === cues[j].endTime && cues[i2].text === cues[j].text) {
            occurrences++;
            if (occurrences > 1) {
              duplicates.push(cues[j]);
            }
          }
        }
        if (duplicates.length) {
          duplicates.forEach(function(dupe) {
            return track.removeCue(dupe);
          });
        }
      }
    };
    var gopsSafeToAlignWith = function gopsSafeToAlignWith2(buffer, currentTime, mapping) {
      if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) {
        return [];
      }
      var currentTimePts = Math.ceil((currentTime - mapping + 3) * clock.ONE_SECOND_IN_TS);
      var i2;
      for (i2 = 0; i2 < buffer.length; i2++) {
        if (buffer[i2].pts > currentTimePts) {
          break;
        }
      }
      return buffer.slice(i2);
    };
    var updateGopBuffer = function updateGopBuffer2(buffer, gops, replace) {
      if (!gops.length) {
        return buffer;
      }
      if (replace) {
        return gops.slice();
      }
      var start2 = gops[0].pts;
      var i2 = 0;
      for (i2; i2 < buffer.length; i2++) {
        if (buffer[i2].pts >= start2) {
          break;
        }
      }
      return buffer.slice(0, i2).concat(gops);
    };
    var removeGopBuffer = function removeGopBuffer2(buffer, start2, end2, mapping) {
      var startPts = Math.ceil((start2 - mapping) * clock.ONE_SECOND_IN_TS);
      var endPts = Math.ceil((end2 - mapping) * clock.ONE_SECOND_IN_TS);
      var updatedBuffer = buffer.slice();
      var i2 = buffer.length;
      while (i2--) {
        if (buffer[i2].pts <= endPts) {
          break;
        }
      }
      if (i2 === -1) {
        return updatedBuffer;
      }
      var j = i2 + 1;
      while (j--) {
        if (buffer[j].pts <= startPts) {
          break;
        }
      }
      j = Math.max(j, 0);
      updatedBuffer.splice(j, i2 - j + 1);
      return updatedBuffer;
    };
    var shallowEqual = function shallowEqual2(a, b) {
      if (!a && !b || !a && b || a && !b) {
        return false;
      }
      if (a === b) {
        return true;
      }
      var akeys = Object.keys(a).sort();
      var bkeys = Object.keys(b).sort();
      if (akeys.length !== bkeys.length) {
        return false;
      }
      for (var i2 = 0; i2 < akeys.length; i2++) {
        var key = akeys[i2];
        if (key !== bkeys[i2]) {
          return false;
        }
        if (a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    };
    var QUOTA_EXCEEDED_ERR = 22;
    var getSyncSegmentCandidate = function getSyncSegmentCandidate2(currentTimeline, segments, targetTime) {
      segments = segments || [];
      var timelineSegments = [];
      var time = 0;
      for (var i2 = 0; i2 < segments.length; i2++) {
        var segment = segments[i2];
        if (currentTimeline === segment.timeline) {
          timelineSegments.push(i2);
          time += segment.duration;
          if (time > targetTime) {
            return i2;
          }
        }
      }
      if (timelineSegments.length === 0) {
        return 0;
      }
      return timelineSegments[timelineSegments.length - 1];
    };
    var MIN_BACK_BUFFER = 1;
    var CHECK_BUFFER_DELAY = 500;
    var finite = function finite2(num) {
      return typeof num === "number" && isFinite(num);
    };
    var MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
    var illegalMediaSwitch = function illegalMediaSwitch2(loaderType, startingMedia, trackInfo) {
      if (loaderType !== "main" || !startingMedia || !trackInfo) {
        return null;
      }
      if (!trackInfo.hasAudio && !trackInfo.hasVideo) {
        return "Neither audio nor video found in segment.";
      }
      if (startingMedia.hasVideo && !trackInfo.hasVideo) {
        return "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest.";
      }
      if (!startingMedia.hasVideo && trackInfo.hasVideo) {
        return "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest.";
      }
      return null;
    };
    var safeBackBufferTrimTime = function safeBackBufferTrimTime2(seekable2, currentTime, targetDuration) {
      var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
      if (seekable2.length) {
        trimTime = Math.max(trimTime, seekable2.start(0));
      }
      var maxTrimTime = currentTime - targetDuration;
      return Math.min(maxTrimTime, trimTime);
    };
    var segmentInfoString = function segmentInfoString2(segmentInfo) {
      var startOfSegment = segmentInfo.startOfSegment, duration2 = segmentInfo.duration, segment = segmentInfo.segment, part = segmentInfo.part, _segmentInfo$playlist = segmentInfo.playlist, seq = _segmentInfo$playlist.mediaSequence, id = _segmentInfo$playlist.id, _segmentInfo$playlist2 = _segmentInfo$playlist.segments, segments = _segmentInfo$playlist2 === void 0 ? [] : _segmentInfo$playlist2, index = segmentInfo.mediaIndex, partIndex = segmentInfo.partIndex, timeline = segmentInfo.timeline;
      var segmentLen = segments.length - 1;
      var selection = "mediaIndex/partIndex increment";
      if (segmentInfo.getMediaInfoForTime) {
        selection = "getMediaInfoForTime (" + segmentInfo.getMediaInfoForTime + ")";
      } else if (segmentInfo.isSyncRequest) {
        selection = "getSyncSegmentCandidate (isSyncRequest)";
      }
      if (segmentInfo.independent) {
        selection += " with independent " + segmentInfo.independent;
      }
      var hasPartIndex = typeof partIndex === "number";
      var name = segmentInfo.segment.uri ? "segment" : "pre-segment";
      var zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
        preloadSegment: segment
      }) - 1 : 0;
      return name + " [" + (seq + index) + "/" + (seq + segmentLen) + "]" + (hasPartIndex ? " part [" + partIndex + "/" + zeroBasedPartCount + "]" : "") + (" segment start/end [" + segment.start + " => " + segment.end + "]") + (hasPartIndex ? " part start/end [" + part.start + " => " + part.end + "]" : "") + (" startOfSegment [" + startOfSegment + "]") + (" duration [" + duration2 + "]") + (" timeline [" + timeline + "]") + (" selected by [" + selection + "]") + (" playlist [" + id + "]");
    };
    var timingInfoPropertyForMedia = function timingInfoPropertyForMedia2(mediaType) {
      return mediaType + "TimingInfo";
    };
    var timestampOffsetForSegment = function timestampOffsetForSegment2(_ref) {
      var segmentTimeline = _ref.segmentTimeline, currentTimeline = _ref.currentTimeline, startOfSegment = _ref.startOfSegment, buffered = _ref.buffered, overrideCheck = _ref.overrideCheck;
      if (!overrideCheck && segmentTimeline === currentTimeline) {
        return null;
      }
      if (segmentTimeline < currentTimeline) {
        return startOfSegment;
      }
      return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
    };
    var shouldWaitForTimelineChange = function shouldWaitForTimelineChange2(_ref2) {
      var timelineChangeController = _ref2.timelineChangeController, currentTimeline = _ref2.currentTimeline, segmentTimeline = _ref2.segmentTimeline, loaderType = _ref2.loaderType, audioDisabled = _ref2.audioDisabled;
      if (currentTimeline === segmentTimeline) {
        return false;
      }
      if (loaderType === "audio") {
        var lastMainTimelineChange = timelineChangeController.lastTimelineChange({
          type: "main"
        });
        return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
      }
      if (loaderType === "main" && audioDisabled) {
        var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
          type: "audio"
        });
        if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {
          return false;
        }
        return true;
      }
      return false;
    };
    var mediaDuration = function mediaDuration2(timingInfos) {
      var maxDuration = 0;
      ["video", "audio"].forEach(function(type) {
        var typeTimingInfo = timingInfos[type + "TimingInfo"];
        if (!typeTimingInfo) {
          return;
        }
        var start2 = typeTimingInfo.start, end2 = typeTimingInfo.end;
        var duration2;
        if (typeof start2 === "bigint" || typeof end2 === "bigint") {
          duration2 = window__default["default"].BigInt(end2) - window__default["default"].BigInt(start2);
        } else if (typeof start2 === "number" && typeof end2 === "number") {
          duration2 = end2 - start2;
        }
        if (typeof duration2 !== "undefined" && duration2 > maxDuration) {
          maxDuration = duration2;
        }
      });
      if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) {
        maxDuration = Number(maxDuration);
      }
      return maxDuration;
    };
    var segmentTooLong = function segmentTooLong2(_ref3) {
      var segmentDuration = _ref3.segmentDuration, maxDuration = _ref3.maxDuration;
      if (!segmentDuration) {
        return false;
      }
      return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
    };
    var getTroublesomeSegmentDurationMessage = function getTroublesomeSegmentDurationMessage2(segmentInfo, sourceType) {
      if (sourceType !== "hls") {
        return null;
      }
      var segmentDuration = mediaDuration({
        audioTimingInfo: segmentInfo.audioTimingInfo,
        videoTimingInfo: segmentInfo.videoTimingInfo
      });
      if (!segmentDuration) {
        return null;
      }
      var targetDuration = segmentInfo.playlist.targetDuration;
      var isSegmentWayTooLong = segmentTooLong({
        segmentDuration,
        maxDuration: targetDuration * 2
      });
      var isSegmentSlightlyTooLong = segmentTooLong({
        segmentDuration,
        maxDuration: targetDuration
      });
      var segmentTooLongMessage = "Segment with index " + segmentInfo.mediaIndex + " " + ("from playlist " + segmentInfo.playlist.id + " ") + ("has a duration of " + segmentDuration + " ") + ("when the reported duration is " + segmentInfo.duration + " ") + ("and the target duration is " + targetDuration + ". ") + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
      if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {
        return {
          severity: isSegmentWayTooLong ? "warn" : "info",
          message: segmentTooLongMessage
        };
      }
      return null;
    };
    var SegmentLoader = /* @__PURE__ */ function(_videojs$EventTarget) {
      _inheritsLoose__default["default"](SegmentLoader2, _videojs$EventTarget);
      function SegmentLoader2(settings2, options) {
        var _this;
        _this = _videojs$EventTarget.call(this) || this;
        if (!settings2) {
          throw new TypeError("Initialization settings are required");
        }
        if (typeof settings2.currentTime !== "function") {
          throw new TypeError("No currentTime getter specified");
        }
        if (!settings2.mediaSource) {
          throw new TypeError("No MediaSource specified");
        }
        _this.bandwidth = settings2.bandwidth;
        _this.throughput = {
          rate: 0,
          count: 0
        };
        _this.roundTrip = NaN;
        _this.resetStats_();
        _this.mediaIndex = null;
        _this.partIndex = null;
        _this.hasPlayed_ = settings2.hasPlayed;
        _this.currentTime_ = settings2.currentTime;
        _this.seekable_ = settings2.seekable;
        _this.seeking_ = settings2.seeking;
        _this.duration_ = settings2.duration;
        _this.mediaSource_ = settings2.mediaSource;
        _this.vhs_ = settings2.vhs;
        _this.loaderType_ = settings2.loaderType;
        _this.currentMediaInfo_ = void 0;
        _this.startingMediaInfo_ = void 0;
        _this.segmentMetadataTrack_ = settings2.segmentMetadataTrack;
        _this.goalBufferLength_ = settings2.goalBufferLength;
        _this.sourceType_ = settings2.sourceType;
        _this.sourceUpdater_ = settings2.sourceUpdater;
        _this.inbandTextTracks_ = settings2.inbandTextTracks;
        _this.state_ = "INIT";
        _this.timelineChangeController_ = settings2.timelineChangeController;
        _this.shouldSaveSegmentTimingInfo_ = true;
        _this.parse708captions_ = settings2.parse708captions;
        _this.useDtsForTimestampOffset_ = settings2.useDtsForTimestampOffset;
        _this.captionServices_ = settings2.captionServices;
        _this.experimentalExactManifestTimings = settings2.experimentalExactManifestTimings;
        _this.checkBufferTimeout_ = null;
        _this.error_ = void 0;
        _this.currentTimeline_ = -1;
        _this.pendingSegment_ = null;
        _this.xhrOptions_ = null;
        _this.pendingSegments_ = [];
        _this.audioDisabled_ = false;
        _this.isPendingTimestampOffset_ = false;
        _this.gopBuffer_ = [];
        _this.timeMapping_ = 0;
        _this.safeAppend_ = videojs3.browser.IE_VERSION >= 11;
        _this.appendInitSegment_ = {
          audio: true,
          video: true
        };
        _this.playlistOfLastInitSegment_ = {
          audio: null,
          video: null
        };
        _this.callQueue_ = [];
        _this.loadQueue_ = [];
        _this.metadataQueue_ = {
          id3: [],
          caption: []
        };
        _this.waitingOnRemove_ = false;
        _this.quotaExceededErrorRetryTimeout_ = null;
        _this.activeInitSegmentId_ = null;
        _this.initSegments_ = {};
        _this.cacheEncryptionKeys_ = settings2.cacheEncryptionKeys;
        _this.keyCache_ = {};
        _this.decrypter_ = settings2.decrypter;
        _this.syncController_ = settings2.syncController;
        _this.syncPoint_ = {
          segmentIndex: 0,
          time: 0
        };
        _this.transmuxer_ = _this.createTransmuxer_();
        _this.triggerSyncInfoUpdate_ = function() {
          return _this.trigger("syncinfoupdate");
        };
        _this.syncController_.on("syncinfoupdate", _this.triggerSyncInfoUpdate_);
        _this.mediaSource_.addEventListener("sourceopen", function() {
          if (!_this.isEndOfStream_()) {
            _this.ended_ = false;
          }
        });
        _this.fetchAtBuffer_ = false;
        _this.logger_ = logger("SegmentLoader[" + _this.loaderType_ + "]");
        Object.defineProperty(_assertThisInitialized__default["default"](_this), "state", {
          get: function get2() {
            return this.state_;
          },
          set: function set2(newState) {
            if (newState !== this.state_) {
              this.logger_(this.state_ + " -> " + newState);
              this.state_ = newState;
              this.trigger("statechange");
            }
          }
        });
        _this.sourceUpdater_.on("ready", function() {
          if (_this.hasEnoughInfoToAppend_()) {
            _this.processCallQueue_();
          }
        });
        if (_this.loaderType_ === "main") {
          _this.timelineChangeController_.on("pendingtimelinechange", function() {
            if (_this.hasEnoughInfoToAppend_()) {
              _this.processCallQueue_();
            }
          });
        }
        if (_this.loaderType_ === "audio") {
          _this.timelineChangeController_.on("timelinechange", function() {
            if (_this.hasEnoughInfoToLoad_()) {
              _this.processLoadQueue_();
            }
            if (_this.hasEnoughInfoToAppend_()) {
              _this.processCallQueue_();
            }
          });
        }
        return _this;
      }
      var _proto = SegmentLoader2.prototype;
      _proto.createTransmuxer_ = function createTransmuxer_() {
        return segmentTransmuxer.createTransmuxer({
          remux: false,
          alignGopsAtEnd: this.safeAppend_,
          keepOriginalTimestamps: true,
          parse708captions: this.parse708captions_,
          captionServices: this.captionServices_
        });
      };
      _proto.resetStats_ = function resetStats_() {
        this.mediaBytesTransferred = 0;
        this.mediaRequests = 0;
        this.mediaRequestsAborted = 0;
        this.mediaRequestsTimedout = 0;
        this.mediaRequestsErrored = 0;
        this.mediaTransferDuration = 0;
        this.mediaSecondsLoaded = 0;
        this.mediaAppends = 0;
      };
      _proto.dispose = function dispose() {
        this.trigger("dispose");
        this.state = "DISPOSED";
        this.pause();
        this.abort_();
        if (this.transmuxer_) {
          this.transmuxer_.terminate();
        }
        this.resetStats_();
        if (this.checkBufferTimeout_) {
          window__default["default"].clearTimeout(this.checkBufferTimeout_);
        }
        if (this.syncController_ && this.triggerSyncInfoUpdate_) {
          this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
        }
        this.off();
      };
      _proto.setAudio = function setAudio(enable) {
        this.audioDisabled_ = !enable;
        if (enable) {
          this.appendInitSegment_.audio = true;
        } else {
          this.sourceUpdater_.removeAudio(0, this.duration_());
        }
      };
      _proto.abort = function abort() {
        if (this.state !== "WAITING") {
          if (this.pendingSegment_) {
            this.pendingSegment_ = null;
          }
          return;
        }
        this.abort_();
        this.state = "READY";
        if (!this.paused()) {
          this.monitorBuffer_();
        }
      };
      _proto.abort_ = function abort_() {
        if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {
          this.pendingSegment_.abortRequests();
        }
        this.pendingSegment_ = null;
        this.callQueue_ = [];
        this.loadQueue_ = [];
        this.metadataQueue_.id3 = [];
        this.metadataQueue_.caption = [];
        this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
        this.waitingOnRemove_ = false;
        window__default["default"].clearTimeout(this.quotaExceededErrorRetryTimeout_);
        this.quotaExceededErrorRetryTimeout_ = null;
      };
      _proto.checkForAbort_ = function checkForAbort_(requestId) {
        if (this.state === "APPENDING" && !this.pendingSegment_) {
          this.state = "READY";
          return true;
        }
        if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {
          return true;
        }
        return false;
      };
      _proto.error = function error(_error) {
        if (typeof _error !== "undefined") {
          this.logger_("error occurred:", _error);
          this.error_ = _error;
        }
        this.pendingSegment_ = null;
        return this.error_;
      };
      _proto.endOfStream = function endOfStream() {
        this.ended_ = true;
        if (this.transmuxer_) {
          segmentTransmuxer.reset(this.transmuxer_);
        }
        this.gopBuffer_.length = 0;
        this.pause();
        this.trigger("ended");
      };
      _proto.buffered_ = function buffered_() {
        var trackInfo = this.getMediaInfo_();
        if (!this.sourceUpdater_ || !trackInfo) {
          return videojs3.createTimeRanges();
        }
        if (this.loaderType_ === "main") {
          var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed2 = trackInfo.isMuxed;
          if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed2) {
            return this.sourceUpdater_.buffered();
          }
          if (hasVideo) {
            return this.sourceUpdater_.videoBuffered();
          }
        }
        return this.sourceUpdater_.audioBuffered();
      };
      _proto.initSegmentForMap = function initSegmentForMap(map, set2) {
        if (set2 === void 0) {
          set2 = false;
        }
        if (!map) {
          return null;
        }
        var id = initSegmentId(map);
        var storedMap = this.initSegments_[id];
        if (set2 && !storedMap && map.bytes) {
          this.initSegments_[id] = storedMap = {
            resolvedUri: map.resolvedUri,
            byterange: map.byterange,
            bytes: map.bytes,
            tracks: map.tracks,
            timescales: map.timescales
          };
        }
        return storedMap || map;
      };
      _proto.segmentKey = function segmentKey(key, set2) {
        if (set2 === void 0) {
          set2 = false;
        }
        if (!key) {
          return null;
        }
        var id = segmentKeyId(key);
        var storedKey = this.keyCache_[id];
        if (this.cacheEncryptionKeys_ && set2 && !storedKey && key.bytes) {
          this.keyCache_[id] = storedKey = {
            resolvedUri: key.resolvedUri,
            bytes: key.bytes
          };
        }
        var result = {
          resolvedUri: (storedKey || key).resolvedUri
        };
        if (storedKey) {
          result.bytes = storedKey.bytes;
        }
        return result;
      };
      _proto.couldBeginLoading_ = function couldBeginLoading_() {
        return this.playlist_ && !this.paused();
      };
      _proto.load = function load() {
        this.monitorBuffer_();
        if (!this.playlist_) {
          return;
        }
        if (this.state === "INIT" && this.couldBeginLoading_()) {
          return this.init_();
        }
        if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") {
          return;
        }
        this.state = "READY";
      };
      _proto.init_ = function init_() {
        this.state = "READY";
        this.resetEverything();
        return this.monitorBuffer_();
      };
      _proto.playlist = function playlist(newPlaylist, options) {
        if (options === void 0) {
          options = {};
        }
        if (!newPlaylist) {
          return;
        }
        var oldPlaylist = this.playlist_;
        var segmentInfo = this.pendingSegment_;
        this.playlist_ = newPlaylist;
        this.xhrOptions_ = options;
        if (this.state === "INIT") {
          newPlaylist.syncInfo = {
            mediaSequence: newPlaylist.mediaSequence,
            time: 0
          };
          if (this.loaderType_ === "main") {
            this.syncController_.setDateTimeMappingForStart(newPlaylist);
          }
        }
        var oldId = null;
        if (oldPlaylist) {
          if (oldPlaylist.id) {
            oldId = oldPlaylist.id;
          } else if (oldPlaylist.uri) {
            oldId = oldPlaylist.uri;
          }
        }
        this.logger_("playlist update [" + oldId + " => " + (newPlaylist.id || newPlaylist.uri) + "]");
        this.trigger("syncinfoupdate");
        if (this.state === "INIT" && this.couldBeginLoading_()) {
          return this.init_();
        }
        if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
          if (this.mediaIndex !== null) {
            if (!newPlaylist.endList) {
              this.resetLoader();
            } else {
              this.resyncLoader();
            }
          }
          this.currentMediaInfo_ = void 0;
          this.trigger("playlistupdate");
          return;
        }
        var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
        this.logger_("live window shift [" + mediaSequenceDiff + "]");
        if (this.mediaIndex !== null) {
          this.mediaIndex -= mediaSequenceDiff;
          if (this.mediaIndex < 0) {
            this.mediaIndex = null;
            this.partIndex = null;
          } else {
            var segment = this.playlist_.segments[this.mediaIndex];
            if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
              var mediaIndex = this.mediaIndex;
              this.logger_("currently processing part (index " + this.partIndex + ") no longer exists.");
              this.resetLoader();
              this.mediaIndex = mediaIndex;
            }
          }
        }
        if (segmentInfo) {
          segmentInfo.mediaIndex -= mediaSequenceDiff;
          if (segmentInfo.mediaIndex < 0) {
            segmentInfo.mediaIndex = null;
            segmentInfo.partIndex = null;
          } else {
            if (segmentInfo.mediaIndex >= 0) {
              segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
            }
            if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {
              segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
            }
          }
        }
        this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
      };
      _proto.pause = function pause() {
        if (this.checkBufferTimeout_) {
          window__default["default"].clearTimeout(this.checkBufferTimeout_);
          this.checkBufferTimeout_ = null;
        }
      };
      _proto.paused = function paused() {
        return this.checkBufferTimeout_ === null;
      };
      _proto.resetEverything = function resetEverything(done) {
        this.ended_ = false;
        this.activeInitSegmentId_ = null;
        this.appendInitSegment_ = {
          audio: true,
          video: true
        };
        this.resetLoader();
        this.remove(0, Infinity, done);
        if (this.transmuxer_) {
          this.transmuxer_.postMessage({
            action: "clearAllMp4Captions"
          });
          this.transmuxer_.postMessage({
            action: "reset"
          });
        }
      };
      _proto.resetLoader = function resetLoader() {
        this.fetchAtBuffer_ = false;
        this.resyncLoader();
      };
      _proto.resyncLoader = function resyncLoader() {
        if (this.transmuxer_) {
          segmentTransmuxer.reset(this.transmuxer_);
        }
        this.mediaIndex = null;
        this.partIndex = null;
        this.syncPoint_ = null;
        this.isPendingTimestampOffset_ = false;
        this.callQueue_ = [];
        this.loadQueue_ = [];
        this.metadataQueue_.id3 = [];
        this.metadataQueue_.caption = [];
        this.abort();
        if (this.transmuxer_) {
          this.transmuxer_.postMessage({
            action: "clearParsedMp4Captions"
          });
        }
      };
      _proto.remove = function remove(start2, end2, done, force) {
        if (done === void 0) {
          done = function done2() {
          };
        }
        if (force === void 0) {
          force = false;
        }
        if (end2 === Infinity) {
          end2 = this.duration_();
        }
        if (end2 <= start2) {
          this.logger_("skipping remove because end ${end} is <= start ${start}");
          return;
        }
        if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
          this.logger_("skipping remove because no source updater or starting media info");
          return;
        }
        var removesRemaining = 1;
        var removeFinished = function removeFinished2() {
          removesRemaining--;
          if (removesRemaining === 0) {
            done();
          }
        };
        if (force || !this.audioDisabled_) {
          removesRemaining++;
          this.sourceUpdater_.removeAudio(start2, end2, removeFinished);
        }
        if (force || this.loaderType_ === "main") {
          this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start2, end2, this.timeMapping_);
          removesRemaining++;
          this.sourceUpdater_.removeVideo(start2, end2, removeFinished);
        }
        for (var track in this.inbandTextTracks_) {
          removeCuesFromTrack(start2, end2, this.inbandTextTracks_[track]);
        }
        removeCuesFromTrack(start2, end2, this.segmentMetadataTrack_);
        removeFinished();
      };
      _proto.monitorBuffer_ = function monitorBuffer_() {
        if (this.checkBufferTimeout_) {
          window__default["default"].clearTimeout(this.checkBufferTimeout_);
        }
        this.checkBufferTimeout_ = window__default["default"].setTimeout(this.monitorBufferTick_.bind(this), 1);
      };
      _proto.monitorBufferTick_ = function monitorBufferTick_() {
        if (this.state === "READY") {
          this.fillBuffer_();
        }
        if (this.checkBufferTimeout_) {
          window__default["default"].clearTimeout(this.checkBufferTimeout_);
        }
        this.checkBufferTimeout_ = window__default["default"].setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
      };
      _proto.fillBuffer_ = function fillBuffer_() {
        if (this.sourceUpdater_.updating()) {
          return;
        }
        var segmentInfo = this.chooseNextRequest_();
        if (!segmentInfo) {
          return;
        }
        if (typeof segmentInfo.timestampOffset === "number") {
          this.isPendingTimestampOffset_ = false;
          this.timelineChangeController_.pendingTimelineChange({
            type: this.loaderType_,
            from: this.currentTimeline_,
            to: segmentInfo.timeline
          });
        }
        this.loadSegment_(segmentInfo);
      };
      _proto.isEndOfStream_ = function isEndOfStream_(mediaIndex, playlist, partIndex) {
        if (mediaIndex === void 0) {
          mediaIndex = this.mediaIndex;
        }
        if (playlist === void 0) {
          playlist = this.playlist_;
        }
        if (partIndex === void 0) {
          partIndex = this.partIndex;
        }
        if (!playlist || !this.mediaSource_) {
          return false;
        }
        var segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
        var appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
        var appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
        return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
      };
      _proto.chooseNextRequest_ = function chooseNextRequest_() {
        var buffered = this.buffered_();
        var bufferedEnd = lastBufferedEnd(buffered) || 0;
        var bufferedTime = timeAheadOf(buffered, this.currentTime_());
        var preloaded = !this.hasPlayed_() && bufferedTime >= 1;
        var haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
        var segments = this.playlist_.segments;
        if (!segments.length || preloaded || haveEnoughBuffer) {
          return null;
        }
        this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
        var next = {
          partIndex: null,
          mediaIndex: null,
          startOfSegment: null,
          playlist: this.playlist_,
          isSyncRequest: Boolean(!this.syncPoint_)
        };
        if (next.isSyncRequest) {
          next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
        } else if (this.mediaIndex !== null) {
          var segment = segments[this.mediaIndex];
          var partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
          next.startOfSegment = segment.end ? segment.end : bufferedEnd;
          if (segment.parts && segment.parts[partIndex + 1]) {
            next.mediaIndex = this.mediaIndex;
            next.partIndex = partIndex + 1;
          } else {
            next.mediaIndex = this.mediaIndex + 1;
          }
        } else {
          var _Playlist$getMediaInf = Playlist.getMediaInfoForTime({
            experimentalExactManifestTimings: this.experimentalExactManifestTimings,
            playlist: this.playlist_,
            currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
            startingPartIndex: this.syncPoint_.partIndex,
            startingSegmentIndex: this.syncPoint_.segmentIndex,
            startTime: this.syncPoint_.time
          }), segmentIndex = _Playlist$getMediaInf.segmentIndex, startTime = _Playlist$getMediaInf.startTime, _partIndex = _Playlist$getMediaInf.partIndex;
          next.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + bufferedEnd : "currentTime " + this.currentTime_();
          next.mediaIndex = segmentIndex;
          next.startOfSegment = startTime;
          next.partIndex = _partIndex;
        }
        var nextSegment = segments[next.mediaIndex];
        var nextPart = nextSegment && typeof next.partIndex === "number" && nextSegment.parts && nextSegment.parts[next.partIndex];
        if (!nextSegment || typeof next.partIndex === "number" && !nextPart) {
          return null;
        }
        if (typeof next.partIndex !== "number" && nextSegment.parts) {
          next.partIndex = 0;
          nextPart = nextSegment.parts[0];
        }
        if (!bufferedTime && nextPart && !nextPart.independent) {
          if (next.partIndex === 0) {
            var lastSegment = segments[next.mediaIndex - 1];
            var lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
            if (lastSegmentLastPart && lastSegmentLastPart.independent) {
              next.mediaIndex -= 1;
              next.partIndex = lastSegment.parts.length - 1;
              next.independent = "previous segment";
            }
          } else if (nextSegment.parts[next.partIndex - 1].independent) {
            next.partIndex -= 1;
            next.independent = "previous part";
          }
        }
        var ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
        if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {
          return null;
        }
        return this.generateSegmentInfo_(next);
      };
      _proto.generateSegmentInfo_ = function generateSegmentInfo_(options) {
        var independent = options.independent, playlist = options.playlist, mediaIndex = options.mediaIndex, startOfSegment = options.startOfSegment, isSyncRequest = options.isSyncRequest, partIndex = options.partIndex, forceTimestampOffset = options.forceTimestampOffset, getMediaInfoForTime2 = options.getMediaInfoForTime;
        var segment = playlist.segments[mediaIndex];
        var part = typeof partIndex === "number" && segment.parts[partIndex];
        var segmentInfo = {
          requestId: "segment-loader-" + Math.random(),
          uri: part && part.resolvedUri || segment.resolvedUri,
          mediaIndex,
          partIndex: part ? partIndex : null,
          isSyncRequest,
          startOfSegment,
          playlist,
          bytes: null,
          encryptedBytes: null,
          timestampOffset: null,
          timeline: segment.timeline,
          duration: part && part.duration || segment.duration,
          segment,
          part,
          byteLength: 0,
          transmuxer: this.transmuxer_,
          getMediaInfoForTime: getMediaInfoForTime2,
          independent
        };
        var overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
        segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
          segmentTimeline: segment.timeline,
          currentTimeline: this.currentTimeline_,
          startOfSegment,
          buffered: this.buffered_(),
          overrideCheck
        });
        var audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
        if (typeof audioBufferedEnd === "number") {
          segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
        }
        if (this.sourceUpdater_.videoBuffered().length) {
          segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);
        }
        return segmentInfo;
      };
      _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_(options) {
        return timestampOffsetForSegment(options);
      };
      _proto.earlyAbortWhenNeeded_ = function earlyAbortWhenNeeded_(stats) {
        if (this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH) {
          return;
        }
        if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) {
          return;
        }
        var currentTime = this.currentTime_();
        var measuredBandwidth = stats.bandwidth;
        var segmentDuration = this.pendingSegment_.duration;
        var requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
        var timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
        if (requestTimeRemaining <= timeUntilRebuffer$1) {
          return;
        }
        var switchCandidate = minRebufferMaxBandwidthSelector({
          master: this.vhs_.playlists.master,
          currentTime,
          bandwidth: measuredBandwidth,
          duration: this.duration_(),
          segmentDuration,
          timeUntilRebuffer: timeUntilRebuffer$1,
          currentTimeline: this.currentTimeline_,
          syncController: this.syncController_
        });
        if (!switchCandidate) {
          return;
        }
        var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
        var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
        var minimumTimeSaving = 0.5;
        if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {
          minimumTimeSaving = 1;
        }
        if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {
          return;
        }
        this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
        this.trigger("earlyabort");
      };
      _proto.handleAbort_ = function handleAbort_(segmentInfo) {
        this.logger_("Aborting " + segmentInfoString(segmentInfo));
        this.mediaRequestsAborted += 1;
      };
      _proto.handleProgress_ = function handleProgress_(event2, simpleSegment) {
        this.earlyAbortWhenNeeded_(simpleSegment.stats);
        if (this.checkForAbort_(simpleSegment.requestId)) {
          return;
        }
        this.trigger("progress");
      };
      _proto.handleTrackInfo_ = function handleTrackInfo_(simpleSegment, trackInfo) {
        this.earlyAbortWhenNeeded_(simpleSegment.stats);
        if (this.checkForAbort_(simpleSegment.requestId)) {
          return;
        }
        if (this.checkForIllegalMediaSwitch(trackInfo)) {
          return;
        }
        trackInfo = trackInfo || {};
        if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {
          this.appendInitSegment_ = {
            audio: true,
            video: true
          };
          this.startingMediaInfo_ = trackInfo;
          this.currentMediaInfo_ = trackInfo;
          this.logger_("trackinfo update", trackInfo);
          this.trigger("trackinfo");
        }
        if (this.checkForAbort_(simpleSegment.requestId)) {
          return;
        }
        this.pendingSegment_.trackInfo = trackInfo;
        if (this.hasEnoughInfoToAppend_()) {
          this.processCallQueue_();
        }
      };
      _proto.handleTimingInfo_ = function handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
        this.earlyAbortWhenNeeded_(simpleSegment.stats);
        if (this.checkForAbort_(simpleSegment.requestId)) {
          return;
        }
        var segmentInfo = this.pendingSegment_;
        var timingInfoProperty = timingInfoPropertyForMedia(mediaType);
        segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
        segmentInfo[timingInfoProperty][timeType] = time;
        this.logger_("timinginfo: " + mediaType + " - " + timeType + " - " + time);
        if (this.hasEnoughInfoToAppend_()) {
          this.processCallQueue_();
        }
      };
      _proto.handleCaptions_ = function handleCaptions_(simpleSegment, captionData) {
        var _this2 = this;
        this.earlyAbortWhenNeeded_(simpleSegment.stats);
        if (this.checkForAbort_(simpleSegment.requestId)) {
          return;
        }
        if (captionData.length === 0) {
          this.logger_("SegmentLoader received no captions from a caption event");
          return;
        }
        var segmentInfo = this.pendingSegment_;
        if (!segmentInfo.hasAppendedData_) {
          this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
          return;
        }
        var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
        var captionTracks = {};
        captionData.forEach(function(caption) {
          captionTracks[caption.stream] = captionTracks[caption.stream] || {
            startTime: Infinity,
            captions: [],
            endTime: 0
          };
          var captionTrack = captionTracks[caption.stream];
          captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);
          captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);
          captionTrack.captions.push(caption);
        });
        Object.keys(captionTracks).forEach(function(trackName) {
          var _captionTracks$trackN = captionTracks[trackName], startTime = _captionTracks$trackN.startTime, endTime = _captionTracks$trackN.endTime, captions = _captionTracks$trackN.captions;
          var inbandTextTracks = _this2.inbandTextTracks_;
          _this2.logger_("adding cues from " + startTime + " -> " + endTime + " for " + trackName);
          createCaptionsTrackIfNotExists(inbandTextTracks, _this2.vhs_.tech_, trackName);
          removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
          addCaptionData({
            captionArray: captions,
            inbandTextTracks,
            timestampOffset
          });
        });
        if (this.transmuxer_) {
          this.transmuxer_.postMessage({
            action: "clearParsedMp4Captions"
          });
        }
      };
      _proto.handleId3_ = function handleId3_(simpleSegment, id3Frames, dispatchType) {
        this.earlyAbortWhenNeeded_(simpleSegment.stats);
        if (this.checkForAbort_(simpleSegment.requestId)) {
          return;
        }
        var segmentInfo = this.pendingSegment_;
        if (!segmentInfo.hasAppendedData_) {
          this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
          return;
        }
        var timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
        createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);
        addMetadata({
          inbandTextTracks: this.inbandTextTracks_,
          metadataArray: id3Frames,
          timestampOffset,
          videoDuration: this.duration_()
        });
      };
      _proto.processMetadataQueue_ = function processMetadataQueue_() {
        this.metadataQueue_.id3.forEach(function(fn) {
          return fn();
        });
        this.metadataQueue_.caption.forEach(function(fn) {
          return fn();
        });
        this.metadataQueue_.id3 = [];
        this.metadataQueue_.caption = [];
      };
      _proto.processCallQueue_ = function processCallQueue_() {
        var callQueue = this.callQueue_;
        this.callQueue_ = [];
        callQueue.forEach(function(fun) {
          return fun();
        });
      };
      _proto.processLoadQueue_ = function processLoadQueue_() {
        var loadQueue = this.loadQueue_;
        this.loadQueue_ = [];
        loadQueue.forEach(function(fun) {
          return fun();
        });
      };
      _proto.hasEnoughInfoToLoad_ = function hasEnoughInfoToLoad_() {
        if (this.loaderType_ !== "audio") {
          return true;
        }
        var segmentInfo = this.pendingSegment_;
        if (!segmentInfo) {
          return false;
        }
        if (!this.getCurrentMediaInfo_()) {
          return true;
        }
        if (shouldWaitForTimelineChange({
          timelineChangeController: this.timelineChangeController_,
          currentTimeline: this.currentTimeline_,
          segmentTimeline: segmentInfo.timeline,
          loaderType: this.loaderType_,
          audioDisabled: this.audioDisabled_
        })) {
          return false;
        }
        return true;
      };
      _proto.getCurrentMediaInfo_ = function getCurrentMediaInfo_(segmentInfo) {
        if (segmentInfo === void 0) {
          segmentInfo = this.pendingSegment_;
        }
        return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
      };
      _proto.getMediaInfo_ = function getMediaInfo_(segmentInfo) {
        if (segmentInfo === void 0) {
          segmentInfo = this.pendingSegment_;
        }
        return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
      };
      _proto.getPendingSegmentPlaylist = function getPendingSegmentPlaylist() {
        return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
      };
      _proto.hasEnoughInfoToAppend_ = function hasEnoughInfoToAppend_() {
        if (!this.sourceUpdater_.ready()) {
          return false;
        }
        if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {
          return false;
        }
        var segmentInfo = this.pendingSegment_;
        var trackInfo = this.getCurrentMediaInfo_();
        if (!segmentInfo || !trackInfo) {
          return false;
        }
        var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed2 = trackInfo.isMuxed;
        if (hasVideo && !segmentInfo.videoTimingInfo) {
          return false;
        }
        if (hasAudio && !this.audioDisabled_ && !isMuxed2 && !segmentInfo.audioTimingInfo) {
          return false;
        }
        if (shouldWaitForTimelineChange({
          timelineChangeController: this.timelineChangeController_,
          currentTimeline: this.currentTimeline_,
          segmentTimeline: segmentInfo.timeline,
          loaderType: this.loaderType_,
          audioDisabled: this.audioDisabled_
        })) {
          return false;
        }
        return true;
      };
      _proto.handleData_ = function handleData_2(simpleSegment, result) {
        this.earlyAbortWhenNeeded_(simpleSegment.stats);
        if (this.checkForAbort_(simpleSegment.requestId)) {
          return;
        }
        if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
          this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
          return;
        }
        var segmentInfo = this.pendingSegment_;
        this.setTimeMapping_(segmentInfo.timeline);
        this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
        if (this.mediaSource_.readyState === "closed") {
          return;
        }
        if (simpleSegment.map) {
          simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
          segmentInfo.segment.map = simpleSegment.map;
        }
        if (simpleSegment.key) {
          this.segmentKey(simpleSegment.key, true);
        }
        segmentInfo.isFmp4 = simpleSegment.isFmp4;
        segmentInfo.timingInfo = segmentInfo.timingInfo || {};
        if (segmentInfo.isFmp4) {
          this.trigger("fmp4");
          segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
        } else {
          var trackInfo = this.getCurrentMediaInfo_();
          var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
          var firstVideoFrameTimeForData;
          if (useVideoTimingInfo) {
            firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
          }
          segmentInfo.timingInfo.start = this.trueSegmentStart_({
            currentStart: segmentInfo.timingInfo.start,
            playlist: segmentInfo.playlist,
            mediaIndex: segmentInfo.mediaIndex,
            currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
            useVideoTimingInfo,
            firstVideoFrameTimeForData,
            videoTimingInfo: segmentInfo.videoTimingInfo,
            audioTimingInfo: segmentInfo.audioTimingInfo
          });
        }
        this.updateAppendInitSegmentStatus(segmentInfo, result.type);
        this.updateSourceBufferTimestampOffset_(segmentInfo);
        if (segmentInfo.isSyncRequest) {
          this.updateTimingInfoEnd_(segmentInfo);
          this.syncController_.saveSegmentTimingInfo({
            segmentInfo,
            shouldSaveTimelineMapping: this.loaderType_ === "main"
          });
          var next = this.chooseNextRequest_();
          if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
            this.logger_("sync segment was incorrect, not appending");
            return;
          }
          this.logger_("sync segment was correct, appending");
        }
        segmentInfo.hasAppendedData_ = true;
        this.processMetadataQueue_();
        this.appendData_(segmentInfo, result);
      };
      _proto.updateAppendInitSegmentStatus = function updateAppendInitSegmentStatus(segmentInfo, type) {
        if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && !segmentInfo.changedTimestampOffset) {
          this.appendInitSegment_ = {
            audio: true,
            video: true
          };
        }
        if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {
          this.appendInitSegment_[type] = true;
        }
      };
      _proto.getInitSegmentAndUpdateState_ = function getInitSegmentAndUpdateState_(_ref4) {
        var type = _ref4.type, initSegment = _ref4.initSegment, map = _ref4.map, playlist = _ref4.playlist;
        if (map) {
          var id = initSegmentId(map);
          if (this.activeInitSegmentId_ === id) {
            return null;
          }
          initSegment = this.initSegmentForMap(map, true).bytes;
          this.activeInitSegmentId_ = id;
        }
        if (initSegment && this.appendInitSegment_[type]) {
          this.playlistOfLastInitSegment_[type] = playlist;
          this.appendInitSegment_[type] = false;
          this.activeInitSegmentId_ = null;
          return initSegment;
        }
        return null;
      };
      _proto.handleQuotaExceededError_ = function handleQuotaExceededError_(_ref5, error) {
        var _this3 = this;
        var segmentInfo = _ref5.segmentInfo, type = _ref5.type, bytes = _ref5.bytes;
        var audioBuffered = this.sourceUpdater_.audioBuffered();
        var videoBuffered = this.sourceUpdater_.videoBuffered();
        if (audioBuffered.length > 1) {
          this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", "));
        }
        if (videoBuffered.length > 1) {
          this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
        }
        var audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
        var audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
        var videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
        var videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
        if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
          this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + ("Appended byte length: " + bytes.byteLength + ", ") + ("audio buffer: " + timeRangesToArray(audioBuffered).join(", ") + ", ") + ("video buffer: " + timeRangesToArray(videoBuffered).join(", ") + ", "));
          this.error({
            message: "Quota exceeded error with append of a single segment of content",
            excludeUntil: Infinity
          });
          this.trigger("error");
          return;
        }
        this.waitingOnRemove_ = true;
        this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
          segmentInfo,
          type,
          bytes
        }));
        var currentTime = this.currentTime_();
        var timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
        this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + timeToRemoveUntil);
        this.remove(0, timeToRemoveUntil, function() {
          _this3.logger_("On QUOTA_EXCEEDED_ERR, retrying append in " + MIN_BACK_BUFFER + "s");
          _this3.waitingOnRemove_ = false;
          _this3.quotaExceededErrorRetryTimeout_ = window__default["default"].setTimeout(function() {
            _this3.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
            _this3.quotaExceededErrorRetryTimeout_ = null;
            _this3.processCallQueue_();
          }, MIN_BACK_BUFFER * 1e3);
        }, true);
      };
      _proto.handleAppendError_ = function handleAppendError_(_ref6, error) {
        var segmentInfo = _ref6.segmentInfo, type = _ref6.type, bytes = _ref6.bytes;
        if (!error) {
          return;
        }
        if (error.code === QUOTA_EXCEEDED_ERR) {
          this.handleQuotaExceededError_({
            segmentInfo,
            type,
            bytes
          });
          return;
        }
        this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
        this.error(type + " append of " + bytes.length + "b failed for segment " + ("#" + segmentInfo.mediaIndex + " in playlist " + segmentInfo.playlist.id));
        this.trigger("appenderror");
      };
      _proto.appendToSourceBuffer_ = function appendToSourceBuffer_(_ref7) {
        var segmentInfo = _ref7.segmentInfo, type = _ref7.type, initSegment = _ref7.initSegment, data = _ref7.data, bytes = _ref7.bytes;
        if (!bytes) {
          var segments = [data];
          var byteLength = data.byteLength;
          if (initSegment) {
            segments.unshift(initSegment);
            byteLength += initSegment.byteLength;
          }
          bytes = concatSegments({
            bytes: byteLength,
            segments
          });
        }
        this.sourceUpdater_.appendBuffer({
          segmentInfo,
          type,
          bytes
        }, this.handleAppendError_.bind(this, {
          segmentInfo,
          type,
          bytes
        }));
      };
      _proto.handleSegmentTimingInfo_ = function handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {
        if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {
          return;
        }
        var segment = this.pendingSegment_.segment;
        var timingInfoProperty = type + "TimingInfo";
        if (!segment[timingInfoProperty]) {
          segment[timingInfoProperty] = {};
        }
        segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
        segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
        segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
        segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
        segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
        segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
      };
      _proto.appendData_ = function appendData_(segmentInfo, result) {
        var type = result.type, data = result.data;
        if (!data || !data.byteLength) {
          return;
        }
        if (type === "audio" && this.audioDisabled_) {
          return;
        }
        var initSegment = this.getInitSegmentAndUpdateState_({
          type,
          initSegment: result.initSegment,
          playlist: segmentInfo.playlist,
          map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
        });
        this.appendToSourceBuffer_({
          segmentInfo,
          type,
          initSegment,
          data
        });
      };
      _proto.loadSegment_ = function loadSegment_(segmentInfo) {
        var _this4 = this;
        this.state = "WAITING";
        this.pendingSegment_ = segmentInfo;
        this.trimBackBuffer_(segmentInfo);
        if (typeof segmentInfo.timestampOffset === "number") {
          if (this.transmuxer_) {
            this.transmuxer_.postMessage({
              action: "clearAllMp4Captions"
            });
          }
        }
        if (!this.hasEnoughInfoToLoad_()) {
          this.loadQueue_.push(function() {
            var options = _extends__default["default"]({}, segmentInfo, {
              forceTimestampOffset: true
            });
            _extends__default["default"](segmentInfo, _this4.generateSegmentInfo_(options));
            _this4.isPendingTimestampOffset_ = false;
            _this4.updateTransmuxerAndRequestSegment_(segmentInfo);
          });
          return;
        }
        this.updateTransmuxerAndRequestSegment_(segmentInfo);
      };
      _proto.updateTransmuxerAndRequestSegment_ = function updateTransmuxerAndRequestSegment_(segmentInfo) {
        var _this5 = this;
        if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
          this.gopBuffer_.length = 0;
          segmentInfo.gopsToAlignWith = [];
          this.timeMapping_ = 0;
          this.transmuxer_.postMessage({
            action: "reset"
          });
          this.transmuxer_.postMessage({
            action: "setTimestampOffset",
            timestampOffset: segmentInfo.timestampOffset
          });
        }
        var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
        var isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
        var isWalkingForward = this.mediaIndex !== null;
        var isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && segmentInfo.timeline > 0;
        var isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
        this.logger_("Requesting " + segmentInfoString(segmentInfo));
        if (simpleSegment.map && !simpleSegment.map.bytes) {
          this.logger_("going to request init segment.");
          this.appendInitSegment_ = {
            video: true,
            audio: true
          };
        }
        segmentInfo.abortRequests = mediaSegmentRequest({
          xhr: this.vhs_.xhr,
          xhrOptions: this.xhrOptions_,
          decryptionWorker: this.decrypter_,
          segment: simpleSegment,
          abortFn: this.handleAbort_.bind(this, segmentInfo),
          progressFn: this.handleProgress_.bind(this),
          trackInfoFn: this.handleTrackInfo_.bind(this),
          timingInfoFn: this.handleTimingInfo_.bind(this),
          videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
          audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
          captionsFn: this.handleCaptions_.bind(this),
          isEndOfTimeline,
          endedTimelineFn: function endedTimelineFn() {
            _this5.logger_("received endedtimeline callback");
          },
          id3Fn: this.handleId3_.bind(this),
          dataFn: this.handleData_.bind(this),
          doneFn: this.segmentRequestFinished_.bind(this),
          onTransmuxerLog: function onTransmuxerLog(_ref8) {
            var message = _ref8.message, level = _ref8.level, stream = _ref8.stream;
            _this5.logger_(segmentInfoString(segmentInfo) + " logged from transmuxer stream " + stream + " as a " + level + ": " + message);
          }
        });
      };
      _proto.trimBackBuffer_ = function trimBackBuffer_(segmentInfo) {
        var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
        if (removeToTime > 0) {
          this.remove(0, removeToTime);
        }
      };
      _proto.createSimplifiedSegmentObj_ = function createSimplifiedSegmentObj_(segmentInfo) {
        var segment = segmentInfo.segment;
        var part = segmentInfo.part;
        var simpleSegment = {
          resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
          byterange: part ? part.byterange : segment.byterange,
          requestId: segmentInfo.requestId,
          transmuxer: segmentInfo.transmuxer,
          audioAppendStart: segmentInfo.audioAppendStart,
          gopsToAlignWith: segmentInfo.gopsToAlignWith,
          part: segmentInfo.part
        };
        var previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
        if (previousSegment && previousSegment.timeline === segment.timeline) {
          if (previousSegment.videoTimingInfo) {
            simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;
          } else if (previousSegment.audioTimingInfo) {
            simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
          }
        }
        if (segment.key) {
          var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);
          simpleSegment.key = this.segmentKey(segment.key);
          simpleSegment.key.iv = iv;
        }
        if (segment.map) {
          simpleSegment.map = this.initSegmentForMap(segment.map);
        }
        return simpleSegment;
      };
      _proto.saveTransferStats_ = function saveTransferStats_(stats) {
        this.mediaRequests += 1;
        if (stats) {
          this.mediaBytesTransferred += stats.bytesReceived;
          this.mediaTransferDuration += stats.roundTripTime;
        }
      };
      _proto.saveBandwidthRelatedStats_ = function saveBandwidthRelatedStats_(duration2, stats) {
        this.pendingSegment_.byteLength = stats.bytesReceived;
        if (duration2 < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
          this.logger_("Ignoring segment's bandwidth because its duration of " + duration2 + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
          return;
        }
        this.bandwidth = stats.bandwidth;
        this.roundTrip = stats.roundTripTime;
      };
      _proto.handleTimeout_ = function handleTimeout_() {
        this.mediaRequestsTimedout += 1;
        this.bandwidth = 1;
        this.roundTrip = NaN;
        this.trigger("bandwidthupdate");
        this.trigger("timeout");
      };
      _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
        if (this.callQueue_.length) {
          this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
          return;
        }
        this.saveTransferStats_(simpleSegment.stats);
        if (!this.pendingSegment_) {
          return;
        }
        if (simpleSegment.requestId !== this.pendingSegment_.requestId) {
          return;
        }
        if (error) {
          this.pendingSegment_ = null;
          this.state = "READY";
          if (error.code === REQUEST_ERRORS.ABORTED) {
            return;
          }
          this.pause();
          if (error.code === REQUEST_ERRORS.TIMEOUT) {
            this.handleTimeout_();
            return;
          }
          this.mediaRequestsErrored += 1;
          this.error(error);
          this.trigger("error");
          return;
        }
        var segmentInfo = this.pendingSegment_;
        this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
        segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
        if (result.gopInfo) {
          this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
        }
        this.state = "APPENDING";
        this.trigger("appending");
        this.waitForAppendsToComplete_(segmentInfo);
      };
      _proto.setTimeMapping_ = function setTimeMapping_(timeline) {
        var timelineMapping = this.syncController_.mappingForTimeline(timeline);
        if (timelineMapping !== null) {
          this.timeMapping_ = timelineMapping;
        }
      };
      _proto.updateMediaSecondsLoaded_ = function updateMediaSecondsLoaded_(segment) {
        if (typeof segment.start === "number" && typeof segment.end === "number") {
          this.mediaSecondsLoaded += segment.end - segment.start;
        } else {
          this.mediaSecondsLoaded += segment.duration;
        }
      };
      _proto.shouldUpdateTransmuxerTimestampOffset_ = function shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {
        if (timestampOffset === null) {
          return false;
        }
        if (this.loaderType_ === "main" && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
          return true;
        }
        if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
          return true;
        }
        return false;
      };
      _proto.trueSegmentStart_ = function trueSegmentStart_(_ref9) {
        var currentStart = _ref9.currentStart, playlist = _ref9.playlist, mediaIndex = _ref9.mediaIndex, firstVideoFrameTimeForData = _ref9.firstVideoFrameTimeForData, currentVideoTimestampOffset = _ref9.currentVideoTimestampOffset, useVideoTimingInfo = _ref9.useVideoTimingInfo, videoTimingInfo = _ref9.videoTimingInfo, audioTimingInfo = _ref9.audioTimingInfo;
        if (typeof currentStart !== "undefined") {
          return currentStart;
        }
        if (!useVideoTimingInfo) {
          return audioTimingInfo.start;
        }
        var previousSegment = playlist.segments[mediaIndex - 1];
        if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {
          return firstVideoFrameTimeForData;
        }
        return videoTimingInfo.start;
      };
      _proto.waitForAppendsToComplete_ = function waitForAppendsToComplete_(segmentInfo) {
        var trackInfo = this.getCurrentMediaInfo_(segmentInfo);
        if (!trackInfo) {
          this.error({
            message: "No starting media returned, likely due to an unsupported media format.",
            blacklistDuration: Infinity
          });
          this.trigger("error");
          return;
        }
        var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed2 = trackInfo.isMuxed;
        var waitForVideo = this.loaderType_ === "main" && hasVideo;
        var waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed2;
        segmentInfo.waitingOnAppends = 0;
        if (!segmentInfo.hasAppendedData_) {
          if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") {
            this.isPendingTimestampOffset_ = true;
          }
          segmentInfo.timingInfo = {
            start: 0
          };
          segmentInfo.waitingOnAppends++;
          if (!this.isPendingTimestampOffset_) {
            this.updateSourceBufferTimestampOffset_(segmentInfo);
            this.processMetadataQueue_();
          }
          this.checkAppendsDone_(segmentInfo);
          return;
        }
        if (waitForVideo) {
          segmentInfo.waitingOnAppends++;
        }
        if (waitForAudio) {
          segmentInfo.waitingOnAppends++;
        }
        if (waitForVideo) {
          this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
        }
        if (waitForAudio) {
          this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
        }
      };
      _proto.checkAppendsDone_ = function checkAppendsDone_(segmentInfo) {
        if (this.checkForAbort_(segmentInfo.requestId)) {
          return;
        }
        segmentInfo.waitingOnAppends--;
        if (segmentInfo.waitingOnAppends === 0) {
          this.handleAppendsDone_();
        }
      };
      _proto.checkForIllegalMediaSwitch = function checkForIllegalMediaSwitch(trackInfo) {
        var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
        if (illegalMediaSwitchError) {
          this.error({
            message: illegalMediaSwitchError,
            blacklistDuration: Infinity
          });
          this.trigger("error");
          return true;
        }
        return false;
      };
      _proto.updateSourceBufferTimestampOffset_ = function updateSourceBufferTimestampOffset_(segmentInfo) {
        if (segmentInfo.timestampOffset === null || typeof segmentInfo.timingInfo.start !== "number" || segmentInfo.changedTimestampOffset || this.loaderType_ !== "main") {
          return;
        }
        var didChange = false;
        segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
          videoTimingInfo: segmentInfo.segment.videoTimingInfo,
          audioTimingInfo: segmentInfo.segment.audioTimingInfo,
          timingInfo: segmentInfo.timingInfo
        });
        segmentInfo.changedTimestampOffset = true;
        if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
          this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
          didChange = true;
        }
        if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
          this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
          didChange = true;
        }
        if (didChange) {
          this.trigger("timestampoffset");
        }
      };
      _proto.getSegmentStartTimeForTimestampOffsetCalculation_ = function getSegmentStartTimeForTimestampOffsetCalculation_(_ref10) {
        var videoTimingInfo = _ref10.videoTimingInfo, audioTimingInfo = _ref10.audioTimingInfo, timingInfo = _ref10.timingInfo;
        if (!this.useDtsForTimestampOffset_) {
          return timingInfo.start;
        }
        if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") {
          return videoTimingInfo.transmuxedDecodeStart;
        }
        if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") {
          return audioTimingInfo.transmuxedDecodeStart;
        }
        return timingInfo.start;
      };
      _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_(segmentInfo) {
        segmentInfo.timingInfo = segmentInfo.timingInfo || {};
        var trackInfo = this.getMediaInfo_();
        var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
        var prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
        if (!prioritizedTimingInfo) {
          return;
        }
        segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;
      };
      _proto.handleAppendsDone_ = function handleAppendsDone_() {
        if (this.pendingSegment_) {
          this.trigger("appendsdone");
        }
        if (!this.pendingSegment_) {
          this.state = "READY";
          if (!this.paused()) {
            this.monitorBuffer_();
          }
          return;
        }
        var segmentInfo = this.pendingSegment_;
        this.updateTimingInfoEnd_(segmentInfo);
        if (this.shouldSaveSegmentTimingInfo_) {
          this.syncController_.saveSegmentTimingInfo({
            segmentInfo,
            shouldSaveTimelineMapping: this.loaderType_ === "main"
          });
        }
        var segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
        if (segmentDurationMessage) {
          if (segmentDurationMessage.severity === "warn") {
            videojs3.log.warn(segmentDurationMessage.message);
          } else {
            this.logger_(segmentDurationMessage.message);
          }
        }
        this.recordThroughput_(segmentInfo);
        this.pendingSegment_ = null;
        this.state = "READY";
        if (segmentInfo.isSyncRequest) {
          this.trigger("syncinfoupdate");
          if (!segmentInfo.hasAppendedData_) {
            this.logger_("Throwing away un-appended sync request " + segmentInfoString(segmentInfo));
            return;
          }
        }
        this.logger_("Appended " + segmentInfoString(segmentInfo));
        this.addSegmentMetadataCue_(segmentInfo);
        this.fetchAtBuffer_ = true;
        if (this.currentTimeline_ !== segmentInfo.timeline) {
          this.timelineChangeController_.lastTimelineChange({
            type: this.loaderType_,
            from: this.currentTimeline_,
            to: segmentInfo.timeline
          });
          if (this.loaderType_ === "main" && !this.audioDisabled_) {
            this.timelineChangeController_.lastTimelineChange({
              type: "audio",
              from: this.currentTimeline_,
              to: segmentInfo.timeline
            });
          }
        }
        this.currentTimeline_ = segmentInfo.timeline;
        this.trigger("syncinfoupdate");
        var segment = segmentInfo.segment;
        var part = segmentInfo.part;
        var badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
        var badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
        if (badSegmentGuess || badPartGuess) {
          this.logger_("bad " + (badSegmentGuess ? "segment" : "part") + " " + segmentInfoString(segmentInfo));
          this.resetEverything();
          return;
        }
        var isWalkingForward = this.mediaIndex !== null;
        if (isWalkingForward) {
          this.trigger("bandwidthupdate");
        }
        this.trigger("progress");
        this.mediaIndex = segmentInfo.mediaIndex;
        this.partIndex = segmentInfo.partIndex;
        if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {
          this.endOfStream();
        }
        this.trigger("appended");
        if (segmentInfo.hasAppendedData_) {
          this.mediaAppends++;
        }
        if (!this.paused()) {
          this.monitorBuffer_();
        }
      };
      _proto.recordThroughput_ = function recordThroughput_(segmentInfo) {
        if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
          this.logger_("Ignoring segment's throughput because its duration of " + segmentInfo.duration + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
          return;
        }
        var rate = this.throughput.rate;
        var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
        var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
        this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
      };
      _proto.addSegmentMetadataCue_ = function addSegmentMetadataCue_(segmentInfo) {
        if (!this.segmentMetadataTrack_) {
          return;
        }
        var segment = segmentInfo.segment;
        var start2 = segment.start;
        var end2 = segment.end;
        if (!finite(start2) || !finite(end2)) {
          return;
        }
        removeCuesFromTrack(start2, end2, this.segmentMetadataTrack_);
        var Cue = window__default["default"].WebKitDataCue || window__default["default"].VTTCue;
        var value = {
          custom: segment.custom,
          dateTimeObject: segment.dateTimeObject,
          dateTimeString: segment.dateTimeString,
          bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
          resolution: segmentInfo.playlist.attributes.RESOLUTION,
          codecs: segmentInfo.playlist.attributes.CODECS,
          byteLength: segmentInfo.byteLength,
          uri: segmentInfo.uri,
          timeline: segmentInfo.timeline,
          playlist: segmentInfo.playlist.id,
          start: start2,
          end: end2
        };
        var data = JSON.stringify(value);
        var cue = new Cue(start2, end2, data);
        cue.value = value;
        this.segmentMetadataTrack_.addCue(cue);
      };
      return SegmentLoader2;
    }(videojs3.EventTarget);
    function noop() {
    }
    var toTitleCase = function toTitleCase2(string) {
      if (typeof string !== "string") {
        return string;
      }
      return string.replace(/./, function(w) {
        return w.toUpperCase();
      });
    };
    var bufferTypes = ["video", "audio"];
    var _updating = function updating(type, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type + "Buffer"];
      return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];
    };
    var nextQueueIndexOfType = function nextQueueIndexOfType2(type, queue) {
      for (var i2 = 0; i2 < queue.length; i2++) {
        var queueEntry = queue[i2];
        if (queueEntry.type === "mediaSource") {
          return null;
        }
        if (queueEntry.type === type) {
          return i2;
        }
      }
      return null;
    };
    var shiftQueue = function shiftQueue2(type, sourceUpdater) {
      if (sourceUpdater.queue.length === 0) {
        return;
      }
      var queueIndex = 0;
      var queueEntry = sourceUpdater.queue[queueIndex];
      if (queueEntry.type === "mediaSource") {
        if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
          sourceUpdater.queue.shift();
          queueEntry.action(sourceUpdater);
          if (queueEntry.doneFn) {
            queueEntry.doneFn();
          }
          shiftQueue2("audio", sourceUpdater);
          shiftQueue2("video", sourceUpdater);
        }
        return;
      }
      if (type === "mediaSource") {
        return;
      }
      if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || _updating(type, sourceUpdater)) {
        return;
      }
      if (queueEntry.type !== type) {
        queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);
        if (queueIndex === null) {
          return;
        }
        queueEntry = sourceUpdater.queue[queueIndex];
      }
      sourceUpdater.queue.splice(queueIndex, 1);
      sourceUpdater.queuePending[type] = queueEntry;
      queueEntry.action(type, sourceUpdater);
      if (!queueEntry.doneFn) {
        sourceUpdater.queuePending[type] = null;
        shiftQueue2(type, sourceUpdater);
        return;
      }
    };
    var cleanupBuffer = function cleanupBuffer2(type, sourceUpdater) {
      var buffer = sourceUpdater[type + "Buffer"];
      var titleType = toTitleCase(type);
      if (!buffer) {
        return;
      }
      buffer.removeEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
      buffer.removeEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
      sourceUpdater.codecs[type] = null;
      sourceUpdater[type + "Buffer"] = null;
    };
    var inSourceBuffers = function inSourceBuffers2(mediaSource, sourceBuffer) {
      return mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
    };
    var actions = {
      appendBuffer: function appendBuffer(bytes, segmentInfo, onError2) {
        return function(type, sourceUpdater) {
          var sourceBuffer = sourceUpdater[type + "Buffer"];
          if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
            return;
          }
          sourceUpdater.logger_("Appending segment " + segmentInfo.mediaIndex + "'s " + bytes.length + " bytes to " + type + "Buffer");
          try {
            sourceBuffer.appendBuffer(bytes);
          } catch (e) {
            sourceUpdater.logger_("Error with code " + e.code + " " + (e.code === QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + ("when appending segment " + segmentInfo.mediaIndex + " to " + type + "Buffer"));
            sourceUpdater.queuePending[type] = null;
            onError2(e);
          }
        };
      },
      remove: function remove(start2, end2) {
        return function(type, sourceUpdater) {
          var sourceBuffer = sourceUpdater[type + "Buffer"];
          if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
            return;
          }
          sourceUpdater.logger_("Removing " + start2 + " to " + end2 + " from " + type + "Buffer");
          try {
            sourceBuffer.remove(start2, end2);
          } catch (e) {
            sourceUpdater.logger_("Remove " + start2 + " to " + end2 + " from " + type + "Buffer failed");
          }
        };
      },
      timestampOffset: function timestampOffset(offset) {
        return function(type, sourceUpdater) {
          var sourceBuffer = sourceUpdater[type + "Buffer"];
          if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
            return;
          }
          sourceUpdater.logger_("Setting " + type + "timestampOffset to " + offset);
          sourceBuffer.timestampOffset = offset;
        };
      },
      callback: function callback(_callback) {
        return function(type, sourceUpdater) {
          _callback();
        };
      },
      endOfStream: function endOfStream(error) {
        return function(sourceUpdater) {
          if (sourceUpdater.mediaSource.readyState !== "open") {
            return;
          }
          sourceUpdater.logger_("Calling mediaSource endOfStream(" + (error || "") + ")");
          try {
            sourceUpdater.mediaSource.endOfStream(error);
          } catch (e) {
            videojs3.log.warn("Failed to call media source endOfStream", e);
          }
        };
      },
      duration: function duration2(_duration) {
        return function(sourceUpdater) {
          sourceUpdater.logger_("Setting mediaSource duration to " + _duration);
          try {
            sourceUpdater.mediaSource.duration = _duration;
          } catch (e) {
            videojs3.log.warn("Failed to set media source duration", e);
          }
        };
      },
      abort: function abort() {
        return function(type, sourceUpdater) {
          if (sourceUpdater.mediaSource.readyState !== "open") {
            return;
          }
          var sourceBuffer = sourceUpdater[type + "Buffer"];
          if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
            return;
          }
          sourceUpdater.logger_("calling abort on " + type + "Buffer");
          try {
            sourceBuffer.abort();
          } catch (e) {
            videojs3.log.warn("Failed to abort on " + type + "Buffer", e);
          }
        };
      },
      addSourceBuffer: function addSourceBuffer(type, codec) {
        return function(sourceUpdater) {
          var titleType = toTitleCase(type);
          var mime = codecs_js.getMimeForCodec(codec);
          sourceUpdater.logger_("Adding " + type + "Buffer with codec " + codec + " to mediaSource");
          var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
          sourceBuffer.addEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
          sourceBuffer.addEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
          sourceUpdater.codecs[type] = codec;
          sourceUpdater[type + "Buffer"] = sourceBuffer;
        };
      },
      removeSourceBuffer: function removeSourceBuffer(type) {
        return function(sourceUpdater) {
          var sourceBuffer = sourceUpdater[type + "Buffer"];
          cleanupBuffer(type, sourceUpdater);
          if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
            return;
          }
          sourceUpdater.logger_("Removing " + type + "Buffer with codec " + sourceUpdater.codecs[type] + " from mediaSource");
          try {
            sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
          } catch (e) {
            videojs3.log.warn("Failed to removeSourceBuffer " + type + "Buffer", e);
          }
        };
      },
      changeType: function changeType(codec) {
        return function(type, sourceUpdater) {
          var sourceBuffer = sourceUpdater[type + "Buffer"];
          var mime = codecs_js.getMimeForCodec(codec);
          if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
            return;
          }
          if (sourceUpdater.codecs[type] === codec) {
            return;
          }
          sourceUpdater.logger_("changing " + type + "Buffer codec from " + sourceUpdater.codecs[type] + " to " + codec);
          try {
            sourceBuffer.changeType(mime);
            sourceUpdater.codecs[type] = codec;
          } catch (e) {
            videojs3.log.warn("Failed to changeType on " + type + "Buffer", e);
          }
        };
      }
    };
    var pushQueue = function pushQueue2(_ref) {
      var type = _ref.type, sourceUpdater = _ref.sourceUpdater, action = _ref.action, doneFn = _ref.doneFn, name = _ref.name;
      sourceUpdater.queue.push({
        type,
        action,
        doneFn,
        name
      });
      shiftQueue(type, sourceUpdater);
    };
    var onUpdateend = function onUpdateend2(type, sourceUpdater) {
      return function(e) {
        if (sourceUpdater.queuePending[type]) {
          var doneFn = sourceUpdater.queuePending[type].doneFn;
          sourceUpdater.queuePending[type] = null;
          if (doneFn) {
            doneFn(sourceUpdater[type + "Error_"]);
          }
        }
        shiftQueue(type, sourceUpdater);
      };
    };
    var SourceUpdater = /* @__PURE__ */ function(_videojs$EventTarget) {
      _inheritsLoose__default["default"](SourceUpdater2, _videojs$EventTarget);
      function SourceUpdater2(mediaSource) {
        var _this;
        _this = _videojs$EventTarget.call(this) || this;
        _this.mediaSource = mediaSource;
        _this.sourceopenListener_ = function() {
          return shiftQueue("mediaSource", _assertThisInitialized__default["default"](_this));
        };
        _this.mediaSource.addEventListener("sourceopen", _this.sourceopenListener_);
        _this.logger_ = logger("SourceUpdater");
        _this.audioTimestampOffset_ = 0;
        _this.videoTimestampOffset_ = 0;
        _this.queue = [];
        _this.queuePending = {
          audio: null,
          video: null
        };
        _this.delayedAudioAppendQueue_ = [];
        _this.videoAppendQueued_ = false;
        _this.codecs = {};
        _this.onVideoUpdateEnd_ = onUpdateend("video", _assertThisInitialized__default["default"](_this));
        _this.onAudioUpdateEnd_ = onUpdateend("audio", _assertThisInitialized__default["default"](_this));
        _this.onVideoError_ = function(e) {
          _this.videoError_ = e;
        };
        _this.onAudioError_ = function(e) {
          _this.audioError_ = e;
        };
        _this.createdSourceBuffers_ = false;
        _this.initializedEme_ = false;
        _this.triggeredReady_ = false;
        return _this;
      }
      var _proto = SourceUpdater2.prototype;
      _proto.initializedEme = function initializedEme() {
        this.initializedEme_ = true;
        this.triggerReady();
      };
      _proto.hasCreatedSourceBuffers = function hasCreatedSourceBuffers() {
        return this.createdSourceBuffers_;
      };
      _proto.hasInitializedAnyEme = function hasInitializedAnyEme() {
        return this.initializedEme_;
      };
      _proto.ready = function ready() {
        return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
      };
      _proto.createSourceBuffers = function createSourceBuffers(codecs) {
        if (this.hasCreatedSourceBuffers()) {
          return;
        }
        this.addOrChangeSourceBuffers(codecs);
        this.createdSourceBuffers_ = true;
        this.trigger("createdsourcebuffers");
        this.triggerReady();
      };
      _proto.triggerReady = function triggerReady() {
        if (this.ready() && !this.triggeredReady_) {
          this.triggeredReady_ = true;
          this.trigger("ready");
        }
      };
      _proto.addSourceBuffer = function addSourceBuffer(type, codec) {
        pushQueue({
          type: "mediaSource",
          sourceUpdater: this,
          action: actions.addSourceBuffer(type, codec),
          name: "addSourceBuffer"
        });
      };
      _proto.abort = function abort(type) {
        pushQueue({
          type,
          sourceUpdater: this,
          action: actions.abort(type),
          name: "abort"
        });
      };
      _proto.removeSourceBuffer = function removeSourceBuffer(type) {
        if (!this.canRemoveSourceBuffer()) {
          videojs3.log.error("removeSourceBuffer is not supported!");
          return;
        }
        pushQueue({
          type: "mediaSource",
          sourceUpdater: this,
          action: actions.removeSourceBuffer(type),
          name: "removeSourceBuffer"
        });
      };
      _proto.canRemoveSourceBuffer = function canRemoveSourceBuffer() {
        return !videojs3.browser.IE_VERSION && !videojs3.browser.IS_FIREFOX && window__default["default"].MediaSource && window__default["default"].MediaSource.prototype && typeof window__default["default"].MediaSource.prototype.removeSourceBuffer === "function";
      };
      SourceUpdater2.canChangeType = function canChangeType() {
        return window__default["default"].SourceBuffer && window__default["default"].SourceBuffer.prototype && typeof window__default["default"].SourceBuffer.prototype.changeType === "function";
      };
      _proto.canChangeType = function canChangeType() {
        return this.constructor.canChangeType();
      };
      _proto.changeType = function changeType(type, codec) {
        if (!this.canChangeType()) {
          videojs3.log.error("changeType is not supported!");
          return;
        }
        pushQueue({
          type,
          sourceUpdater: this,
          action: actions.changeType(codec),
          name: "changeType"
        });
      };
      _proto.addOrChangeSourceBuffers = function addOrChangeSourceBuffers(codecs) {
        var _this2 = this;
        if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) {
          throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
        }
        Object.keys(codecs).forEach(function(type) {
          var codec = codecs[type];
          if (!_this2.hasCreatedSourceBuffers()) {
            return _this2.addSourceBuffer(type, codec);
          }
          if (_this2.canChangeType()) {
            _this2.changeType(type, codec);
          }
        });
      };
      _proto.appendBuffer = function appendBuffer(options, doneFn) {
        var _this3 = this;
        var segmentInfo = options.segmentInfo, type = options.type, bytes = options.bytes;
        this.processedAppend_ = true;
        if (type === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
          this.delayedAudioAppendQueue_.push([options, doneFn]);
          this.logger_("delayed audio append of " + bytes.length + " until video append");
          return;
        }
        var onError2 = doneFn;
        pushQueue({
          type,
          sourceUpdater: this,
          action: actions.appendBuffer(bytes, segmentInfo || {
            mediaIndex: -1
          }, onError2),
          doneFn,
          name: "appendBuffer"
        });
        if (type === "video") {
          this.videoAppendQueued_ = true;
          if (!this.delayedAudioAppendQueue_.length) {
            return;
          }
          var queue = this.delayedAudioAppendQueue_.slice();
          this.logger_("queuing delayed audio " + queue.length + " appendBuffers");
          this.delayedAudioAppendQueue_.length = 0;
          queue.forEach(function(que) {
            _this3.appendBuffer.apply(_this3, que);
          });
        }
      };
      _proto.audioBuffered = function audioBuffered() {
        if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {
          return videojs3.createTimeRange();
        }
        return this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs3.createTimeRange();
      };
      _proto.videoBuffered = function videoBuffered() {
        if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {
          return videojs3.createTimeRange();
        }
        return this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs3.createTimeRange();
      };
      _proto.buffered = function buffered() {
        var video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
        var audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
        if (audio && !video) {
          return this.audioBuffered();
        }
        if (video && !audio) {
          return this.videoBuffered();
        }
        return bufferIntersection(this.audioBuffered(), this.videoBuffered());
      };
      _proto.setDuration = function setDuration(duration2, doneFn) {
        if (doneFn === void 0) {
          doneFn = noop;
        }
        pushQueue({
          type: "mediaSource",
          sourceUpdater: this,
          action: actions.duration(duration2),
          name: "duration",
          doneFn
        });
      };
      _proto.endOfStream = function endOfStream(error, doneFn) {
        if (error === void 0) {
          error = null;
        }
        if (doneFn === void 0) {
          doneFn = noop;
        }
        if (typeof error !== "string") {
          error = void 0;
        }
        pushQueue({
          type: "mediaSource",
          sourceUpdater: this,
          action: actions.endOfStream(error),
          name: "endOfStream",
          doneFn
        });
      };
      _proto.removeAudio = function removeAudio(start2, end2, done) {
        if (done === void 0) {
          done = noop;
        }
        if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
          done();
          return;
        }
        pushQueue({
          type: "audio",
          sourceUpdater: this,
          action: actions.remove(start2, end2),
          doneFn: done,
          name: "remove"
        });
      };
      _proto.removeVideo = function removeVideo(start2, end2, done) {
        if (done === void 0) {
          done = noop;
        }
        if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
          done();
          return;
        }
        pushQueue({
          type: "video",
          sourceUpdater: this,
          action: actions.remove(start2, end2),
          doneFn: done,
          name: "remove"
        });
      };
      _proto.updating = function updating() {
        if (_updating("audio", this) || _updating("video", this)) {
          return true;
        }
        return false;
      };
      _proto.audioTimestampOffset = function audioTimestampOffset(offset) {
        if (typeof offset !== "undefined" && this.audioBuffer && this.audioTimestampOffset_ !== offset) {
          pushQueue({
            type: "audio",
            sourceUpdater: this,
            action: actions.timestampOffset(offset),
            name: "timestampOffset"
          });
          this.audioTimestampOffset_ = offset;
        }
        return this.audioTimestampOffset_;
      };
      _proto.videoTimestampOffset = function videoTimestampOffset(offset) {
        if (typeof offset !== "undefined" && this.videoBuffer && this.videoTimestampOffset !== offset) {
          pushQueue({
            type: "video",
            sourceUpdater: this,
            action: actions.timestampOffset(offset),
            name: "timestampOffset"
          });
          this.videoTimestampOffset_ = offset;
        }
        return this.videoTimestampOffset_;
      };
      _proto.audioQueueCallback = function audioQueueCallback(callback) {
        if (!this.audioBuffer) {
          return;
        }
        pushQueue({
          type: "audio",
          sourceUpdater: this,
          action: actions.callback(callback),
          name: "callback"
        });
      };
      _proto.videoQueueCallback = function videoQueueCallback(callback) {
        if (!this.videoBuffer) {
          return;
        }
        pushQueue({
          type: "video",
          sourceUpdater: this,
          action: actions.callback(callback),
          name: "callback"
        });
      };
      _proto.dispose = function dispose() {
        var _this4 = this;
        this.trigger("dispose");
        bufferTypes.forEach(function(type) {
          _this4.abort(type);
          if (_this4.canRemoveSourceBuffer()) {
            _this4.removeSourceBuffer(type);
          } else {
            _this4[type + "QueueCallback"](function() {
              return cleanupBuffer(type, _this4);
            });
          }
        });
        this.videoAppendQueued_ = false;
        this.delayedAudioAppendQueue_.length = 0;
        if (this.sourceopenListener_) {
          this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
        }
        this.off();
      };
      return SourceUpdater2;
    }(videojs3.EventTarget);
    var uint8ToUtf8 = function uint8ToUtf82(uintArray) {
      return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
    };
    var VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map(function(_char3) {
      return _char3.charCodeAt(0);
    }));
    var NoVttJsError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose__default["default"](NoVttJsError2, _Error);
      function NoVttJsError2() {
        return _Error.call(this, "Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.") || this;
      }
      return NoVttJsError2;
    }(/* @__PURE__ */ _wrapNativeSuper__default["default"](Error));
    var VTTSegmentLoader = /* @__PURE__ */ function(_SegmentLoader) {
      _inheritsLoose__default["default"](VTTSegmentLoader2, _SegmentLoader);
      function VTTSegmentLoader2(settings2, options) {
        var _this;
        if (options === void 0) {
          options = {};
        }
        _this = _SegmentLoader.call(this, settings2, options) || this;
        _this.mediaSource_ = null;
        _this.subtitlesTrack_ = null;
        _this.loaderType_ = "subtitle";
        _this.featuresNativeTextTracks_ = settings2.featuresNativeTextTracks;
        _this.loadVttJs = settings2.loadVttJs;
        _this.shouldSaveSegmentTimingInfo_ = false;
        return _this;
      }
      var _proto = VTTSegmentLoader2.prototype;
      _proto.createTransmuxer_ = function createTransmuxer_() {
        return null;
      };
      _proto.buffered_ = function buffered_() {
        if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {
          return videojs3.createTimeRanges();
        }
        var cues = this.subtitlesTrack_.cues;
        var start2 = cues[0].startTime;
        var end2 = cues[cues.length - 1].startTime;
        return videojs3.createTimeRanges([[start2, end2]]);
      };
      _proto.initSegmentForMap = function initSegmentForMap(map, set2) {
        if (set2 === void 0) {
          set2 = false;
        }
        if (!map) {
          return null;
        }
        var id = initSegmentId(map);
        var storedMap = this.initSegments_[id];
        if (set2 && !storedMap && map.bytes) {
          var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
          var combinedSegment = new Uint8Array(combinedByteLength);
          combinedSegment.set(map.bytes);
          combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);
          this.initSegments_[id] = storedMap = {
            resolvedUri: map.resolvedUri,
            byterange: map.byterange,
            bytes: combinedSegment
          };
        }
        return storedMap || map;
      };
      _proto.couldBeginLoading_ = function couldBeginLoading_() {
        return this.playlist_ && this.subtitlesTrack_ && !this.paused();
      };
      _proto.init_ = function init_() {
        this.state = "READY";
        this.resetEverything();
        return this.monitorBuffer_();
      };
      _proto.track = function track(_track) {
        if (typeof _track === "undefined") {
          return this.subtitlesTrack_;
        }
        this.subtitlesTrack_ = _track;
        if (this.state === "INIT" && this.couldBeginLoading_()) {
          this.init_();
        }
        return this.subtitlesTrack_;
      };
      _proto.remove = function remove(start2, end2) {
        removeCuesFromTrack(start2, end2, this.subtitlesTrack_);
      };
      _proto.fillBuffer_ = function fillBuffer_() {
        var _this2 = this;
        var segmentInfo = this.chooseNextRequest_();
        if (!segmentInfo) {
          return;
        }
        if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
          var checkTimestampOffset = function checkTimestampOffset2() {
            _this2.state = "READY";
            if (!_this2.paused()) {
              _this2.monitorBuffer_();
            }
          };
          this.syncController_.one("timestampoffset", checkTimestampOffset);
          this.state = "WAITING_ON_TIMELINE";
          return;
        }
        this.loadSegment_(segmentInfo);
      };
      _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_() {
        return null;
      };
      _proto.chooseNextRequest_ = function chooseNextRequest_() {
        return this.skipEmptySegments_(_SegmentLoader.prototype.chooseNextRequest_.call(this));
      };
      _proto.skipEmptySegments_ = function skipEmptySegments_(segmentInfo) {
        while (segmentInfo && segmentInfo.segment.empty) {
          if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
            segmentInfo = null;
            break;
          }
          segmentInfo = this.generateSegmentInfo_({
            playlist: segmentInfo.playlist,
            mediaIndex: segmentInfo.mediaIndex + 1,
            startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
            isSyncRequest: segmentInfo.isSyncRequest
          });
        }
        return segmentInfo;
      };
      _proto.stopForError = function stopForError(error) {
        this.error(error);
        this.state = "READY";
        this.pause();
        this.trigger("error");
      };
      _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
        var _this3 = this;
        if (!this.subtitlesTrack_) {
          this.state = "READY";
          return;
        }
        this.saveTransferStats_(simpleSegment.stats);
        if (!this.pendingSegment_) {
          this.state = "READY";
          this.mediaRequestsAborted += 1;
          return;
        }
        if (error) {
          if (error.code === REQUEST_ERRORS.TIMEOUT) {
            this.handleTimeout_();
          }
          if (error.code === REQUEST_ERRORS.ABORTED) {
            this.mediaRequestsAborted += 1;
          } else {
            this.mediaRequestsErrored += 1;
          }
          this.stopForError(error);
          return;
        }
        var segmentInfo = this.pendingSegment_;
        this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
        if (simpleSegment.key) {
          this.segmentKey(simpleSegment.key, true);
        }
        this.state = "APPENDING";
        this.trigger("appending");
        var segment = segmentInfo.segment;
        if (segment.map) {
          segment.map.bytes = simpleSegment.map.bytes;
        }
        segmentInfo.bytes = simpleSegment.bytes;
        if (typeof window__default["default"].WebVTT !== "function" && typeof this.loadVttJs === "function") {
          this.state = "WAITING_ON_VTTJS";
          this.loadVttJs().then(function() {
            return _this3.segmentRequestFinished_(error, simpleSegment, result);
          }, function() {
            return _this3.stopForError({
              message: "Error loading vtt.js"
            });
          });
          return;
        }
        segment.requested = true;
        try {
          this.parseVTTCues_(segmentInfo);
        } catch (e) {
          this.stopForError({
            message: e.message
          });
          return;
        }
        this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
        if (segmentInfo.cues.length) {
          segmentInfo.timingInfo = {
            start: segmentInfo.cues[0].startTime,
            end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
          };
        } else {
          segmentInfo.timingInfo = {
            start: segmentInfo.startOfSegment,
            end: segmentInfo.startOfSegment + segmentInfo.duration
          };
        }
        if (segmentInfo.isSyncRequest) {
          this.trigger("syncinfoupdate");
          this.pendingSegment_ = null;
          this.state = "READY";
          return;
        }
        segmentInfo.byteLength = segmentInfo.bytes.byteLength;
        this.mediaSecondsLoaded += segment.duration;
        segmentInfo.cues.forEach(function(cue) {
          _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new window__default["default"].VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
        });
        removeDuplicateCuesFromTrack(this.subtitlesTrack_);
        this.handleAppendsDone_();
      };
      _proto.handleData_ = function handleData_2() {
      };
      _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_() {
      };
      _proto.parseVTTCues_ = function parseVTTCues_(segmentInfo) {
        var decoder;
        var decodeBytesToString = false;
        if (typeof window__default["default"].WebVTT !== "function") {
          throw new NoVttJsError();
        }
        if (typeof window__default["default"].TextDecoder === "function") {
          decoder = new window__default["default"].TextDecoder("utf8");
        } else {
          decoder = window__default["default"].WebVTT.StringDecoder();
          decodeBytesToString = true;
        }
        var parser = new window__default["default"].WebVTT.Parser(window__default["default"], window__default["default"].vttjs, decoder);
        segmentInfo.cues = [];
        segmentInfo.timestampmap = {
          MPEGTS: 0,
          LOCAL: 0
        };
        parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
        parser.ontimestampmap = function(map) {
          segmentInfo.timestampmap = map;
        };
        parser.onparsingerror = function(error) {
          videojs3.log.warn("Error encountered when parsing cues: " + error.message);
        };
        if (segmentInfo.segment.map) {
          var mapData = segmentInfo.segment.map.bytes;
          if (decodeBytesToString) {
            mapData = uint8ToUtf8(mapData);
          }
          parser.parse(mapData);
        }
        var segmentData = segmentInfo.bytes;
        if (decodeBytesToString) {
          segmentData = uint8ToUtf8(segmentData);
        }
        parser.parse(segmentData);
        parser.flush();
      };
      _proto.updateTimeMapping_ = function updateTimeMapping_(segmentInfo, mappingObj, playlist) {
        var segment = segmentInfo.segment;
        if (!mappingObj) {
          return;
        }
        if (!segmentInfo.cues.length) {
          segment.empty = true;
          return;
        }
        var timestampmap = segmentInfo.timestampmap;
        var diff = timestampmap.MPEGTS / clock.ONE_SECOND_IN_TS - timestampmap.LOCAL + mappingObj.mapping;
        segmentInfo.cues.forEach(function(cue) {
          cue.startTime += diff;
          cue.endTime += diff;
        });
        if (!playlist.syncInfo) {
          var firstStart = segmentInfo.cues[0].startTime;
          var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
          playlist.syncInfo = {
            mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
            time: Math.min(firstStart, lastStart - segment.duration)
          };
        }
      };
      return VTTSegmentLoader2;
    }(SegmentLoader);
    var findAdCue = function findAdCue2(track, mediaTime) {
      var cues = track.cues;
      for (var i2 = 0; i2 < cues.length; i2++) {
        var cue = cues[i2];
        if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {
          return cue;
        }
      }
      return null;
    };
    var updateAdCues = function updateAdCues2(media, track, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (!media.segments) {
        return;
      }
      var mediaTime = offset;
      var cue;
      for (var i2 = 0; i2 < media.segments.length; i2++) {
        var segment = media.segments[i2];
        if (!cue) {
          cue = findAdCue(track, mediaTime + segment.duration / 2);
        }
        if (cue) {
          if ("cueIn" in segment) {
            cue.endTime = mediaTime;
            cue.adEndTime = mediaTime;
            mediaTime += segment.duration;
            cue = null;
            continue;
          }
          if (mediaTime < cue.endTime) {
            mediaTime += segment.duration;
            continue;
          }
          cue.endTime += segment.duration;
        } else {
          if ("cueOut" in segment) {
            cue = new window__default["default"].VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);
            cue.adStartTime = mediaTime;
            cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
            track.addCue(cue);
          }
          if ("cueOutCont" in segment) {
            var _segment$cueOutCont$s = segment.cueOutCont.split("/").map(parseFloat), adOffset = _segment$cueOutCont$s[0], adTotal = _segment$cueOutCont$s[1];
            cue = new window__default["default"].VTTCue(mediaTime, mediaTime + segment.duration, "");
            cue.adStartTime = mediaTime - adOffset;
            cue.adEndTime = cue.adStartTime + adTotal;
            track.addCue(cue);
          }
        }
        mediaTime += segment.duration;
      }
    };
    var MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
    var syncPointStrategies = [
      {
        name: "VOD",
        run: function run(syncController, playlist, duration2, currentTimeline, currentTime) {
          if (duration2 !== Infinity) {
            var syncPoint = {
              time: 0,
              segmentIndex: 0,
              partIndex: null
            };
            return syncPoint;
          }
          return null;
        }
      },
      {
        name: "ProgramDateTime",
        run: function run(syncController, playlist, duration2, currentTimeline, currentTime) {
          if (!Object.keys(syncController.timelineToDatetimeMappings).length) {
            return null;
          }
          var syncPoint = null;
          var lastDistance = null;
          var partsAndSegments = getPartsAndSegments(playlist);
          currentTime = currentTime || 0;
          for (var i2 = 0; i2 < partsAndSegments.length; i2++) {
            var index = playlist.endList || currentTime === 0 ? i2 : partsAndSegments.length - (i2 + 1);
            var partAndSegment = partsAndSegments[index];
            var segment = partAndSegment.segment;
            var datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
            if (!datetimeMapping || !segment.dateTimeObject) {
              continue;
            }
            var segmentTime = segment.dateTimeObject.getTime() / 1e3;
            var start2 = segmentTime + datetimeMapping;
            if (segment.parts && typeof partAndSegment.partIndex === "number") {
              for (var z = 0; z < partAndSegment.partIndex; z++) {
                start2 += segment.parts[z].duration;
              }
            }
            var distance = Math.abs(currentTime - start2);
            if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {
              break;
            }
            lastDistance = distance;
            syncPoint = {
              time: start2,
              segmentIndex: partAndSegment.segmentIndex,
              partIndex: partAndSegment.partIndex
            };
          }
          return syncPoint;
        }
      },
      {
        name: "Segment",
        run: function run(syncController, playlist, duration2, currentTimeline, currentTime) {
          var syncPoint = null;
          var lastDistance = null;
          currentTime = currentTime || 0;
          var partsAndSegments = getPartsAndSegments(playlist);
          for (var i2 = 0; i2 < partsAndSegments.length; i2++) {
            var index = playlist.endList || currentTime === 0 ? i2 : partsAndSegments.length - (i2 + 1);
            var partAndSegment = partsAndSegments[index];
            var segment = partAndSegment.segment;
            var start2 = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
            if (segment.timeline === currentTimeline && typeof start2 !== "undefined") {
              var distance = Math.abs(currentTime - start2);
              if (lastDistance !== null && lastDistance < distance) {
                break;
              }
              if (!syncPoint || lastDistance === null || lastDistance >= distance) {
                lastDistance = distance;
                syncPoint = {
                  time: start2,
                  segmentIndex: partAndSegment.segmentIndex,
                  partIndex: partAndSegment.partIndex
                };
              }
            }
          }
          return syncPoint;
        }
      },
      {
        name: "Discontinuity",
        run: function run(syncController, playlist, duration2, currentTimeline, currentTime) {
          var syncPoint = null;
          currentTime = currentTime || 0;
          if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
            var lastDistance = null;
            for (var i2 = 0; i2 < playlist.discontinuityStarts.length; i2++) {
              var segmentIndex = playlist.discontinuityStarts[i2];
              var discontinuity = playlist.discontinuitySequence + i2 + 1;
              var discontinuitySync = syncController.discontinuities[discontinuity];
              if (discontinuitySync) {
                var distance = Math.abs(currentTime - discontinuitySync.time);
                if (lastDistance !== null && lastDistance < distance) {
                  break;
                }
                if (!syncPoint || lastDistance === null || lastDistance >= distance) {
                  lastDistance = distance;
                  syncPoint = {
                    time: discontinuitySync.time,
                    segmentIndex,
                    partIndex: null
                  };
                }
              }
            }
          }
          return syncPoint;
        }
      },
      {
        name: "Playlist",
        run: function run(syncController, playlist, duration2, currentTimeline, currentTime) {
          if (playlist.syncInfo) {
            var syncPoint = {
              time: playlist.syncInfo.time,
              segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
              partIndex: null
            };
            return syncPoint;
          }
          return null;
        }
      }
    ];
    var SyncController = /* @__PURE__ */ function(_videojs$EventTarget) {
      _inheritsLoose__default["default"](SyncController2, _videojs$EventTarget);
      function SyncController2(options) {
        var _this;
        _this = _videojs$EventTarget.call(this) || this;
        _this.timelines = [];
        _this.discontinuities = [];
        _this.timelineToDatetimeMappings = {};
        _this.logger_ = logger("SyncController");
        return _this;
      }
      var _proto = SyncController2.prototype;
      _proto.getSyncPoint = function getSyncPoint(playlist, duration2, currentTimeline, currentTime) {
        var syncPoints = this.runStrategies_(playlist, duration2, currentTimeline, currentTime);
        if (!syncPoints.length) {
          return null;
        }
        return this.selectSyncPoint_(syncPoints, {
          key: "time",
          value: currentTime
        });
      };
      _proto.getExpiredTime = function getExpiredTime(playlist, duration2) {
        if (!playlist || !playlist.segments) {
          return null;
        }
        var syncPoints = this.runStrategies_(playlist, duration2, playlist.discontinuitySequence, 0);
        if (!syncPoints.length) {
          return null;
        }
        var syncPoint = this.selectSyncPoint_(syncPoints, {
          key: "segmentIndex",
          value: 0
        });
        if (syncPoint.segmentIndex > 0) {
          syncPoint.time *= -1;
        }
        return Math.abs(syncPoint.time + sumDurations({
          defaultDuration: playlist.targetDuration,
          durationList: playlist.segments,
          startIndex: syncPoint.segmentIndex,
          endIndex: 0
        }));
      };
      _proto.runStrategies_ = function runStrategies_(playlist, duration2, currentTimeline, currentTime) {
        var syncPoints = [];
        for (var i2 = 0; i2 < syncPointStrategies.length; i2++) {
          var strategy = syncPointStrategies[i2];
          var syncPoint = strategy.run(this, playlist, duration2, currentTimeline, currentTime);
          if (syncPoint) {
            syncPoint.strategy = strategy.name;
            syncPoints.push({
              strategy: strategy.name,
              syncPoint
            });
          }
        }
        return syncPoints;
      };
      _proto.selectSyncPoint_ = function selectSyncPoint_(syncPoints, target) {
        var bestSyncPoint = syncPoints[0].syncPoint;
        var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
        var bestStrategy = syncPoints[0].strategy;
        for (var i2 = 1; i2 < syncPoints.length; i2++) {
          var newDistance = Math.abs(syncPoints[i2].syncPoint[target.key] - target.value);
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            bestSyncPoint = syncPoints[i2].syncPoint;
            bestStrategy = syncPoints[i2].strategy;
          }
        }
        this.logger_("syncPoint for [" + target.key + ": " + target.value + "] chosen with strategy" + (" [" + bestStrategy + "]: [time:" + bestSyncPoint.time + ",") + (" segmentIndex:" + bestSyncPoint.segmentIndex) + (typeof bestSyncPoint.partIndex === "number" ? ",partIndex:" + bestSyncPoint.partIndex : "") + "]");
        return bestSyncPoint;
      };
      _proto.saveExpiredSegmentInfo = function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
        var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
        if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
          videojs3.log.warn("Not saving expired segment info. Media sequence gap " + mediaSequenceDiff + " is too large.");
          return;
        }
        for (var i2 = mediaSequenceDiff - 1; i2 >= 0; i2--) {
          var lastRemovedSegment = oldPlaylist.segments[i2];
          if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
            newPlaylist.syncInfo = {
              mediaSequence: oldPlaylist.mediaSequence + i2,
              time: lastRemovedSegment.start
            };
            this.logger_("playlist refresh sync: [time:" + newPlaylist.syncInfo.time + "," + (" mediaSequence: " + newPlaylist.syncInfo.mediaSequence + "]"));
            this.trigger("syncinfoupdate");
            break;
          }
        }
      };
      _proto.setDateTimeMappingForStart = function setDateTimeMappingForStart(playlist) {
        this.timelineToDatetimeMappings = {};
        if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
          var firstSegment = playlist.segments[0];
          var playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
          this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
        }
      };
      _proto.saveSegmentTimingInfo = function saveSegmentTimingInfo(_ref) {
        var segmentInfo = _ref.segmentInfo, shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping;
        var didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
        var segment = segmentInfo.segment;
        if (didCalculateSegmentTimeMapping) {
          this.saveDiscontinuitySyncInfo_(segmentInfo);
          if (!segmentInfo.playlist.syncInfo) {
            segmentInfo.playlist.syncInfo = {
              mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
              time: segment.start
            };
          }
        }
        var dateTime = segment.dateTimeObject;
        if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {
          this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1e3);
        }
      };
      _proto.timestampOffsetForTimeline = function timestampOffsetForTimeline(timeline) {
        if (typeof this.timelines[timeline] === "undefined") {
          return null;
        }
        return this.timelines[timeline].time;
      };
      _proto.mappingForTimeline = function mappingForTimeline(timeline) {
        if (typeof this.timelines[timeline] === "undefined") {
          return null;
        }
        return this.timelines[timeline].mapping;
      };
      _proto.calculateSegmentTimeMapping_ = function calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
        var segment = segmentInfo.segment;
        var part = segmentInfo.part;
        var mappingObj = this.timelines[segmentInfo.timeline];
        var start2;
        var end2;
        if (typeof segmentInfo.timestampOffset === "number") {
          mappingObj = {
            time: segmentInfo.startOfSegment,
            mapping: segmentInfo.startOfSegment - timingInfo.start
          };
          if (shouldSaveTimelineMapping) {
            this.timelines[segmentInfo.timeline] = mappingObj;
            this.trigger("timestampoffset");
            this.logger_("time mapping for timeline " + segmentInfo.timeline + ": " + ("[time: " + mappingObj.time + "] [mapping: " + mappingObj.mapping + "]"));
          }
          start2 = segmentInfo.startOfSegment;
          end2 = timingInfo.end + mappingObj.mapping;
        } else if (mappingObj) {
          start2 = timingInfo.start + mappingObj.mapping;
          end2 = timingInfo.end + mappingObj.mapping;
        } else {
          return false;
        }
        if (part) {
          part.start = start2;
          part.end = end2;
        }
        if (!segment.start || start2 < segment.start) {
          segment.start = start2;
        }
        segment.end = end2;
        return true;
      };
      _proto.saveDiscontinuitySyncInfo_ = function saveDiscontinuitySyncInfo_(segmentInfo) {
        var playlist = segmentInfo.playlist;
        var segment = segmentInfo.segment;
        if (segment.discontinuity) {
          this.discontinuities[segment.timeline] = {
            time: segment.start,
            accuracy: 0
          };
        } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
          for (var i2 = 0; i2 < playlist.discontinuityStarts.length; i2++) {
            var segmentIndex = playlist.discontinuityStarts[i2];
            var discontinuity = playlist.discontinuitySequence + i2 + 1;
            var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
            var accuracy = Math.abs(mediaIndexDiff);
            if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
              var time = void 0;
              if (mediaIndexDiff < 0) {
                time = segment.start - sumDurations({
                  defaultDuration: playlist.targetDuration,
                  durationList: playlist.segments,
                  startIndex: segmentInfo.mediaIndex,
                  endIndex: segmentIndex
                });
              } else {
                time = segment.end + sumDurations({
                  defaultDuration: playlist.targetDuration,
                  durationList: playlist.segments,
                  startIndex: segmentInfo.mediaIndex + 1,
                  endIndex: segmentIndex
                });
              }
              this.discontinuities[discontinuity] = {
                time,
                accuracy
              };
            }
          }
        }
      };
      _proto.dispose = function dispose() {
        this.trigger("dispose");
        this.off();
      };
      return SyncController2;
    }(videojs3.EventTarget);
    var TimelineChangeController = /* @__PURE__ */ function(_videojs$EventTarget) {
      _inheritsLoose__default["default"](TimelineChangeController2, _videojs$EventTarget);
      function TimelineChangeController2() {
        var _this;
        _this = _videojs$EventTarget.call(this) || this;
        _this.pendingTimelineChanges_ = {};
        _this.lastTimelineChanges_ = {};
        return _this;
      }
      var _proto = TimelineChangeController2.prototype;
      _proto.clearPendingTimelineChange = function clearPendingTimelineChange(type) {
        this.pendingTimelineChanges_[type] = null;
        this.trigger("pendingtimelinechange");
      };
      _proto.pendingTimelineChange = function pendingTimelineChange(_ref) {
        var type = _ref.type, from = _ref.from, to = _ref.to;
        if (typeof from === "number" && typeof to === "number") {
          this.pendingTimelineChanges_[type] = {
            type,
            from,
            to
          };
          this.trigger("pendingtimelinechange");
        }
        return this.pendingTimelineChanges_[type];
      };
      _proto.lastTimelineChange = function lastTimelineChange(_ref2) {
        var type = _ref2.type, from = _ref2.from, to = _ref2.to;
        if (typeof from === "number" && typeof to === "number") {
          this.lastTimelineChanges_[type] = {
            type,
            from,
            to
          };
          delete this.pendingTimelineChanges_[type];
          this.trigger("timelinechange");
        }
        return this.lastTimelineChanges_[type];
      };
      _proto.dispose = function dispose() {
        this.trigger("dispose");
        this.pendingTimelineChanges_ = {};
        this.lastTimelineChanges_ = {};
        this.off();
      };
      return TimelineChangeController2;
    }(videojs3.EventTarget);
    var workerCode = transform(getWorkerString(function() {
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
      function createCommonjsModule(fn, basedir, module2) {
        return module2 = {
          path: basedir,
          exports: {},
          require: function require2(path, base) {
            return commonjsRequire(path, base === void 0 || base === null ? module2.path : base);
          }
        }, fn(module2, module2.exports), module2.exports;
      }
      function commonjsRequire() {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
      }
      var createClass = createCommonjsModule(function(module2) {
        function _defineProperties(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        module2.exports = _createClass;
        module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
      });
      var setPrototypeOf = createCommonjsModule(function(module2) {
        function _setPrototypeOf(o, p) {
          module2.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
          return _setPrototypeOf(o, p);
        }
        module2.exports = _setPrototypeOf;
        module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
      });
      var inheritsLoose = createCommonjsModule(function(module2) {
        function _inheritsLoose3(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          setPrototypeOf(subClass, superClass);
        }
        module2.exports = _inheritsLoose3;
        module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
      });
      var Stream = /* @__PURE__ */ function() {
        function Stream2() {
          this.listeners = {};
        }
        var _proto = Stream2.prototype;
        _proto.on = function on2(type, listener) {
          if (!this.listeners[type]) {
            this.listeners[type] = [];
          }
          this.listeners[type].push(listener);
        };
        _proto.off = function off2(type, listener) {
          if (!this.listeners[type]) {
            return false;
          }
          var index = this.listeners[type].indexOf(listener);
          this.listeners[type] = this.listeners[type].slice(0);
          this.listeners[type].splice(index, 1);
          return index > -1;
        };
        _proto.trigger = function trigger2(type) {
          var callbacks = this.listeners[type];
          if (!callbacks) {
            return;
          }
          if (arguments.length === 2) {
            var length = callbacks.length;
            for (var i2 = 0; i2 < length; ++i2) {
              callbacks[i2].call(this, arguments[1]);
            }
          } else {
            var args = Array.prototype.slice.call(arguments, 1);
            var _length = callbacks.length;
            for (var _i2 = 0; _i2 < _length; ++_i2) {
              callbacks[_i2].apply(this, args);
            }
          }
        };
        _proto.dispose = function dispose() {
          this.listeners = {};
        };
        _proto.pipe = function pipe(destination) {
          this.on("data", function(data) {
            destination.push(data);
          });
        };
        return Stream2;
      }();
      function unpad(padded) {
        return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
      }
      var precompute = function precompute2() {
        var tables = [[[], [], [], [], []], [[], [], [], [], []]];
        var encTable = tables[0];
        var decTable = tables[1];
        var sbox = encTable[4];
        var sboxInv = decTable[4];
        var i2;
        var x;
        var xInv;
        var d = [];
        var th = [];
        var x2;
        var x4;
        var x8;
        var s;
        var tEnc;
        var tDec;
        for (i2 = 0; i2 < 256; i2++) {
          th[(d[i2] = i2 << 1 ^ (i2 >> 7) * 283) ^ i2] = i2;
        }
        for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
          s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
          s = s >> 8 ^ s & 255 ^ 99;
          sbox[x] = s;
          sboxInv[s] = x;
          x8 = d[x4 = d[x2 = d[x]]];
          tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          tEnc = d[s] * 257 ^ s * 16843008;
          for (i2 = 0; i2 < 4; i2++) {
            encTable[i2][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
            decTable[i2][s] = tDec = tDec << 24 ^ tDec >>> 8;
          }
        }
        for (i2 = 0; i2 < 5; i2++) {
          encTable[i2] = encTable[i2].slice(0);
          decTable[i2] = decTable[i2].slice(0);
        }
        return tables;
      };
      var aesTables = null;
      var AES = /* @__PURE__ */ function() {
        function AES2(key) {
          if (!aesTables) {
            aesTables = precompute();
          }
          this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];
          var i2;
          var j;
          var tmp;
          var sbox = this._tables[0][4];
          var decTable = this._tables[1];
          var keyLen = key.length;
          var rcon = 1;
          if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
            throw new Error("Invalid aes key size");
          }
          var encKey = key.slice(0);
          var decKey = [];
          this._key = [encKey, decKey];
          for (i2 = keyLen; i2 < 4 * keyLen + 28; i2++) {
            tmp = encKey[i2 - 1];
            if (i2 % keyLen === 0 || keyLen === 8 && i2 % keyLen === 4) {
              tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
              if (i2 % keyLen === 0) {
                tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                rcon = rcon << 1 ^ (rcon >> 7) * 283;
              }
            }
            encKey[i2] = encKey[i2 - keyLen] ^ tmp;
          }
          for (j = 0; i2; j++, i2--) {
            tmp = encKey[j & 3 ? i2 : i2 - 4];
            if (i2 <= 4 || j < 4) {
              decKey[j] = tmp;
            } else {
              decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
            }
          }
        }
        var _proto = AES2.prototype;
        _proto.decrypt = function decrypt3(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
          var key = this._key[1];
          var a = encrypted0 ^ key[0];
          var b = encrypted3 ^ key[1];
          var c = encrypted2 ^ key[2];
          var d = encrypted1 ^ key[3];
          var a2;
          var b2;
          var c2;
          var nInnerRounds = key.length / 4 - 2;
          var i2;
          var kIndex = 4;
          var table = this._tables[1];
          var table0 = table[0];
          var table1 = table[1];
          var table2 = table[2];
          var table3 = table[3];
          var sbox = table[4];
          for (i2 = 0; i2 < nInnerRounds; i2++) {
            a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
            b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
            c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
            d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a = a2;
            b = b2;
            c = c2;
          }
          for (i2 = 0; i2 < 4; i2++) {
            out[(3 & -i2) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
            a2 = a;
            a = b;
            b = c;
            c = d;
            d = a2;
          }
        };
        return AES2;
      }();
      var AsyncStream = /* @__PURE__ */ function(_Stream) {
        inheritsLoose(AsyncStream2, _Stream);
        function AsyncStream2() {
          var _this;
          _this = _Stream.call(this, Stream) || this;
          _this.jobs = [];
          _this.delay = 1;
          _this.timeout_ = null;
          return _this;
        }
        var _proto = AsyncStream2.prototype;
        _proto.processJob_ = function processJob_() {
          this.jobs.shift()();
          if (this.jobs.length) {
            this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
          } else {
            this.timeout_ = null;
          }
        };
        _proto.push = function push(job) {
          this.jobs.push(job);
          if (!this.timeout_) {
            this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
          }
        };
        return AsyncStream2;
      }(Stream);
      var ntoh = function ntoh2(word) {
        return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
      };
      var decrypt2 = function decrypt3(encrypted, key, initVector) {
        var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
        var decipher = new AES(Array.prototype.slice.call(key));
        var decrypted = new Uint8Array(encrypted.byteLength);
        var decrypted32 = new Int32Array(decrypted.buffer);
        var init0;
        var init1;
        var init2;
        var init3;
        var encrypted0;
        var encrypted1;
        var encrypted2;
        var encrypted3;
        var wordIx;
        init0 = initVector[0];
        init1 = initVector[1];
        init2 = initVector[2];
        init3 = initVector[3];
        for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
          encrypted0 = ntoh(encrypted32[wordIx]);
          encrypted1 = ntoh(encrypted32[wordIx + 1]);
          encrypted2 = ntoh(encrypted32[wordIx + 2]);
          encrypted3 = ntoh(encrypted32[wordIx + 3]);
          decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
          decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
          decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
          decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
          decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
          init0 = encrypted0;
          init1 = encrypted1;
          init2 = encrypted2;
          init3 = encrypted3;
        }
        return decrypted;
      };
      var Decrypter2 = /* @__PURE__ */ function() {
        function Decrypter3(encrypted, key, initVector, done) {
          var step = Decrypter3.STEP;
          var encrypted32 = new Int32Array(encrypted.buffer);
          var decrypted = new Uint8Array(encrypted.byteLength);
          var i2 = 0;
          this.asyncStream_ = new AsyncStream();
          this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i2, i2 + step), key, initVector, decrypted));
          for (i2 = step; i2 < encrypted32.length; i2 += step) {
            initVector = new Uint32Array([ntoh(encrypted32[i2 - 4]), ntoh(encrypted32[i2 - 3]), ntoh(encrypted32[i2 - 2]), ntoh(encrypted32[i2 - 1])]);
            this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i2, i2 + step), key, initVector, decrypted));
          }
          this.asyncStream_.push(function() {
            done(null, unpad(decrypted));
          });
        }
        var _proto = Decrypter3.prototype;
        _proto.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {
          return function() {
            var bytes = decrypt2(encrypted, key, initVector);
            decrypted.set(bytes, encrypted.byteOffset);
          };
        };
        createClass(Decrypter3, null, [{
          key: "STEP",
          get: function get2() {
            return 32e3;
          }
        }]);
        return Decrypter3;
      }();
      var win;
      if (typeof window !== "undefined") {
        win = window;
      } else if (typeof commonjsGlobal !== "undefined") {
        win = commonjsGlobal;
      } else if (typeof self !== "undefined") {
        win = self;
      } else {
        win = {};
      }
      var window_1 = win;
      var isArrayBufferView = function isArrayBufferView2(obj2) {
        if (ArrayBuffer.isView === "function") {
          return ArrayBuffer.isView(obj2);
        }
        return obj2 && obj2.buffer instanceof ArrayBuffer;
      };
      var BigInt = window_1.BigInt || Number;
      [BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000")];
      var createTransferableMessage2 = function createTransferableMessage3(message) {
        var transferable = {};
        Object.keys(message).forEach(function(key) {
          var value = message[key];
          if (isArrayBufferView(value)) {
            transferable[key] = {
              bytes: value.buffer,
              byteOffset: value.byteOffset,
              byteLength: value.byteLength
            };
          } else {
            transferable[key] = value;
          }
        });
        return transferable;
      };
      self.onmessage = function(event2) {
        var data = event2.data;
        var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
        var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
        var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
        new Decrypter2(encrypted, key, iv, function(err, bytes) {
          self.postMessage(createTransferableMessage2({
            source: data.source,
            decrypted: bytes
          }), [bytes.buffer]);
        });
      };
    }));
    var Decrypter = factory(workerCode);
    var audioTrackKind_ = function audioTrackKind_2(properties) {
      var kind = properties["default"] ? "main" : "alternative";
      if (properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0) {
        kind = "main-desc";
      }
      return kind;
    };
    var stopLoaders = function stopLoaders2(segmentLoader, mediaType) {
      segmentLoader.abort();
      segmentLoader.pause();
      if (mediaType && mediaType.activePlaylistLoader) {
        mediaType.activePlaylistLoader.pause();
        mediaType.activePlaylistLoader = null;
      }
    };
    var startLoaders = function startLoaders2(playlistLoader, mediaType) {
      mediaType.activePlaylistLoader = playlistLoader;
      playlistLoader.load();
    };
    var onGroupChanged = function onGroupChanged2(type, settings2) {
      return function() {
        var _settings$segmentLoad = settings2.segmentLoaders, segmentLoader = _settings$segmentLoad[type], mainSegmentLoader = _settings$segmentLoad.main, mediaType = settings2.mediaTypes[type];
        var activeTrack2 = mediaType.activeTrack();
        var activeGroup2 = mediaType.getActiveGroup();
        var previousActiveLoader = mediaType.activePlaylistLoader;
        var lastGroup = mediaType.lastGroup_;
        if (activeGroup2 && lastGroup && activeGroup2.id === lastGroup.id) {
          return;
        }
        mediaType.lastGroup_ = activeGroup2;
        mediaType.lastTrack_ = activeTrack2;
        stopLoaders(segmentLoader, mediaType);
        if (!activeGroup2 || activeGroup2.isMasterPlaylist) {
          return;
        }
        if (!activeGroup2.playlistLoader) {
          if (previousActiveLoader) {
            mainSegmentLoader.resetEverything();
          }
          return;
        }
        segmentLoader.resyncLoader();
        startLoaders(activeGroup2.playlistLoader, mediaType);
      };
    };
    var onGroupChanging = function onGroupChanging2(type, settings2) {
      return function() {
        var segmentLoader = settings2.segmentLoaders[type], mediaType = settings2.mediaTypes[type];
        mediaType.lastGroup_ = null;
        segmentLoader.abort();
        segmentLoader.pause();
      };
    };
    var onTrackChanged = function onTrackChanged2(type, settings2) {
      return function() {
        var masterPlaylistLoader = settings2.masterPlaylistLoader, _settings$segmentLoad2 = settings2.segmentLoaders, segmentLoader = _settings$segmentLoad2[type], mainSegmentLoader = _settings$segmentLoad2.main, mediaType = settings2.mediaTypes[type];
        var activeTrack2 = mediaType.activeTrack();
        var activeGroup2 = mediaType.getActiveGroup();
        var previousActiveLoader = mediaType.activePlaylistLoader;
        var lastTrack = mediaType.lastTrack_;
        if (lastTrack && activeTrack2 && lastTrack.id === activeTrack2.id) {
          return;
        }
        mediaType.lastGroup_ = activeGroup2;
        mediaType.lastTrack_ = activeTrack2;
        stopLoaders(segmentLoader, mediaType);
        if (!activeGroup2) {
          return;
        }
        if (activeGroup2.isMasterPlaylist) {
          if (!activeTrack2 || !lastTrack || activeTrack2.id === lastTrack.id) {
            return;
          }
          var mpc = settings2.vhs.masterPlaylistController_;
          var newPlaylist = mpc.selectPlaylist();
          if (mpc.media() === newPlaylist) {
            return;
          }
          mediaType.logger_("track change. Switching master audio from " + lastTrack.id + " to " + activeTrack2.id);
          masterPlaylistLoader.pause();
          mainSegmentLoader.resetEverything();
          mpc.fastQualityChange_(newPlaylist);
          return;
        }
        if (type === "AUDIO") {
          if (!activeGroup2.playlistLoader) {
            mainSegmentLoader.setAudio(true);
            mainSegmentLoader.resetEverything();
            return;
          }
          segmentLoader.setAudio(true);
          mainSegmentLoader.setAudio(false);
        }
        if (previousActiveLoader === activeGroup2.playlistLoader) {
          startLoaders(activeGroup2.playlistLoader, mediaType);
          return;
        }
        if (segmentLoader.track) {
          segmentLoader.track(activeTrack2);
        }
        segmentLoader.resetEverything();
        startLoaders(activeGroup2.playlistLoader, mediaType);
      };
    };
    var onError = {
      AUDIO: function AUDIO(type, settings2) {
        return function() {
          var segmentLoader = settings2.segmentLoaders[type], mediaType = settings2.mediaTypes[type], blacklistCurrentPlaylist = settings2.blacklistCurrentPlaylist;
          stopLoaders(segmentLoader, mediaType);
          var activeTrack2 = mediaType.activeTrack();
          var activeGroup2 = mediaType.activeGroup();
          var id = (activeGroup2.filter(function(group) {
            return group["default"];
          })[0] || activeGroup2[0]).id;
          var defaultTrack = mediaType.tracks[id];
          if (activeTrack2 === defaultTrack) {
            blacklistCurrentPlaylist({
              message: "Problem encountered loading the default audio track."
            });
            return;
          }
          videojs3.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
          for (var trackId in mediaType.tracks) {
            mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
          }
          mediaType.onTrackChanged();
        };
      },
      SUBTITLES: function SUBTITLES(type, settings2) {
        return function() {
          var segmentLoader = settings2.segmentLoaders[type], mediaType = settings2.mediaTypes[type];
          videojs3.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
          stopLoaders(segmentLoader, mediaType);
          var track = mediaType.activeTrack();
          if (track) {
            track.mode = "disabled";
          }
          mediaType.onTrackChanged();
        };
      }
    };
    var setupListeners = {
      AUDIO: function AUDIO(type, playlistLoader, settings2) {
        if (!playlistLoader) {
          return;
        }
        var tech = settings2.tech, requestOptions = settings2.requestOptions, segmentLoader = settings2.segmentLoaders[type];
        playlistLoader.on("loadedmetadata", function() {
          var media = playlistLoader.media();
          segmentLoader.playlist(media, requestOptions);
          if (!tech.paused() || media.endList && tech.preload() !== "none") {
            segmentLoader.load();
          }
        });
        playlistLoader.on("loadedplaylist", function() {
          segmentLoader.playlist(playlistLoader.media(), requestOptions);
          if (!tech.paused()) {
            segmentLoader.load();
          }
        });
        playlistLoader.on("error", onError[type](type, settings2));
      },
      SUBTITLES: function SUBTITLES(type, playlistLoader, settings2) {
        var tech = settings2.tech, requestOptions = settings2.requestOptions, segmentLoader = settings2.segmentLoaders[type], mediaType = settings2.mediaTypes[type];
        playlistLoader.on("loadedmetadata", function() {
          var media = playlistLoader.media();
          segmentLoader.playlist(media, requestOptions);
          segmentLoader.track(mediaType.activeTrack());
          if (!tech.paused() || media.endList && tech.preload() !== "none") {
            segmentLoader.load();
          }
        });
        playlistLoader.on("loadedplaylist", function() {
          segmentLoader.playlist(playlistLoader.media(), requestOptions);
          if (!tech.paused()) {
            segmentLoader.load();
          }
        });
        playlistLoader.on("error", onError[type](type, settings2));
      }
    };
    var initialize = {
      "AUDIO": function AUDIO(type, settings2) {
        var vhs = settings2.vhs, sourceType = settings2.sourceType, segmentLoader = settings2.segmentLoaders[type], requestOptions = settings2.requestOptions, mediaGroups = settings2.master.mediaGroups, _settings$mediaTypes$ = settings2.mediaTypes[type], groups = _settings$mediaTypes$.groups, tracks = _settings$mediaTypes$.tracks, logger_ = _settings$mediaTypes$.logger_, masterPlaylistLoader = settings2.masterPlaylistLoader;
        var audioOnlyMaster = isAudioOnly(masterPlaylistLoader.master);
        if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {
          mediaGroups[type] = {
            main: {
              "default": {
                "default": true
              }
            }
          };
          if (audioOnlyMaster) {
            mediaGroups[type].main["default"].playlists = masterPlaylistLoader.master.playlists;
          }
        }
        for (var groupId in mediaGroups[type]) {
          if (!groups[groupId]) {
            groups[groupId] = [];
          }
          for (var variantLabel in mediaGroups[type][groupId]) {
            var properties = mediaGroups[type][groupId][variantLabel];
            var playlistLoader = void 0;
            if (audioOnlyMaster) {
              logger_("AUDIO group '" + groupId + "' label '" + variantLabel + "' is a master playlist");
              properties.isMasterPlaylist = true;
              playlistLoader = null;
            } else if (sourceType === "vhs-json" && properties.playlists) {
              playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);
            } else if (properties.resolvedUri) {
              playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
            } else if (properties.playlists && sourceType === "dash") {
              playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
            } else {
              playlistLoader = null;
            }
            properties = videojs3.mergeOptions({
              id: variantLabel,
              playlistLoader
            }, properties);
            setupListeners[type](type, properties.playlistLoader, settings2);
            groups[groupId].push(properties);
            if (typeof tracks[variantLabel] === "undefined") {
              var track = new videojs3.AudioTrack({
                id: variantLabel,
                kind: audioTrackKind_(properties),
                enabled: false,
                language: properties.language,
                "default": properties["default"],
                label: variantLabel
              });
              tracks[variantLabel] = track;
            }
          }
        }
        segmentLoader.on("error", onError[type](type, settings2));
      },
      "SUBTITLES": function SUBTITLES(type, settings2) {
        var tech = settings2.tech, vhs = settings2.vhs, sourceType = settings2.sourceType, segmentLoader = settings2.segmentLoaders[type], requestOptions = settings2.requestOptions, mediaGroups = settings2.master.mediaGroups, _settings$mediaTypes$2 = settings2.mediaTypes[type], groups = _settings$mediaTypes$2.groups, tracks = _settings$mediaTypes$2.tracks, masterPlaylistLoader = settings2.masterPlaylistLoader;
        for (var groupId in mediaGroups[type]) {
          if (!groups[groupId]) {
            groups[groupId] = [];
          }
          for (var variantLabel in mediaGroups[type][groupId]) {
            if (mediaGroups[type][groupId][variantLabel].forced) {
              continue;
            }
            var properties = mediaGroups[type][groupId][variantLabel];
            var playlistLoader = void 0;
            if (sourceType === "hls") {
              playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
            } else if (sourceType === "dash") {
              var playlists = properties.playlists.filter(function(p) {
                return p.excludeUntil !== Infinity;
              });
              if (!playlists.length) {
                return;
              }
              playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, masterPlaylistLoader);
            } else if (sourceType === "vhs-json") {
              playlistLoader = new PlaylistLoader(properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);
            }
            properties = videojs3.mergeOptions({
              id: variantLabel,
              playlistLoader
            }, properties);
            setupListeners[type](type, properties.playlistLoader, settings2);
            groups[groupId].push(properties);
            if (typeof tracks[variantLabel] === "undefined") {
              var track = tech.addRemoteTextTrack({
                id: variantLabel,
                kind: "subtitles",
                "default": properties["default"] && properties.autoselect,
                language: properties.language,
                label: variantLabel
              }, false).track;
              tracks[variantLabel] = track;
            }
          }
        }
        segmentLoader.on("error", onError[type](type, settings2));
      },
      "CLOSED-CAPTIONS": function CLOSEDCAPTIONS(type, settings2) {
        var tech = settings2.tech, mediaGroups = settings2.master.mediaGroups, _settings$mediaTypes$3 = settings2.mediaTypes[type], groups = _settings$mediaTypes$3.groups, tracks = _settings$mediaTypes$3.tracks;
        for (var groupId in mediaGroups[type]) {
          if (!groups[groupId]) {
            groups[groupId] = [];
          }
          for (var variantLabel in mediaGroups[type][groupId]) {
            var properties = mediaGroups[type][groupId][variantLabel];
            if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {
              continue;
            }
            var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
            var newProps = {
              label: variantLabel,
              language: properties.language,
              instreamId: properties.instreamId,
              "default": properties["default"] && properties.autoselect
            };
            if (captionServices[newProps.instreamId]) {
              newProps = videojs3.mergeOptions(newProps, captionServices[newProps.instreamId]);
            }
            if (newProps["default"] === void 0) {
              delete newProps["default"];
            }
            groups[groupId].push(videojs3.mergeOptions({
              id: variantLabel
            }, properties));
            if (typeof tracks[variantLabel] === "undefined") {
              var track = tech.addRemoteTextTrack({
                id: newProps.instreamId,
                kind: "captions",
                "default": newProps["default"],
                language: newProps.language,
                label: newProps.label
              }, false).track;
              tracks[variantLabel] = track;
            }
          }
        }
      }
    };
    var groupMatch = function groupMatch2(list, media) {
      for (var i2 = 0; i2 < list.length; i2++) {
        if (playlistMatch(media, list[i2])) {
          return true;
        }
        if (list[i2].playlists && groupMatch2(list[i2].playlists, media)) {
          return true;
        }
      }
      return false;
    };
    var activeGroup = function activeGroup2(type, settings2) {
      return function(track) {
        var masterPlaylistLoader = settings2.masterPlaylistLoader, groups = settings2.mediaTypes[type].groups;
        var media = masterPlaylistLoader.media();
        if (!media) {
          return null;
        }
        var variants = null;
        if (media.attributes[type]) {
          variants = groups[media.attributes[type]];
        }
        var groupKeys = Object.keys(groups);
        if (!variants) {
          if (type === "AUDIO" && groupKeys.length > 1 && isAudioOnly(settings2.master)) {
            for (var i2 = 0; i2 < groupKeys.length; i2++) {
              var groupPropertyList = groups[groupKeys[i2]];
              if (groupMatch(groupPropertyList, media)) {
                variants = groupPropertyList;
                break;
              }
            }
          } else if (groups.main) {
            variants = groups.main;
          } else if (groupKeys.length === 1) {
            variants = groups[groupKeys[0]];
          }
        }
        if (typeof track === "undefined") {
          return variants;
        }
        if (track === null || !variants) {
          return null;
        }
        return variants.filter(function(props) {
          return props.id === track.id;
        })[0] || null;
      };
    };
    var activeTrack = {
      AUDIO: function AUDIO(type, settings2) {
        return function() {
          var tracks = settings2.mediaTypes[type].tracks;
          for (var id in tracks) {
            if (tracks[id].enabled) {
              return tracks[id];
            }
          }
          return null;
        };
      },
      SUBTITLES: function SUBTITLES(type, settings2) {
        return function() {
          var tracks = settings2.mediaTypes[type].tracks;
          for (var id in tracks) {
            if (tracks[id].mode === "showing" || tracks[id].mode === "hidden") {
              return tracks[id];
            }
          }
          return null;
        };
      }
    };
    var getActiveGroup = function getActiveGroup2(type, _ref) {
      var mediaTypes = _ref.mediaTypes;
      return function() {
        var activeTrack_ = mediaTypes[type].activeTrack();
        if (!activeTrack_) {
          return null;
        }
        return mediaTypes[type].activeGroup(activeTrack_);
      };
    };
    var setupMediaGroups = function setupMediaGroups2(settings2) {
      ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type) {
        initialize[type](type, settings2);
      });
      var mediaTypes = settings2.mediaTypes, masterPlaylistLoader = settings2.masterPlaylistLoader, tech = settings2.tech, vhs = settings2.vhs, _settings$segmentLoad3 = settings2.segmentLoaders, audioSegmentLoader = _settings$segmentLoad3["AUDIO"], mainSegmentLoader = _settings$segmentLoad3.main;
      ["AUDIO", "SUBTITLES"].forEach(function(type) {
        mediaTypes[type].activeGroup = activeGroup(type, settings2);
        mediaTypes[type].activeTrack = activeTrack[type](type, settings2);
        mediaTypes[type].onGroupChanged = onGroupChanged(type, settings2);
        mediaTypes[type].onGroupChanging = onGroupChanging(type, settings2);
        mediaTypes[type].onTrackChanged = onTrackChanged(type, settings2);
        mediaTypes[type].getActiveGroup = getActiveGroup(type, settings2);
      });
      var audioGroup = mediaTypes.AUDIO.activeGroup();
      if (audioGroup) {
        var groupId = (audioGroup.filter(function(group) {
          return group["default"];
        })[0] || audioGroup[0]).id;
        mediaTypes.AUDIO.tracks[groupId].enabled = true;
        mediaTypes.AUDIO.onGroupChanged();
        mediaTypes.AUDIO.onTrackChanged();
        var activeAudioGroup = mediaTypes.AUDIO.getActiveGroup();
        if (!activeAudioGroup.playlistLoader) {
          mainSegmentLoader.setAudio(true);
        } else {
          mainSegmentLoader.setAudio(false);
          audioSegmentLoader.setAudio(true);
        }
      }
      masterPlaylistLoader.on("mediachange", function() {
        ["AUDIO", "SUBTITLES"].forEach(function(type) {
          return mediaTypes[type].onGroupChanged();
        });
      });
      masterPlaylistLoader.on("mediachanging", function() {
        ["AUDIO", "SUBTITLES"].forEach(function(type) {
          return mediaTypes[type].onGroupChanging();
        });
      });
      var onAudioTrackChanged = function onAudioTrackChanged2() {
        mediaTypes.AUDIO.onTrackChanged();
        tech.trigger({
          type: "usage",
          name: "vhs-audio-change"
        });
        tech.trigger({
          type: "usage",
          name: "hls-audio-change"
        });
      };
      tech.audioTracks().addEventListener("change", onAudioTrackChanged);
      tech.remoteTextTracks().addEventListener("change", mediaTypes.SUBTITLES.onTrackChanged);
      vhs.on("dispose", function() {
        tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
        tech.remoteTextTracks().removeEventListener("change", mediaTypes.SUBTITLES.onTrackChanged);
      });
      tech.clearTracks("audio");
      for (var id in mediaTypes.AUDIO.tracks) {
        tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);
      }
    };
    var createMediaTypes = function createMediaTypes2() {
      var mediaTypes = {};
      ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type) {
        mediaTypes[type] = {
          groups: {},
          tracks: {},
          activePlaylistLoader: null,
          activeGroup: noop,
          activeTrack: noop,
          getActiveGroup: noop,
          onGroupChanged: noop,
          onTrackChanged: noop,
          lastTrack_: null,
          logger_: logger("MediaGroups[" + type + "]")
        };
      });
      return mediaTypes;
    };
    var ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;
    var Vhs$1;
    var loaderStats = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"];
    var sumLoaderStat = function sumLoaderStat2(stat) {
      return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
    };
    var shouldSwitchToMedia = function shouldSwitchToMedia2(_ref) {
      var currentPlaylist = _ref.currentPlaylist, buffered = _ref.buffered, currentTime = _ref.currentTime, nextPlaylist = _ref.nextPlaylist, bufferLowWaterLine = _ref.bufferLowWaterLine, bufferHighWaterLine = _ref.bufferHighWaterLine, duration2 = _ref.duration, experimentalBufferBasedABR = _ref.experimentalBufferBasedABR, log3 = _ref.log;
      if (!nextPlaylist) {
        videojs3.log.warn("We received no playlist to switch to. Please check your stream.");
        return false;
      }
      var sharedLogLine = "allowing switch " + (currentPlaylist && currentPlaylist.id || "null") + " -> " + nextPlaylist.id;
      if (!currentPlaylist) {
        log3(sharedLogLine + " as current playlist is not set");
        return true;
      }
      if (nextPlaylist.id === currentPlaylist.id) {
        return false;
      }
      var isBuffered = Boolean(findRange(buffered, currentTime).length);
      if (!currentPlaylist.endList) {
        if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
          log3("not " + sharedLogLine + " as current playlist is live llhls, but currentTime isn't in buffered.");
          return false;
        }
        log3(sharedLogLine + " as current playlist is live");
        return true;
      }
      var forwardBuffer = timeAheadOf(buffered, currentTime);
      var maxBufferLowWaterLine = experimentalBufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
      if (duration2 < maxBufferLowWaterLine) {
        log3(sharedLogLine + " as duration < max low water line (" + duration2 + " < " + maxBufferLowWaterLine + ")");
        return true;
      }
      var nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
      var currBandwidth = currentPlaylist.attributes.BANDWIDTH;
      if (nextBandwidth < currBandwidth && (!experimentalBufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
        var logLine = sharedLogLine + " as next bandwidth < current bandwidth (" + nextBandwidth + " < " + currBandwidth + ")";
        if (experimentalBufferBasedABR) {
          logLine += " and forwardBuffer < bufferHighWaterLine (" + forwardBuffer + " < " + bufferHighWaterLine + ")";
        }
        log3(logLine);
        return true;
      }
      if ((!experimentalBufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
        var _logLine = sharedLogLine + " as forwardBuffer >= bufferLowWaterLine (" + forwardBuffer + " >= " + bufferLowWaterLine + ")";
        if (experimentalBufferBasedABR) {
          _logLine += " and next bandwidth > current bandwidth (" + nextBandwidth + " > " + currBandwidth + ")";
        }
        log3(_logLine);
        return true;
      }
      log3("not " + sharedLogLine + " as no switching criteria met");
      return false;
    };
    var MasterPlaylistController = /* @__PURE__ */ function(_videojs$EventTarget) {
      _inheritsLoose__default["default"](MasterPlaylistController2, _videojs$EventTarget);
      function MasterPlaylistController2(options) {
        var _this;
        _this = _videojs$EventTarget.call(this) || this;
        var src = options.src, handleManifestRedirects = options.handleManifestRedirects, withCredentials = options.withCredentials, tech = options.tech, bandwidth = options.bandwidth, externVhs = options.externVhs, useCueTags = options.useCueTags, blacklistDuration = options.blacklistDuration, enableLowInitialPlaylist = options.enableLowInitialPlaylist, sourceType = options.sourceType, cacheEncryptionKeys = options.cacheEncryptionKeys, experimentalBufferBasedABR = options.experimentalBufferBasedABR, experimentalLeastPixelDiffSelector = options.experimentalLeastPixelDiffSelector, captionServices = options.captionServices;
        if (!src) {
          throw new Error("A non-empty playlist URL or JSON manifest string is required");
        }
        var maxPlaylistRetries = options.maxPlaylistRetries;
        if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") {
          maxPlaylistRetries = Infinity;
        }
        Vhs$1 = externVhs;
        _this.experimentalBufferBasedABR = Boolean(experimentalBufferBasedABR);
        _this.experimentalLeastPixelDiffSelector = Boolean(experimentalLeastPixelDiffSelector);
        _this.withCredentials = withCredentials;
        _this.tech_ = tech;
        _this.vhs_ = tech.vhs;
        _this.sourceType_ = sourceType;
        _this.useCueTags_ = useCueTags;
        _this.blacklistDuration = blacklistDuration;
        _this.maxPlaylistRetries = maxPlaylistRetries;
        _this.enableLowInitialPlaylist = enableLowInitialPlaylist;
        if (_this.useCueTags_) {
          _this.cueTagsTrack_ = _this.tech_.addTextTrack("metadata", "ad-cues");
          _this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
        }
        _this.requestOptions_ = {
          withCredentials,
          handleManifestRedirects,
          maxPlaylistRetries,
          timeout: null
        };
        _this.on("error", _this.pauseLoading);
        _this.mediaTypes_ = createMediaTypes();
        _this.mediaSource = new window__default["default"].MediaSource();
        _this.handleDurationChange_ = _this.handleDurationChange_.bind(_assertThisInitialized__default["default"](_this));
        _this.handleSourceOpen_ = _this.handleSourceOpen_.bind(_assertThisInitialized__default["default"](_this));
        _this.handleSourceEnded_ = _this.handleSourceEnded_.bind(_assertThisInitialized__default["default"](_this));
        _this.mediaSource.addEventListener("durationchange", _this.handleDurationChange_);
        _this.mediaSource.addEventListener("sourceopen", _this.handleSourceOpen_);
        _this.mediaSource.addEventListener("sourceended", _this.handleSourceEnded_);
        _this.seekable_ = videojs3.createTimeRanges();
        _this.hasPlayed_ = false;
        _this.syncController_ = new SyncController(options);
        _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
          kind: "metadata",
          label: "segment-metadata"
        }, false).track;
        _this.decrypter_ = new Decrypter();
        _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource);
        _this.inbandTextTracks_ = {};
        _this.timelineChangeController_ = new TimelineChangeController();
        var segmentLoaderSettings = {
          vhs: _this.vhs_,
          parse708captions: options.parse708captions,
          useDtsForTimestampOffset: options.useDtsForTimestampOffset,
          captionServices,
          mediaSource: _this.mediaSource,
          currentTime: _this.tech_.currentTime.bind(_this.tech_),
          seekable: function seekable2() {
            return _this.seekable();
          },
          seeking: function seeking() {
            return _this.tech_.seeking();
          },
          duration: function duration2() {
            return _this.duration();
          },
          hasPlayed: function hasPlayed() {
            return _this.hasPlayed_;
          },
          goalBufferLength: function goalBufferLength() {
            return _this.goalBufferLength();
          },
          bandwidth,
          syncController: _this.syncController_,
          decrypter: _this.decrypter_,
          sourceType: _this.sourceType_,
          inbandTextTracks: _this.inbandTextTracks_,
          cacheEncryptionKeys,
          sourceUpdater: _this.sourceUpdater_,
          timelineChangeController: _this.timelineChangeController_,
          experimentalExactManifestTimings: options.experimentalExactManifestTimings
        };
        _this.masterPlaylistLoader_ = _this.sourceType_ === "dash" ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader(src, _this.vhs_, _this.requestOptions_);
        _this.setupMasterPlaylistLoaderListeners_();
        _this.mainSegmentLoader_ = new SegmentLoader(videojs3.mergeOptions(segmentLoaderSettings, {
          segmentMetadataTrack: _this.segmentMetadataTrack_,
          loaderType: "main"
        }), options);
        _this.audioSegmentLoader_ = new SegmentLoader(videojs3.mergeOptions(segmentLoaderSettings, {
          loaderType: "audio"
        }), options);
        _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs3.mergeOptions(segmentLoaderSettings, {
          loaderType: "vtt",
          featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks,
          loadVttJs: function loadVttJs() {
            return new Promise(function(resolve, reject) {
              function onLoad() {
                tech.off("vttjserror", onError2);
                resolve();
              }
              function onError2() {
                tech.off("vttjsloaded", onLoad);
                reject();
              }
              tech.one("vttjsloaded", onLoad);
              tech.one("vttjserror", onError2);
              tech.addWebVttScript_();
            });
          }
        }), options);
        _this.setupSegmentLoaderListeners_();
        if (_this.experimentalBufferBasedABR) {
          _this.masterPlaylistLoader_.one("loadedplaylist", function() {
            return _this.startABRTimer_();
          });
          _this.tech_.on("pause", function() {
            return _this.stopABRTimer_();
          });
          _this.tech_.on("play", function() {
            return _this.startABRTimer_();
          });
        }
        loaderStats.forEach(function(stat) {
          _this[stat + "_"] = sumLoaderStat.bind(_assertThisInitialized__default["default"](_this), stat);
        });
        _this.logger_ = logger("MPC");
        _this.triggeredFmp4Usage = false;
        if (_this.tech_.preload() === "none") {
          _this.loadOnPlay_ = function() {
            _this.loadOnPlay_ = null;
            _this.masterPlaylistLoader_.load();
          };
          _this.tech_.one("play", _this.loadOnPlay_);
        } else {
          _this.masterPlaylistLoader_.load();
        }
        _this.timeToLoadedData__ = -1;
        _this.mainAppendsToLoadedData__ = -1;
        _this.audioAppendsToLoadedData__ = -1;
        var event2 = _this.tech_.preload() === "none" ? "play" : "loadstart";
        _this.tech_.one(event2, function() {
          var timeToLoadedDataStart = Date.now();
          _this.tech_.one("loadeddata", function() {
            _this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
            _this.mainAppendsToLoadedData__ = _this.mainSegmentLoader_.mediaAppends;
            _this.audioAppendsToLoadedData__ = _this.audioSegmentLoader_.mediaAppends;
          });
        });
        return _this;
      }
      var _proto = MasterPlaylistController2.prototype;
      _proto.mainAppendsToLoadedData_ = function mainAppendsToLoadedData_() {
        return this.mainAppendsToLoadedData__;
      };
      _proto.audioAppendsToLoadedData_ = function audioAppendsToLoadedData_() {
        return this.audioAppendsToLoadedData__;
      };
      _proto.appendsToLoadedData_ = function appendsToLoadedData_() {
        var main = this.mainAppendsToLoadedData_();
        var audio = this.audioAppendsToLoadedData_();
        if (main === -1 || audio === -1) {
          return -1;
        }
        return main + audio;
      };
      _proto.timeToLoadedData_ = function timeToLoadedData_() {
        return this.timeToLoadedData__;
      };
      _proto.checkABR_ = function checkABR_(reason) {
        if (reason === void 0) {
          reason = "abr";
        }
        var nextPlaylist = this.selectPlaylist();
        if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {
          this.switchMedia_(nextPlaylist, reason);
        }
      };
      _proto.switchMedia_ = function switchMedia_(playlist, cause, delay) {
        var oldMedia = this.media();
        var oldId = oldMedia && (oldMedia.id || oldMedia.uri);
        var newId = playlist.id || playlist.uri;
        if (oldId && oldId !== newId) {
          this.logger_("switch media " + oldId + " -> " + newId + " from " + cause);
          this.tech_.trigger({
            type: "usage",
            name: "vhs-rendition-change-" + cause
          });
        }
        this.masterPlaylistLoader_.media(playlist, delay);
      };
      _proto.startABRTimer_ = function startABRTimer_() {
        var _this2 = this;
        this.stopABRTimer_();
        this.abrTimer_ = window__default["default"].setInterval(function() {
          return _this2.checkABR_();
        }, 250);
      };
      _proto.stopABRTimer_ = function stopABRTimer_() {
        if (this.tech_.scrubbing && this.tech_.scrubbing()) {
          return;
        }
        window__default["default"].clearInterval(this.abrTimer_);
        this.abrTimer_ = null;
      };
      _proto.getAudioTrackPlaylists_ = function getAudioTrackPlaylists_() {
        var master = this.master();
        var defaultPlaylists = master && master.playlists || [];
        if (!master || !master.mediaGroups || !master.mediaGroups.AUDIO) {
          return defaultPlaylists;
        }
        var AUDIO = master.mediaGroups.AUDIO;
        var groupKeys = Object.keys(AUDIO);
        var track;
        if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {
          track = this.mediaTypes_.AUDIO.activeTrack();
        } else {
          var defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];
          for (var label in defaultGroup) {
            if (defaultGroup[label]["default"]) {
              track = {
                label
              };
              break;
            }
          }
        }
        if (!track) {
          return defaultPlaylists;
        }
        var playlists = [];
        for (var group in AUDIO) {
          if (AUDIO[group][track.label]) {
            var properties = AUDIO[group][track.label];
            if (properties.playlists && properties.playlists.length) {
              playlists.push.apply(playlists, properties.playlists);
            } else if (properties.uri) {
              playlists.push(properties);
            } else if (master.playlists.length) {
              for (var i2 = 0; i2 < master.playlists.length; i2++) {
                var playlist = master.playlists[i2];
                if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {
                  playlists.push(playlist);
                }
              }
            }
          }
        }
        if (!playlists.length) {
          return defaultPlaylists;
        }
        return playlists;
      };
      _proto.setupMasterPlaylistLoaderListeners_ = function setupMasterPlaylistLoaderListeners_() {
        var _this3 = this;
        this.masterPlaylistLoader_.on("loadedmetadata", function() {
          var media = _this3.masterPlaylistLoader_.media();
          var requestTimeout = media.targetDuration * 1.5 * 1e3;
          if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
            _this3.requestOptions_.timeout = 0;
          } else {
            _this3.requestOptions_.timeout = requestTimeout;
          }
          if (media.endList && _this3.tech_.preload() !== "none") {
            _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
            _this3.mainSegmentLoader_.load();
          }
          setupMediaGroups({
            sourceType: _this3.sourceType_,
            segmentLoaders: {
              AUDIO: _this3.audioSegmentLoader_,
              SUBTITLES: _this3.subtitleSegmentLoader_,
              main: _this3.mainSegmentLoader_
            },
            tech: _this3.tech_,
            requestOptions: _this3.requestOptions_,
            masterPlaylistLoader: _this3.masterPlaylistLoader_,
            vhs: _this3.vhs_,
            master: _this3.master(),
            mediaTypes: _this3.mediaTypes_,
            blacklistCurrentPlaylist: _this3.blacklistCurrentPlaylist.bind(_this3)
          });
          _this3.triggerPresenceUsage_(_this3.master(), media);
          _this3.setupFirstPlay();
          if (!_this3.mediaTypes_.AUDIO.activePlaylistLoader || _this3.mediaTypes_.AUDIO.activePlaylistLoader.media()) {
            _this3.trigger("selectedinitialmedia");
          } else {
            _this3.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", function() {
              _this3.trigger("selectedinitialmedia");
            });
          }
        });
        this.masterPlaylistLoader_.on("loadedplaylist", function() {
          if (_this3.loadOnPlay_) {
            _this3.tech_.off("play", _this3.loadOnPlay_);
          }
          var updatedPlaylist = _this3.masterPlaylistLoader_.media();
          if (!updatedPlaylist) {
            _this3.excludeUnsupportedVariants_();
            var selectedMedia;
            if (_this3.enableLowInitialPlaylist) {
              selectedMedia = _this3.selectInitialPlaylist();
            }
            if (!selectedMedia) {
              selectedMedia = _this3.selectPlaylist();
            }
            if (!selectedMedia || !_this3.shouldSwitchToMedia_(selectedMedia)) {
              return;
            }
            _this3.initialMedia_ = selectedMedia;
            _this3.switchMedia_(_this3.initialMedia_, "initial");
            var haveJsonSource = _this3.sourceType_ === "vhs-json" && _this3.initialMedia_.segments;
            if (!haveJsonSource) {
              return;
            }
            updatedPlaylist = _this3.initialMedia_;
          }
          _this3.handleUpdatedMediaPlaylist(updatedPlaylist);
        });
        this.masterPlaylistLoader_.on("error", function() {
          _this3.blacklistCurrentPlaylist(_this3.masterPlaylistLoader_.error);
        });
        this.masterPlaylistLoader_.on("mediachanging", function() {
          _this3.mainSegmentLoader_.abort();
          _this3.mainSegmentLoader_.pause();
        });
        this.masterPlaylistLoader_.on("mediachange", function() {
          var media = _this3.masterPlaylistLoader_.media();
          var requestTimeout = media.targetDuration * 1.5 * 1e3;
          if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
            _this3.requestOptions_.timeout = 0;
          } else {
            _this3.requestOptions_.timeout = requestTimeout;
          }
          _this3.masterPlaylistLoader_.load();
          _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
          _this3.mainSegmentLoader_.load();
          _this3.tech_.trigger({
            type: "mediachange",
            bubbles: true
          });
        });
        this.masterPlaylistLoader_.on("playlistunchanged", function() {
          var updatedPlaylist = _this3.masterPlaylistLoader_.media();
          if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") {
            return;
          }
          var playlistOutdated = _this3.stuckAtPlaylistEnd_(updatedPlaylist);
          if (playlistOutdated) {
            _this3.blacklistCurrentPlaylist({
              message: "Playlist no longer updating.",
              reason: "playlist-unchanged"
            });
            _this3.tech_.trigger("playliststuck");
          }
        });
        this.masterPlaylistLoader_.on("renditiondisabled", function() {
          _this3.tech_.trigger({
            type: "usage",
            name: "vhs-rendition-disabled"
          });
          _this3.tech_.trigger({
            type: "usage",
            name: "hls-rendition-disabled"
          });
        });
        this.masterPlaylistLoader_.on("renditionenabled", function() {
          _this3.tech_.trigger({
            type: "usage",
            name: "vhs-rendition-enabled"
          });
          _this3.tech_.trigger({
            type: "usage",
            name: "hls-rendition-enabled"
          });
        });
      };
      _proto.handleUpdatedMediaPlaylist = function handleUpdatedMediaPlaylist(updatedPlaylist) {
        if (this.useCueTags_) {
          this.updateAdCues_(updatedPlaylist);
        }
        this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
        this.updateDuration(!updatedPlaylist.endList);
        if (!this.tech_.paused()) {
          this.mainSegmentLoader_.load();
          if (this.audioSegmentLoader_) {
            this.audioSegmentLoader_.load();
          }
        }
      };
      _proto.triggerPresenceUsage_ = function triggerPresenceUsage_(master, media) {
        var mediaGroups = master.mediaGroups || {};
        var defaultDemuxed = true;
        var audioGroupKeys = Object.keys(mediaGroups.AUDIO);
        for (var mediaGroup in mediaGroups.AUDIO) {
          for (var label in mediaGroups.AUDIO[mediaGroup]) {
            var properties = mediaGroups.AUDIO[mediaGroup][label];
            if (!properties.uri) {
              defaultDemuxed = false;
            }
          }
        }
        if (defaultDemuxed) {
          this.tech_.trigger({
            type: "usage",
            name: "vhs-demuxed"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-demuxed"
          });
        }
        if (Object.keys(mediaGroups.SUBTITLES).length) {
          this.tech_.trigger({
            type: "usage",
            name: "vhs-webvtt"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-webvtt"
          });
        }
        if (Vhs$1.Playlist.isAes(media)) {
          this.tech_.trigger({
            type: "usage",
            name: "vhs-aes"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-aes"
          });
        }
        if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {
          this.tech_.trigger({
            type: "usage",
            name: "vhs-alternate-audio"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-alternate-audio"
          });
        }
        if (this.useCueTags_) {
          this.tech_.trigger({
            type: "usage",
            name: "vhs-playlist-cue-tags"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-playlist-cue-tags"
          });
        }
      };
      _proto.shouldSwitchToMedia_ = function shouldSwitchToMedia_(nextPlaylist) {
        var currentPlaylist = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_;
        var currentTime = this.tech_.currentTime();
        var bufferLowWaterLine = this.bufferLowWaterLine();
        var bufferHighWaterLine = this.bufferHighWaterLine();
        var buffered = this.tech_.buffered();
        return shouldSwitchToMedia({
          buffered,
          currentTime,
          currentPlaylist,
          nextPlaylist,
          bufferLowWaterLine,
          bufferHighWaterLine,
          duration: this.duration(),
          experimentalBufferBasedABR: this.experimentalBufferBasedABR,
          log: this.logger_
        });
      };
      _proto.setupSegmentLoaderListeners_ = function setupSegmentLoaderListeners_() {
        var _this4 = this;
        this.mainSegmentLoader_.on("bandwidthupdate", function() {
          _this4.checkABR_("bandwidthupdate");
          _this4.tech_.trigger("bandwidthupdate");
        });
        this.mainSegmentLoader_.on("timeout", function() {
          if (_this4.experimentalBufferBasedABR) {
            _this4.mainSegmentLoader_.load();
          }
        });
        if (!this.experimentalBufferBasedABR) {
          this.mainSegmentLoader_.on("progress", function() {
            _this4.trigger("progress");
          });
        }
        this.mainSegmentLoader_.on("error", function() {
          _this4.blacklistCurrentPlaylist(_this4.mainSegmentLoader_.error());
        });
        this.mainSegmentLoader_.on("appenderror", function() {
          _this4.error = _this4.mainSegmentLoader_.error_;
          _this4.trigger("error");
        });
        this.mainSegmentLoader_.on("syncinfoupdate", function() {
          _this4.onSyncInfoUpdate_();
        });
        this.mainSegmentLoader_.on("timestampoffset", function() {
          _this4.tech_.trigger({
            type: "usage",
            name: "vhs-timestamp-offset"
          });
          _this4.tech_.trigger({
            type: "usage",
            name: "hls-timestamp-offset"
          });
        });
        this.audioSegmentLoader_.on("syncinfoupdate", function() {
          _this4.onSyncInfoUpdate_();
        });
        this.audioSegmentLoader_.on("appenderror", function() {
          _this4.error = _this4.audioSegmentLoader_.error_;
          _this4.trigger("error");
        });
        this.mainSegmentLoader_.on("ended", function() {
          _this4.logger_("main segment loader ended");
          _this4.onEndOfStream();
        });
        this.mainSegmentLoader_.on("earlyabort", function(event2) {
          if (_this4.experimentalBufferBasedABR) {
            return;
          }
          _this4.delegateLoaders_("all", ["abort"]);
          _this4.blacklistCurrentPlaylist({
            message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
          }, ABORT_EARLY_BLACKLIST_SECONDS);
        });
        var updateCodecs = function updateCodecs2() {
          if (!_this4.sourceUpdater_.hasCreatedSourceBuffers()) {
            return _this4.tryToCreateSourceBuffers_();
          }
          var codecs = _this4.getCodecsOrExclude_();
          if (!codecs) {
            return;
          }
          _this4.sourceUpdater_.addOrChangeSourceBuffers(codecs);
        };
        this.mainSegmentLoader_.on("trackinfo", updateCodecs);
        this.audioSegmentLoader_.on("trackinfo", updateCodecs);
        this.mainSegmentLoader_.on("fmp4", function() {
          if (!_this4.triggeredFmp4Usage) {
            _this4.tech_.trigger({
              type: "usage",
              name: "vhs-fmp4"
            });
            _this4.tech_.trigger({
              type: "usage",
              name: "hls-fmp4"
            });
            _this4.triggeredFmp4Usage = true;
          }
        });
        this.audioSegmentLoader_.on("fmp4", function() {
          if (!_this4.triggeredFmp4Usage) {
            _this4.tech_.trigger({
              type: "usage",
              name: "vhs-fmp4"
            });
            _this4.tech_.trigger({
              type: "usage",
              name: "hls-fmp4"
            });
            _this4.triggeredFmp4Usage = true;
          }
        });
        this.audioSegmentLoader_.on("ended", function() {
          _this4.logger_("audioSegmentLoader ended");
          _this4.onEndOfStream();
        });
      };
      _proto.mediaSecondsLoaded_ = function mediaSecondsLoaded_() {
        return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
      };
      _proto.load = function load() {
        this.mainSegmentLoader_.load();
        if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
          this.audioSegmentLoader_.load();
        }
        if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
          this.subtitleSegmentLoader_.load();
        }
      };
      _proto.smoothQualityChange_ = function smoothQualityChange_(media) {
        if (media === void 0) {
          media = this.selectPlaylist();
        }
        this.fastQualityChange_(media);
      };
      _proto.fastQualityChange_ = function fastQualityChange_(media) {
        var _this5 = this;
        if (media === void 0) {
          media = this.selectPlaylist();
        }
        if (media === this.masterPlaylistLoader_.media()) {
          this.logger_("skipping fastQualityChange because new media is same as old");
          return;
        }
        this.switchMedia_(media, "fast-quality");
        this.mainSegmentLoader_.resetEverything(function() {
          if (videojs3.browser.IE_VERSION || videojs3.browser.IS_EDGE) {
            _this5.tech_.setCurrentTime(_this5.tech_.currentTime() + 0.04);
          } else {
            _this5.tech_.setCurrentTime(_this5.tech_.currentTime());
          }
        });
      };
      _proto.play = function play() {
        if (this.setupFirstPlay()) {
          return;
        }
        if (this.tech_.ended()) {
          this.tech_.setCurrentTime(0);
        }
        if (this.hasPlayed_) {
          this.load();
        }
        var seekable2 = this.tech_.seekable();
        if (this.tech_.duration() === Infinity) {
          if (this.tech_.currentTime() < seekable2.start(0)) {
            return this.tech_.setCurrentTime(seekable2.end(seekable2.length - 1));
          }
        }
      };
      _proto.setupFirstPlay = function setupFirstPlay() {
        var _this6 = this;
        var media = this.masterPlaylistLoader_.media();
        if (!media || this.tech_.paused() || this.hasPlayed_) {
          return false;
        }
        if (!media.endList) {
          var seekable2 = this.seekable();
          if (!seekable2.length) {
            return false;
          }
          if (videojs3.browser.IE_VERSION && this.tech_.readyState() === 0) {
            this.tech_.one("loadedmetadata", function() {
              _this6.trigger("firstplay");
              _this6.tech_.setCurrentTime(seekable2.end(0));
              _this6.hasPlayed_ = true;
            });
            return false;
          }
          this.trigger("firstplay");
          this.tech_.setCurrentTime(seekable2.end(0));
        }
        this.hasPlayed_ = true;
        this.load();
        return true;
      };
      _proto.handleSourceOpen_ = function handleSourceOpen_() {
        this.tryToCreateSourceBuffers_();
        if (this.tech_.autoplay()) {
          var playPromise = this.tech_.play();
          if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") {
            playPromise.then(null, function(e) {
            });
          }
        }
        this.trigger("sourceopen");
      };
      _proto.handleSourceEnded_ = function handleSourceEnded_() {
        if (!this.inbandTextTracks_.metadataTrack_) {
          return;
        }
        var cues = this.inbandTextTracks_.metadataTrack_.cues;
        if (!cues || !cues.length) {
          return;
        }
        var duration2 = this.duration();
        cues[cues.length - 1].endTime = isNaN(duration2) || Math.abs(duration2) === Infinity ? Number.MAX_VALUE : duration2;
      };
      _proto.handleDurationChange_ = function handleDurationChange_() {
        this.tech_.trigger("durationchange");
      };
      _proto.onEndOfStream = function onEndOfStream() {
        var isEndOfStream = this.mainSegmentLoader_.ended_;
        if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
          var mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
          if (!mainMediaInfo || mainMediaInfo.hasVideo) {
            isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;
          } else {
            isEndOfStream = this.audioSegmentLoader_.ended_;
          }
        }
        if (!isEndOfStream) {
          return;
        }
        this.stopABRTimer_();
        this.sourceUpdater_.endOfStream();
      };
      _proto.stuckAtPlaylistEnd_ = function stuckAtPlaylistEnd_(playlist) {
        var seekable2 = this.seekable();
        if (!seekable2.length) {
          return false;
        }
        var expired = this.syncController_.getExpiredTime(playlist, this.duration());
        if (expired === null) {
          return false;
        }
        var absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
        var currentTime = this.tech_.currentTime();
        var buffered = this.tech_.buffered();
        if (!buffered.length) {
          return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
        }
        var bufferedEnd = buffered.end(buffered.length - 1);
        return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
      };
      _proto.blacklistCurrentPlaylist = function blacklistCurrentPlaylist(error, blacklistDuration) {
        if (error === void 0) {
          error = {};
        }
        var currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();
        blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;
        if (!currentPlaylist) {
          this.error = error;
          if (this.mediaSource.readyState !== "open") {
            this.trigger("error");
          } else {
            this.sourceUpdater_.endOfStream("network");
          }
          return;
        }
        currentPlaylist.playlistErrors_++;
        var playlists = this.masterPlaylistLoader_.master.playlists;
        var enabledPlaylists = playlists.filter(isEnabled);
        var isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === currentPlaylist;
        if (playlists.length === 1 && blacklistDuration !== Infinity) {
          videojs3.log.warn("Problem encountered with playlist " + currentPlaylist.id + ". Trying again since it is the only playlist.");
          this.tech_.trigger("retryplaylist");
          return this.masterPlaylistLoader_.load(isFinalRendition);
        }
        if (isFinalRendition) {
          var reincluded = false;
          playlists.forEach(function(playlist) {
            if (playlist === currentPlaylist) {
              return;
            }
            var excludeUntil2 = playlist.excludeUntil;
            if (typeof excludeUntil2 !== "undefined" && excludeUntil2 !== Infinity) {
              reincluded = true;
              delete playlist.excludeUntil;
            }
          });
          if (reincluded) {
            videojs3.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded.");
            this.tech_.trigger("retryplaylist");
          }
        }
        var excludeUntil;
        if (currentPlaylist.playlistErrors_ > this.maxPlaylistRetries) {
          excludeUntil = Infinity;
        } else {
          excludeUntil = Date.now() + blacklistDuration * 1e3;
        }
        currentPlaylist.excludeUntil = excludeUntil;
        if (error.reason) {
          currentPlaylist.lastExcludeReason_ = error.reason;
        }
        this.tech_.trigger("blacklistplaylist");
        this.tech_.trigger({
          type: "usage",
          name: "vhs-rendition-blacklisted"
        });
        this.tech_.trigger({
          type: "usage",
          name: "hls-rendition-blacklisted"
        });
        var nextPlaylist = this.selectPlaylist();
        if (!nextPlaylist) {
          this.error = "Playback cannot continue. No available working or supported playlists.";
          this.trigger("error");
          return;
        }
        var logFn2 = error.internal ? this.logger_ : videojs3.log.warn;
        var errorMessage = error.message ? " " + error.message : "";
        logFn2((error.internal ? "Internal problem" : "Problem") + " encountered with playlist " + currentPlaylist.id + "." + (errorMessage + " Switching to playlist " + nextPlaylist.id + "."));
        if (nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO) {
          this.delegateLoaders_("audio", ["abort", "pause"]);
        }
        if (nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES) {
          this.delegateLoaders_("subtitle", ["abort", "pause"]);
        }
        this.delegateLoaders_("main", ["abort", "pause"]);
        var delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
        var shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
        return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
      };
      _proto.pauseLoading = function pauseLoading() {
        this.delegateLoaders_("all", ["abort", "pause"]);
        this.stopABRTimer_();
      };
      _proto.delegateLoaders_ = function delegateLoaders_(filter, fnNames) {
        var _this7 = this;
        var loaders = [];
        var dontFilterPlaylist = filter === "all";
        if (dontFilterPlaylist || filter === "main") {
          loaders.push(this.masterPlaylistLoader_);
        }
        var mediaTypes = [];
        if (dontFilterPlaylist || filter === "audio") {
          mediaTypes.push("AUDIO");
        }
        if (dontFilterPlaylist || filter === "subtitle") {
          mediaTypes.push("CLOSED-CAPTIONS");
          mediaTypes.push("SUBTITLES");
        }
        mediaTypes.forEach(function(mediaType) {
          var loader = _this7.mediaTypes_[mediaType] && _this7.mediaTypes_[mediaType].activePlaylistLoader;
          if (loader) {
            loaders.push(loader);
          }
        });
        ["main", "audio", "subtitle"].forEach(function(name) {
          var loader = _this7[name + "SegmentLoader_"];
          if (loader && (filter === name || filter === "all")) {
            loaders.push(loader);
          }
        });
        loaders.forEach(function(loader) {
          return fnNames.forEach(function(fnName) {
            if (typeof loader[fnName] === "function") {
              loader[fnName]();
            }
          });
        });
      };
      _proto.setCurrentTime = function setCurrentTime(currentTime) {
        var buffered = findRange(this.tech_.buffered(), currentTime);
        if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {
          return 0;
        }
        if (!this.masterPlaylistLoader_.media().segments) {
          return 0;
        }
        if (buffered && buffered.length) {
          return currentTime;
        }
        this.mainSegmentLoader_.resetEverything();
        this.mainSegmentLoader_.abort();
        if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
          this.audioSegmentLoader_.resetEverything();
          this.audioSegmentLoader_.abort();
        }
        if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
          this.subtitleSegmentLoader_.resetEverything();
          this.subtitleSegmentLoader_.abort();
        }
        this.load();
      };
      _proto.duration = function duration2() {
        if (!this.masterPlaylistLoader_) {
          return 0;
        }
        var media = this.masterPlaylistLoader_.media();
        if (!media) {
          return 0;
        }
        if (!media.endList) {
          return Infinity;
        }
        if (this.mediaSource) {
          return this.mediaSource.duration;
        }
        return Vhs$1.Playlist.duration(media);
      };
      _proto.seekable = function seekable2() {
        return this.seekable_;
      };
      _proto.onSyncInfoUpdate_ = function onSyncInfoUpdate_() {
        var audioSeekable;
        if (!this.masterPlaylistLoader_) {
          return;
        }
        var media = this.masterPlaylistLoader_.media();
        if (!media) {
          return;
        }
        var expired = this.syncController_.getExpiredTime(media, this.duration());
        if (expired === null) {
          return;
        }
        var master = this.masterPlaylistLoader_.master;
        var mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
        if (mainSeekable.length === 0) {
          return;
        }
        if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
          media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
          expired = this.syncController_.getExpiredTime(media, this.duration());
          if (expired === null) {
            return;
          }
          audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
          if (audioSeekable.length === 0) {
            return;
          }
        }
        var oldEnd;
        var oldStart;
        if (this.seekable_ && this.seekable_.length) {
          oldEnd = this.seekable_.end(0);
          oldStart = this.seekable_.start(0);
        }
        if (!audioSeekable) {
          this.seekable_ = mainSeekable;
        } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {
          this.seekable_ = mainSeekable;
        } else {
          this.seekable_ = videojs3.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);
        }
        if (this.seekable_ && this.seekable_.length) {
          if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {
            return;
          }
        }
        this.logger_("seekable updated [" + printableRange(this.seekable_) + "]");
        this.tech_.trigger("seekablechanged");
      };
      _proto.updateDuration = function updateDuration(isLive) {
        if (this.updateDuration_) {
          this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
          this.updateDuration_ = null;
        }
        if (this.mediaSource.readyState !== "open") {
          this.updateDuration_ = this.updateDuration.bind(this, isLive);
          this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
          return;
        }
        if (isLive) {
          var seekable2 = this.seekable();
          if (!seekable2.length) {
            return;
          }
          if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable2.end(seekable2.length - 1)) {
            this.sourceUpdater_.setDuration(seekable2.end(seekable2.length - 1));
          }
          return;
        }
        var buffered = this.tech_.buffered();
        var duration2 = Vhs$1.Playlist.duration(this.masterPlaylistLoader_.media());
        if (buffered.length > 0) {
          duration2 = Math.max(duration2, buffered.end(buffered.length - 1));
        }
        if (this.mediaSource.duration !== duration2) {
          this.sourceUpdater_.setDuration(duration2);
        }
      };
      _proto.dispose = function dispose() {
        var _this8 = this;
        this.trigger("dispose");
        this.decrypter_.terminate();
        this.masterPlaylistLoader_.dispose();
        this.mainSegmentLoader_.dispose();
        if (this.loadOnPlay_) {
          this.tech_.off("play", this.loadOnPlay_);
        }
        ["AUDIO", "SUBTITLES"].forEach(function(type) {
          var groups = _this8.mediaTypes_[type].groups;
          for (var id in groups) {
            groups[id].forEach(function(group) {
              if (group.playlistLoader) {
                group.playlistLoader.dispose();
              }
            });
          }
        });
        this.audioSegmentLoader_.dispose();
        this.subtitleSegmentLoader_.dispose();
        this.sourceUpdater_.dispose();
        this.timelineChangeController_.dispose();
        this.stopABRTimer_();
        if (this.updateDuration_) {
          this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
        }
        this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
        this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
        this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
        this.off();
      };
      _proto.master = function master() {
        return this.masterPlaylistLoader_.master;
      };
      _proto.media = function media() {
        return this.masterPlaylistLoader_.media() || this.initialMedia_;
      };
      _proto.areMediaTypesKnown_ = function areMediaTypesKnown_() {
        var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
        var hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
        var hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
        if (!hasMainMediaInfo || !hasAudioMediaInfo) {
          return false;
        }
        return true;
      };
      _proto.getCodecsOrExclude_ = function getCodecsOrExclude_() {
        var _this9 = this;
        var media = {
          main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
          audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
        };
        var playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
        media.video = media.main;
        var playlistCodecs = codecsForPlaylist(this.master(), playlist);
        var codecs = {};
        var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
        if (media.main.hasVideo) {
          codecs.video = playlistCodecs.video || media.main.videoCodec || codecs_js.DEFAULT_VIDEO_CODEC;
        }
        if (media.main.isMuxed) {
          codecs.video += "," + (playlistCodecs.audio || media.main.audioCodec || codecs_js.DEFAULT_AUDIO_CODEC);
        }
        if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
          codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || codecs_js.DEFAULT_AUDIO_CODEC;
          media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
        }
        if (!codecs.audio && !codecs.video) {
          this.blacklistCurrentPlaylist({
            playlist,
            message: "Could not determine codecs for playlist.",
            blacklistDuration: Infinity
          });
          return;
        }
        var supportFunction = function supportFunction2(isFmp4, codec) {
          return isFmp4 ? codecs_js.browserSupportsCodec(codec) : codecs_js.muxerSupportsCodec(codec);
        };
        var unsupportedCodecs = {};
        var unsupportedAudio;
        ["video", "audio"].forEach(function(type) {
          if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {
            var supporter = media[type].isFmp4 ? "browser" : "muxer";
            unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
            unsupportedCodecs[supporter].push(codecs[type]);
            if (type === "audio") {
              unsupportedAudio = supporter;
            }
          }
        });
        if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {
          var audioGroup = playlist.attributes.AUDIO;
          this.master().playlists.forEach(function(variant) {
            var variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
            if (variantAudioGroup === audioGroup && variant !== playlist) {
              variant.excludeUntil = Infinity;
            }
          });
          this.logger_("excluding audio group " + audioGroup + " as " + unsupportedAudio + ' does not support codec(s): "' + codecs.audio + '"');
        }
        if (Object.keys(unsupportedCodecs).length) {
          var message = Object.keys(unsupportedCodecs).reduce(function(acc, supporter) {
            if (acc) {
              acc += ", ";
            }
            acc += supporter + ' does not support codec(s): "' + unsupportedCodecs[supporter].join(",") + '"';
            return acc;
          }, "") + ".";
          this.blacklistCurrentPlaylist({
            playlist,
            internal: true,
            message,
            blacklistDuration: Infinity
          });
          return;
        }
        if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
          var switchMessages = [];
          ["video", "audio"].forEach(function(type) {
            var newCodec = (codecs_js.parseCodecs(_this9.sourceUpdater_.codecs[type] || "")[0] || {}).type;
            var oldCodec = (codecs_js.parseCodecs(codecs[type] || "")[0] || {}).type;
            if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {
              switchMessages.push('"' + _this9.sourceUpdater_.codecs[type] + '" -> "' + codecs[type] + '"');
            }
          });
          if (switchMessages.length) {
            this.blacklistCurrentPlaylist({
              playlist,
              message: "Codec switching not supported: " + switchMessages.join(", ") + ".",
              blacklistDuration: Infinity,
              internal: true
            });
            return;
          }
        }
        return codecs;
      };
      _proto.tryToCreateSourceBuffers_ = function tryToCreateSourceBuffers_() {
        if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) {
          return;
        }
        if (!this.areMediaTypesKnown_()) {
          return;
        }
        var codecs = this.getCodecsOrExclude_();
        if (!codecs) {
          return;
        }
        this.sourceUpdater_.createSourceBuffers(codecs);
        var codecString = [codecs.video, codecs.audio].filter(Boolean).join(",");
        this.excludeIncompatibleVariants_(codecString);
      };
      _proto.excludeUnsupportedVariants_ = function excludeUnsupportedVariants_() {
        var _this10 = this;
        var playlists = this.master().playlists;
        var ids = [];
        Object.keys(playlists).forEach(function(key) {
          var variant = playlists[key];
          if (ids.indexOf(variant.id) !== -1) {
            return;
          }
          ids.push(variant.id);
          var codecs = codecsForPlaylist(_this10.master, variant);
          var unsupported = [];
          if (codecs.audio && !codecs_js.muxerSupportsCodec(codecs.audio) && !codecs_js.browserSupportsCodec(codecs.audio)) {
            unsupported.push("audio codec " + codecs.audio);
          }
          if (codecs.video && !codecs_js.muxerSupportsCodec(codecs.video) && !codecs_js.browserSupportsCodec(codecs.video)) {
            unsupported.push("video codec " + codecs.video);
          }
          if (codecs.text && codecs.text === "stpp.ttml.im1t") {
            unsupported.push("text codec " + codecs.text);
          }
          if (unsupported.length) {
            variant.excludeUntil = Infinity;
            _this10.logger_("excluding " + variant.id + " for unsupported: " + unsupported.join(", "));
          }
        });
      };
      _proto.excludeIncompatibleVariants_ = function excludeIncompatibleVariants_(codecString) {
        var _this11 = this;
        var ids = [];
        var playlists = this.master().playlists;
        var codecs = unwrapCodecList(codecs_js.parseCodecs(codecString));
        var codecCount_ = codecCount(codecs);
        var videoDetails = codecs.video && codecs_js.parseCodecs(codecs.video)[0] || null;
        var audioDetails = codecs.audio && codecs_js.parseCodecs(codecs.audio)[0] || null;
        Object.keys(playlists).forEach(function(key) {
          var variant = playlists[key];
          if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {
            return;
          }
          ids.push(variant.id);
          var blacklistReasons = [];
          var variantCodecs = codecsForPlaylist(_this11.masterPlaylistLoader_.master, variant);
          var variantCodecCount = codecCount(variantCodecs);
          if (!variantCodecs.audio && !variantCodecs.video) {
            return;
          }
          if (variantCodecCount !== codecCount_) {
            blacklistReasons.push('codec count "' + variantCodecCount + '" !== "' + codecCount_ + '"');
          }
          if (!_this11.sourceUpdater_.canChangeType()) {
            var variantVideoDetails = variantCodecs.video && codecs_js.parseCodecs(variantCodecs.video)[0] || null;
            var variantAudioDetails = variantCodecs.audio && codecs_js.parseCodecs(variantCodecs.audio)[0] || null;
            if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {
              blacklistReasons.push('video codec "' + variantVideoDetails.type + '" !== "' + videoDetails.type + '"');
            }
            if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {
              blacklistReasons.push('audio codec "' + variantAudioDetails.type + '" !== "' + audioDetails.type + '"');
            }
          }
          if (blacklistReasons.length) {
            variant.excludeUntil = Infinity;
            _this11.logger_("blacklisting " + variant.id + ": " + blacklistReasons.join(" && "));
          }
        });
      };
      _proto.updateAdCues_ = function updateAdCues_(media) {
        var offset = 0;
        var seekable2 = this.seekable();
        if (seekable2.length) {
          offset = seekable2.start(0);
        }
        updateAdCues(media, this.cueTagsTrack_, offset);
      };
      _proto.goalBufferLength = function goalBufferLength() {
        var currentTime = this.tech_.currentTime();
        var initial = Config.GOAL_BUFFER_LENGTH;
        var rate = Config.GOAL_BUFFER_LENGTH_RATE;
        var max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
        return Math.min(initial + currentTime * rate, max);
      };
      _proto.bufferLowWaterLine = function bufferLowWaterLine() {
        var currentTime = this.tech_.currentTime();
        var initial = Config.BUFFER_LOW_WATER_LINE;
        var rate = Config.BUFFER_LOW_WATER_LINE_RATE;
        var max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
        var newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
        return Math.min(initial + currentTime * rate, this.experimentalBufferBasedABR ? newMax : max);
      };
      _proto.bufferHighWaterLine = function bufferHighWaterLine() {
        return Config.BUFFER_HIGH_WATER_LINE;
      };
      return MasterPlaylistController2;
    }(videojs3.EventTarget);
    var enableFunction = function enableFunction2(loader, playlistID, changePlaylistFn) {
      return function(enable) {
        var playlist = loader.master.playlists[playlistID];
        var incompatible = isIncompatible(playlist);
        var currentlyEnabled = isEnabled(playlist);
        if (typeof enable === "undefined") {
          return currentlyEnabled;
        }
        if (enable) {
          delete playlist.disabled;
        } else {
          playlist.disabled = true;
        }
        if (enable !== currentlyEnabled && !incompatible) {
          changePlaylistFn();
          if (enable) {
            loader.trigger("renditionenabled");
          } else {
            loader.trigger("renditiondisabled");
          }
        }
        return enable;
      };
    };
    var Representation = function Representation2(vhsHandler, playlist, id) {
      var mpc = vhsHandler.masterPlaylistController_, smoothQualityChange = vhsHandler.options_.smoothQualityChange;
      var changeType = smoothQualityChange ? "smooth" : "fast";
      var qualityChangeFunction = mpc[changeType + "QualityChange_"].bind(mpc);
      if (playlist.attributes) {
        var resolution = playlist.attributes.RESOLUTION;
        this.width = resolution && resolution.width;
        this.height = resolution && resolution.height;
        this.bandwidth = playlist.attributes.BANDWIDTH;
        this.frameRate = playlist.attributes["FRAME-RATE"];
      }
      this.codecs = codecsForPlaylist(mpc.master(), playlist);
      this.playlist = playlist;
      this.id = id;
      this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
    };
    var renditionSelectionMixin = function renditionSelectionMixin2(vhsHandler) {
      vhsHandler.representations = function() {
        var master = vhsHandler.masterPlaylistController_.master();
        var playlists = isAudioOnly(master) ? vhsHandler.masterPlaylistController_.getAudioTrackPlaylists_() : master.playlists;
        if (!playlists) {
          return [];
        }
        return playlists.filter(function(media) {
          return !isIncompatible(media);
        }).map(function(e, i2) {
          return new Representation(vhsHandler, e, e.id);
        });
      };
    };
    var timerCancelEvents = ["seeking", "seeked", "pause", "playing", "error"];
    var PlaybackWatcher = /* @__PURE__ */ function() {
      function PlaybackWatcher2(options) {
        var _this = this;
        this.masterPlaylistController_ = options.masterPlaylistController;
        this.tech_ = options.tech;
        this.seekable = options.seekable;
        this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
        this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
        this.media = options.media;
        this.consecutiveUpdates = 0;
        this.lastRecordedTime = null;
        this.timer_ = null;
        this.checkCurrentTimeTimeout_ = null;
        this.logger_ = logger("PlaybackWatcher");
        this.logger_("initialize");
        var playHandler = function playHandler2() {
          return _this.monitorCurrentTime_();
        };
        var canPlayHandler = function canPlayHandler2() {
          return _this.monitorCurrentTime_();
        };
        var waitingHandler = function waitingHandler2() {
          return _this.techWaiting_();
        };
        var cancelTimerHandler = function cancelTimerHandler2() {
          return _this.cancelTimer_();
        };
        var mpc = this.masterPlaylistController_;
        var loaderTypes = ["main", "subtitle", "audio"];
        var loaderChecks = {};
        loaderTypes.forEach(function(type) {
          loaderChecks[type] = {
            reset: function reset2() {
              return _this.resetSegmentDownloads_(type);
            },
            updateend: function updateend() {
              return _this.checkSegmentDownloads_(type);
            }
          };
          mpc[type + "SegmentLoader_"].on("appendsdone", loaderChecks[type].updateend);
          mpc[type + "SegmentLoader_"].on("playlistupdate", loaderChecks[type].reset);
          _this.tech_.on(["seeked", "seeking"], loaderChecks[type].reset);
        });
        var setSeekingHandlers = function setSeekingHandlers2(fn) {
          ["main", "audio"].forEach(function(type) {
            mpc[type + "SegmentLoader_"][fn]("appended", _this.seekingAppendCheck_);
          });
        };
        this.seekingAppendCheck_ = function() {
          if (_this.fixesBadSeeks_()) {
            _this.consecutiveUpdates = 0;
            _this.lastRecordedTime = _this.tech_.currentTime();
            setSeekingHandlers("off");
          }
        };
        this.clearSeekingAppendCheck_ = function() {
          return setSeekingHandlers("off");
        };
        this.watchForBadSeeking_ = function() {
          _this.clearSeekingAppendCheck_();
          setSeekingHandlers("on");
        };
        this.tech_.on("seeked", this.clearSeekingAppendCheck_);
        this.tech_.on("seeking", this.watchForBadSeeking_);
        this.tech_.on("waiting", waitingHandler);
        this.tech_.on(timerCancelEvents, cancelTimerHandler);
        this.tech_.on("canplay", canPlayHandler);
        this.tech_.one("play", playHandler);
        this.dispose = function() {
          _this.clearSeekingAppendCheck_();
          _this.logger_("dispose");
          _this.tech_.off("waiting", waitingHandler);
          _this.tech_.off(timerCancelEvents, cancelTimerHandler);
          _this.tech_.off("canplay", canPlayHandler);
          _this.tech_.off("play", playHandler);
          _this.tech_.off("seeking", _this.watchForBadSeeking_);
          _this.tech_.off("seeked", _this.clearSeekingAppendCheck_);
          loaderTypes.forEach(function(type) {
            mpc[type + "SegmentLoader_"].off("appendsdone", loaderChecks[type].updateend);
            mpc[type + "SegmentLoader_"].off("playlistupdate", loaderChecks[type].reset);
            _this.tech_.off(["seeked", "seeking"], loaderChecks[type].reset);
          });
          if (_this.checkCurrentTimeTimeout_) {
            window__default["default"].clearTimeout(_this.checkCurrentTimeTimeout_);
          }
          _this.cancelTimer_();
        };
      }
      var _proto = PlaybackWatcher2.prototype;
      _proto.monitorCurrentTime_ = function monitorCurrentTime_() {
        this.checkCurrentTime_();
        if (this.checkCurrentTimeTimeout_) {
          window__default["default"].clearTimeout(this.checkCurrentTimeTimeout_);
        }
        this.checkCurrentTimeTimeout_ = window__default["default"].setTimeout(this.monitorCurrentTime_.bind(this), 250);
      };
      _proto.resetSegmentDownloads_ = function resetSegmentDownloads_(type) {
        var loader = this.masterPlaylistController_[type + "SegmentLoader_"];
        if (this[type + "StalledDownloads_"] > 0) {
          this.logger_("resetting possible stalled download count for " + type + " loader");
        }
        this[type + "StalledDownloads_"] = 0;
        this[type + "Buffered_"] = loader.buffered_();
      };
      _proto.checkSegmentDownloads_ = function checkSegmentDownloads_(type) {
        var mpc = this.masterPlaylistController_;
        var loader = mpc[type + "SegmentLoader_"];
        var buffered = loader.buffered_();
        var isBufferedDifferent = isRangeDifferent(this[type + "Buffered_"], buffered);
        this[type + "Buffered_"] = buffered;
        if (isBufferedDifferent) {
          this.resetSegmentDownloads_(type);
          return;
        }
        this[type + "StalledDownloads_"]++;
        this.logger_("found #" + this[type + "StalledDownloads_"] + " " + type + " appends that did not increase buffer (possible stalled download)", {
          playlistId: loader.playlist_ && loader.playlist_.id,
          buffered: timeRangesToArray(buffered)
        });
        if (this[type + "StalledDownloads_"] < 10) {
          return;
        }
        this.logger_(type + " loader stalled download exclusion");
        this.resetSegmentDownloads_(type);
        this.tech_.trigger({
          type: "usage",
          name: "vhs-" + type + "-download-exclusion"
        });
        if (type === "subtitle") {
          return;
        }
        mpc.blacklistCurrentPlaylist({
          message: "Excessive " + type + " segment downloading detected."
        }, Infinity);
      };
      _proto.checkCurrentTime_ = function checkCurrentTime_() {
        if (this.tech_.paused() || this.tech_.seeking()) {
          return;
        }
        var currentTime = this.tech_.currentTime();
        var buffered = this.tech_.buffered();
        if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {
          return this.techWaiting_();
        }
        if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
          this.consecutiveUpdates++;
          this.waiting_();
        } else if (currentTime === this.lastRecordedTime) {
          this.consecutiveUpdates++;
        } else {
          this.consecutiveUpdates = 0;
          this.lastRecordedTime = currentTime;
        }
      };
      _proto.cancelTimer_ = function cancelTimer_() {
        this.consecutiveUpdates = 0;
        if (this.timer_) {
          this.logger_("cancelTimer_");
          clearTimeout(this.timer_);
        }
        this.timer_ = null;
      };
      _proto.fixesBadSeeks_ = function fixesBadSeeks_() {
        var seeking = this.tech_.seeking();
        if (!seeking) {
          return false;
        }
        var seekable2 = this.seekable();
        var currentTime = this.tech_.currentTime();
        var isAfterSeekableRange = this.afterSeekableWindow_(seekable2, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
        var seekTo;
        if (isAfterSeekableRange) {
          var seekableEnd = seekable2.end(seekable2.length - 1);
          seekTo = seekableEnd;
        }
        if (this.beforeSeekableWindow_(seekable2, currentTime)) {
          var seekableStart = seekable2.start(0);
          seekTo = seekableStart + (seekableStart === seekable2.end(0) ? 0 : SAFE_TIME_DELTA);
        }
        if (typeof seekTo !== "undefined") {
          this.logger_("Trying to seek outside of seekable at time " + currentTime + " with " + ("seekable range " + printableRange(seekable2) + ". Seeking to ") + (seekTo + "."));
          this.tech_.setCurrentTime(seekTo);
          return true;
        }
        var sourceUpdater = this.masterPlaylistController_.sourceUpdater_;
        var buffered = this.tech_.buffered();
        var audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
        var videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
        var media = this.media();
        var minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
        var bufferedToCheck = [audioBuffered, videoBuffered];
        for (var i2 = 0; i2 < bufferedToCheck.length; i2++) {
          if (!bufferedToCheck[i2]) {
            continue;
          }
          var timeAhead = timeAheadOf(bufferedToCheck[i2], currentTime);
          if (timeAhead < minAppendedDuration) {
            return false;
          }
        }
        var nextRange = findNextRange(buffered, currentTime);
        if (nextRange.length === 0) {
          return false;
        }
        seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
        this.logger_("Buffered region starts (" + nextRange.start(0) + ") " + (" just beyond seek point (" + currentTime + "). Seeking to " + seekTo + "."));
        this.tech_.setCurrentTime(seekTo);
        return true;
      };
      _proto.waiting_ = function waiting_() {
        if (this.techWaiting_()) {
          return;
        }
        var currentTime = this.tech_.currentTime();
        var buffered = this.tech_.buffered();
        var currentRange = findRange(buffered, currentTime);
        if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
          this.cancelTimer_();
          this.tech_.setCurrentTime(currentTime);
          this.logger_("Stopped at " + currentTime + " while inside a buffered region " + ("[" + currentRange.start(0) + " -> " + currentRange.end(0) + "]. Attempting to resume ") + "playback by seeking to the current time.");
          this.tech_.trigger({
            type: "usage",
            name: "vhs-unknown-waiting"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-unknown-waiting"
          });
          return;
        }
      };
      _proto.techWaiting_ = function techWaiting_() {
        var seekable2 = this.seekable();
        var currentTime = this.tech_.currentTime();
        if (this.tech_.seeking() || this.timer_ !== null) {
          return true;
        }
        if (this.beforeSeekableWindow_(seekable2, currentTime)) {
          var livePoint = seekable2.end(seekable2.length - 1);
          this.logger_("Fell out of live window at time " + currentTime + ". Seeking to " + ("live point (seekable end) " + livePoint));
          this.cancelTimer_();
          this.tech_.setCurrentTime(livePoint);
          this.tech_.trigger({
            type: "usage",
            name: "vhs-live-resync"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-live-resync"
          });
          return true;
        }
        var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_;
        var buffered = this.tech_.buffered();
        var videoUnderflow = this.videoUnderflow_({
          audioBuffered: sourceUpdater.audioBuffered(),
          videoBuffered: sourceUpdater.videoBuffered(),
          currentTime
        });
        if (videoUnderflow) {
          this.cancelTimer_();
          this.tech_.setCurrentTime(currentTime);
          this.tech_.trigger({
            type: "usage",
            name: "vhs-video-underflow"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-video-underflow"
          });
          return true;
        }
        var nextRange = findNextRange(buffered, currentTime);
        if (nextRange.length > 0) {
          var difference = nextRange.start(0) - currentTime;
          this.logger_("Stopped at " + currentTime + ", setting timer for " + difference + ", seeking " + ("to " + nextRange.start(0)));
          this.cancelTimer_();
          this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1e3, currentTime);
          return true;
        }
        return false;
      };
      _proto.afterSeekableWindow_ = function afterSeekableWindow_(seekable2, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {
        if (allowSeeksWithinUnsafeLiveWindow === void 0) {
          allowSeeksWithinUnsafeLiveWindow = false;
        }
        if (!seekable2.length) {
          return false;
        }
        var allowedEnd = seekable2.end(seekable2.length - 1) + SAFE_TIME_DELTA;
        var isLive = !playlist.endList;
        if (isLive && allowSeeksWithinUnsafeLiveWindow) {
          allowedEnd = seekable2.end(seekable2.length - 1) + playlist.targetDuration * 3;
        }
        if (currentTime > allowedEnd) {
          return true;
        }
        return false;
      };
      _proto.beforeSeekableWindow_ = function beforeSeekableWindow_(seekable2, currentTime) {
        if (seekable2.length && seekable2.start(0) > 0 && currentTime < seekable2.start(0) - this.liveRangeSafeTimeDelta) {
          return true;
        }
        return false;
      };
      _proto.videoUnderflow_ = function videoUnderflow_(_ref) {
        var videoBuffered = _ref.videoBuffered, audioBuffered = _ref.audioBuffered, currentTime = _ref.currentTime;
        if (!videoBuffered) {
          return;
        }
        var gap;
        if (videoBuffered.length && audioBuffered.length) {
          var lastVideoRange = findRange(videoBuffered, currentTime - 3);
          var videoRange = findRange(videoBuffered, currentTime);
          var audioRange = findRange(audioBuffered, currentTime);
          if (audioRange.length && !videoRange.length && lastVideoRange.length) {
            gap = {
              start: lastVideoRange.end(0),
              end: audioRange.end(0)
            };
          }
        } else {
          var nextRange = findNextRange(videoBuffered, currentTime);
          if (!nextRange.length) {
            gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
          }
        }
        if (gap) {
          this.logger_("Encountered a gap in video from " + gap.start + " to " + gap.end + ". " + ("Seeking to current time " + currentTime));
          return true;
        }
        return false;
      };
      _proto.skipTheGap_ = function skipTheGap_(scheduledCurrentTime) {
        var buffered = this.tech_.buffered();
        var currentTime = this.tech_.currentTime();
        var nextRange = findNextRange(buffered, currentTime);
        this.cancelTimer_();
        if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {
          return;
        }
        this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
        this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
        this.tech_.trigger({
          type: "usage",
          name: "vhs-gap-skip"
        });
        this.tech_.trigger({
          type: "usage",
          name: "hls-gap-skip"
        });
      };
      _proto.gapFromVideoUnderflow_ = function gapFromVideoUnderflow_(buffered, currentTime) {
        var gaps = findGaps(buffered);
        for (var i2 = 0; i2 < gaps.length; i2++) {
          var start2 = gaps.start(i2);
          var end2 = gaps.end(i2);
          if (currentTime - start2 < 4 && currentTime - start2 > 2) {
            return {
              start: start2,
              end: end2
            };
          }
        }
        return null;
      };
      return PlaybackWatcher2;
    }();
    var defaultOptions = {
      errorInterval: 30,
      getSource: function getSource(next) {
        var tech = this.tech({
          IWillNotUseThisInPlugins: true
        });
        var sourceObj = tech.currentSource_ || this.currentSource();
        return next(sourceObj);
      }
    };
    var initPlugin = function initPlugin2(player, options) {
      var lastCalled = 0;
      var seekTo = 0;
      var localOptions = videojs3.mergeOptions(defaultOptions, options);
      player.ready(function() {
        player.trigger({
          type: "usage",
          name: "vhs-error-reload-initialized"
        });
        player.trigger({
          type: "usage",
          name: "hls-error-reload-initialized"
        });
      });
      var loadedMetadataHandler = function loadedMetadataHandler2() {
        if (seekTo) {
          player.currentTime(seekTo);
        }
      };
      var setSource2 = function setSource3(sourceObj) {
        if (sourceObj === null || sourceObj === void 0) {
          return;
        }
        seekTo = player.duration() !== Infinity && player.currentTime() || 0;
        player.one("loadedmetadata", loadedMetadataHandler);
        player.src(sourceObj);
        player.trigger({
          type: "usage",
          name: "vhs-error-reload"
        });
        player.trigger({
          type: "usage",
          name: "hls-error-reload"
        });
        player.play();
      };
      var errorHandler = function errorHandler2() {
        if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
          player.trigger({
            type: "usage",
            name: "vhs-error-reload-canceled"
          });
          player.trigger({
            type: "usage",
            name: "hls-error-reload-canceled"
          });
          return;
        }
        if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
          videojs3.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
          return;
        }
        lastCalled = Date.now();
        return localOptions.getSource.call(player, setSource2);
      };
      var cleanupEvents = function cleanupEvents2() {
        player.off("loadedmetadata", loadedMetadataHandler);
        player.off("error", errorHandler);
        player.off("dispose", cleanupEvents2);
      };
      var reinitPlugin = function reinitPlugin2(newOptions) {
        cleanupEvents();
        initPlugin2(player, newOptions);
      };
      player.on("error", errorHandler);
      player.on("dispose", cleanupEvents);
      player.reloadSourceOnError = reinitPlugin;
    };
    var reloadSourceOnError = function reloadSourceOnError2(options) {
      initPlugin(this, options);
    };
    var version$4 = "2.16.3";
    var version$3 = "6.0.1";
    var version$2 = "0.22.1";
    var version$1 = "4.8.0";
    var version2 = "3.1.3";
    var Vhs = {
      PlaylistLoader,
      Playlist,
      utils,
      STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
      INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
      lastBandwidthSelector,
      movingAverageBandwidthSelector,
      comparePlaylistBandwidth,
      comparePlaylistResolution,
      xhr: xhrFactory()
    };
    Object.keys(Config).forEach(function(prop) {
      Object.defineProperty(Vhs, prop, {
        get: function get2() {
          videojs3.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
          return Config[prop];
        },
        set: function set2(value) {
          videojs3.log.warn("using Vhs." + prop + " is UNSAFE be sure you know what you are doing");
          if (typeof value !== "number" || value < 0) {
            videojs3.log.warn("value of Vhs." + prop + " must be greater than or equal to 0");
            return;
          }
          Config[prop] = value;
        }
      });
    });
    var LOCAL_STORAGE_KEY = "videojs-vhs";
    var handleVhsMediaChange = function handleVhsMediaChange2(qualityLevels, playlistLoader) {
      var newPlaylist = playlistLoader.media();
      var selectedIndex = -1;
      for (var i2 = 0; i2 < qualityLevels.length; i2++) {
        if (qualityLevels[i2].id === newPlaylist.id) {
          selectedIndex = i2;
          break;
        }
      }
      qualityLevels.selectedIndex_ = selectedIndex;
      qualityLevels.trigger({
        selectedIndex,
        type: "change"
      });
    };
    var handleVhsLoadedMetadata = function handleVhsLoadedMetadata2(qualityLevels, vhs) {
      vhs.representations().forEach(function(rep) {
        qualityLevels.addQualityLevel(rep);
      });
      handleVhsMediaChange(qualityLevels, vhs.playlists);
    };
    Vhs.canPlaySource = function() {
      return videojs3.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
    };
    var emeKeySystems = function emeKeySystems2(keySystemOptions, mainPlaylist, audioPlaylist) {
      if (!keySystemOptions) {
        return keySystemOptions;
      }
      var codecs = {};
      if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {
        codecs = unwrapCodecList(codecs_js.parseCodecs(mainPlaylist.attributes.CODECS));
      }
      if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {
        codecs.audio = audioPlaylist.attributes.CODECS;
      }
      var videoContentType = codecs_js.getMimeForCodec(codecs.video);
      var audioContentType = codecs_js.getMimeForCodec(codecs.audio);
      var keySystemContentTypes = {};
      for (var keySystem in keySystemOptions) {
        keySystemContentTypes[keySystem] = {};
        if (audioContentType) {
          keySystemContentTypes[keySystem].audioContentType = audioContentType;
        }
        if (videoContentType) {
          keySystemContentTypes[keySystem].videoContentType = videoContentType;
        }
        if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {
          keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
        }
        if (typeof keySystemOptions[keySystem] === "string") {
          keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
        }
      }
      return videojs3.mergeOptions(keySystemOptions, keySystemContentTypes);
    };
    var getAllPsshKeySystemsOptions = function getAllPsshKeySystemsOptions2(playlists, keySystems) {
      return playlists.reduce(function(keySystemsArr, playlist) {
        if (!playlist.contentProtection) {
          return keySystemsArr;
        }
        var keySystemsOptions = keySystems.reduce(function(keySystemsObj, keySystem) {
          var keySystemOptions = playlist.contentProtection[keySystem];
          if (keySystemOptions && keySystemOptions.pssh) {
            keySystemsObj[keySystem] = {
              pssh: keySystemOptions.pssh
            };
          }
          return keySystemsObj;
        }, {});
        if (Object.keys(keySystemsOptions).length) {
          keySystemsArr.push(keySystemsOptions);
        }
        return keySystemsArr;
      }, []);
    };
    var waitForKeySessionCreation = function waitForKeySessionCreation2(_ref) {
      var player = _ref.player, sourceKeySystems = _ref.sourceKeySystems, audioMedia = _ref.audioMedia, mainPlaylists = _ref.mainPlaylists;
      if (!player.eme.initializeMediaKeys) {
        return Promise.resolve();
      }
      var playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;
      var keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
      var initializationFinishedPromises = [];
      var keySessionCreatedPromises = [];
      keySystemsOptionsArr.forEach(function(keySystemsOptions) {
        keySessionCreatedPromises.push(new Promise(function(resolve, reject) {
          player.tech_.one("keysessioncreated", resolve);
        }));
        initializationFinishedPromises.push(new Promise(function(resolve, reject) {
          player.eme.initializeMediaKeys({
            keySystems: keySystemsOptions
          }, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve();
          });
        }));
      });
      return Promise.race([
        Promise.all(initializationFinishedPromises),
        Promise.race(keySessionCreatedPromises)
      ]);
    };
    var setupEmeOptions = function setupEmeOptions2(_ref2) {
      var player = _ref2.player, sourceKeySystems = _ref2.sourceKeySystems, media = _ref2.media, audioMedia = _ref2.audioMedia;
      var sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
      if (!sourceOptions) {
        return false;
      }
      player.currentSource().keySystems = sourceOptions;
      if (sourceOptions && !player.eme) {
        videojs3.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
        return false;
      }
      return true;
    };
    var getVhsLocalStorage = function getVhsLocalStorage2() {
      if (!window__default["default"].localStorage) {
        return null;
      }
      var storedObject = window__default["default"].localStorage.getItem(LOCAL_STORAGE_KEY);
      if (!storedObject) {
        return null;
      }
      try {
        return JSON.parse(storedObject);
      } catch (e) {
        return null;
      }
    };
    var updateVhsLocalStorage = function updateVhsLocalStorage2(options) {
      if (!window__default["default"].localStorage) {
        return false;
      }
      var objectToStore = getVhsLocalStorage();
      objectToStore = objectToStore ? videojs3.mergeOptions(objectToStore, options) : options;
      try {
        window__default["default"].localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
      } catch (e) {
        return false;
      }
      return objectToStore;
    };
    var expandDataUri = function expandDataUri2(dataUri) {
      if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) {
        return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
      }
      return dataUri;
    };
    Vhs.supportsNativeHls = function() {
      if (!document__default["default"] || !document__default["default"].createElement) {
        return false;
      }
      var video = document__default["default"].createElement("video");
      if (!videojs3.getTech("Html5").isSupported()) {
        return false;
      }
      var canPlay = [
        "application/vnd.apple.mpegurl",
        "audio/mpegurl",
        "audio/x-mpegurl",
        "application/x-mpegurl",
        "video/x-mpegurl",
        "video/mpegurl",
        "application/mpegurl"
      ];
      return canPlay.some(function(canItPlay) {
        return /maybe|probably/i.test(video.canPlayType(canItPlay));
      });
    }();
    Vhs.supportsNativeDash = function() {
      if (!document__default["default"] || !document__default["default"].createElement || !videojs3.getTech("Html5").isSupported()) {
        return false;
      }
      return /maybe|probably/i.test(document__default["default"].createElement("video").canPlayType("application/dash+xml"));
    }();
    Vhs.supportsTypeNatively = function(type) {
      if (type === "hls") {
        return Vhs.supportsNativeHls;
      }
      if (type === "dash") {
        return Vhs.supportsNativeDash;
      }
      return false;
    };
    Vhs.isSupported = function() {
      return videojs3.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
    };
    var Component = videojs3.getComponent("Component");
    var VhsHandler = /* @__PURE__ */ function(_Component) {
      _inheritsLoose__default["default"](VhsHandler2, _Component);
      function VhsHandler2(source, tech, options) {
        var _this;
        _this = _Component.call(this, tech, videojs3.mergeOptions(options.hls, options.vhs)) || this;
        if (options.hls && Object.keys(options.hls).length) {
          videojs3.log.warn("Using hls options is deprecated. Please rename `hls` to `vhs` in your options object.");
        }
        if (typeof options.initialBandwidth === "number") {
          _this.options_.bandwidth = options.initialBandwidth;
        }
        _this.logger_ = logger("VhsHandler");
        if (tech.options_ && tech.options_.playerId) {
          var _player = videojs3(tech.options_.playerId);
          if (!_player.hasOwnProperty("hls")) {
            Object.defineProperty(_player, "hls", {
              get: function get2() {
                videojs3.log.warn("player.hls is deprecated. Use player.tech().vhs instead.");
                tech.trigger({
                  type: "usage",
                  name: "hls-player-access"
                });
                return _assertThisInitialized__default["default"](_this);
              },
              configurable: true
            });
          }
          if (!_player.hasOwnProperty("vhs")) {
            Object.defineProperty(_player, "vhs", {
              get: function get2() {
                videojs3.log.warn("player.vhs is deprecated. Use player.tech().vhs instead.");
                tech.trigger({
                  type: "usage",
                  name: "vhs-player-access"
                });
                return _assertThisInitialized__default["default"](_this);
              },
              configurable: true
            });
          }
          if (!_player.hasOwnProperty("dash")) {
            Object.defineProperty(_player, "dash", {
              get: function get2() {
                videojs3.log.warn("player.dash is deprecated. Use player.tech().vhs instead.");
                return _assertThisInitialized__default["default"](_this);
              },
              configurable: true
            });
          }
          _this.player_ = _player;
        }
        _this.tech_ = tech;
        _this.source_ = source;
        _this.stats = {};
        _this.ignoreNextSeekingEvent_ = false;
        _this.setOptions_();
        if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
          tech.overrideNativeAudioTracks(true);
          tech.overrideNativeVideoTracks(true);
        } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {
          throw new Error("Overriding native HLS requires emulated tracks. See https://git.io/vMpjB");
        }
        _this.on(document__default["default"], ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], function(event2) {
          var fullscreenElement = document__default["default"].fullscreenElement || document__default["default"].webkitFullscreenElement || document__default["default"].mozFullScreenElement || document__default["default"].msFullscreenElement;
          if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {
            _this.masterPlaylistController_.fastQualityChange_();
          } else {
            _this.masterPlaylistController_.checkABR_();
          }
        });
        _this.on(_this.tech_, "seeking", function() {
          if (this.ignoreNextSeekingEvent_) {
            this.ignoreNextSeekingEvent_ = false;
            return;
          }
          this.setCurrentTime(this.tech_.currentTime());
        });
        _this.on(_this.tech_, "error", function() {
          if (this.tech_.error() && this.masterPlaylistController_) {
            this.masterPlaylistController_.pauseLoading();
          }
        });
        _this.on(_this.tech_, "play", _this.play);
        return _this;
      }
      var _proto = VhsHandler2.prototype;
      _proto.setOptions_ = function setOptions_() {
        var _this2 = this;
        this.options_.withCredentials = this.options_.withCredentials || false;
        this.options_.handleManifestRedirects = this.options_.handleManifestRedirects === false ? false : true;
        this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
        this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
        this.options_.smoothQualityChange = this.options_.smoothQualityChange || false;
        this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
        this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
        this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
        this.options_.customTagParsers = this.options_.customTagParsers || [];
        this.options_.customTagMappers = this.options_.customTagMappers || [];
        this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
        if (typeof this.options_.blacklistDuration !== "number") {
          this.options_.blacklistDuration = 5 * 60;
        }
        if (typeof this.options_.bandwidth !== "number") {
          if (this.options_.useBandwidthFromLocalStorage) {
            var storedObject = getVhsLocalStorage();
            if (storedObject && storedObject.bandwidth) {
              this.options_.bandwidth = storedObject.bandwidth;
              this.tech_.trigger({
                type: "usage",
                name: "vhs-bandwidth-from-local-storage"
              });
              this.tech_.trigger({
                type: "usage",
                name: "hls-bandwidth-from-local-storage"
              });
            }
            if (storedObject && storedObject.throughput) {
              this.options_.throughput = storedObject.throughput;
              this.tech_.trigger({
                type: "usage",
                name: "vhs-throughput-from-local-storage"
              });
              this.tech_.trigger({
                type: "usage",
                name: "hls-throughput-from-local-storage"
              });
            }
          }
        }
        if (typeof this.options_.bandwidth !== "number") {
          this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
        }
        this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
        ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "smoothQualityChange", "customTagParsers", "customTagMappers", "handleManifestRedirects", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "experimentalBufferBasedABR", "liveRangeSafeTimeDelta", "experimentalLLHLS", "useNetworkInformationApi", "useDtsForTimestampOffset", "experimentalExactManifestTimings", "experimentalLeastPixelDiffSelector"].forEach(function(option) {
          if (typeof _this2.source_[option] !== "undefined") {
            _this2.options_[option] = _this2.source_[option];
          }
        });
        this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
        this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
      };
      _proto.src = function src(_src, type) {
        var _this3 = this;
        if (!_src) {
          return;
        }
        this.setOptions_();
        this.options_.src = expandDataUri(this.source_.src);
        this.options_.tech = this.tech_;
        this.options_.externVhs = Vhs;
        this.options_.sourceType = mediaTypes_js.simpleTypeFromSourceType(type);
        this.options_.seekTo = function(time) {
          _this3.tech_.setCurrentTime(time);
        };
        if (this.options_.smoothQualityChange) {
          videojs3.log.warn("smoothQualityChange is deprecated and will be removed in the next major version");
        }
        this.masterPlaylistController_ = new MasterPlaylistController(this.options_);
        var playbackWatcherOptions = videojs3.mergeOptions({
          liveRangeSafeTimeDelta: SAFE_TIME_DELTA
        }, this.options_, {
          seekable: function seekable2() {
            return _this3.seekable();
          },
          media: function media() {
            return _this3.masterPlaylistController_.media();
          },
          masterPlaylistController: this.masterPlaylistController_
        });
        this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
        this.masterPlaylistController_.on("error", function() {
          var player = videojs3.players[_this3.tech_.options_.playerId];
          var error = _this3.masterPlaylistController_.error;
          if (typeof error === "object" && !error.code) {
            error.code = 3;
          } else if (typeof error === "string") {
            error = {
              message: error,
              code: 3
            };
          }
          player.error(error);
        });
        var defaultSelector = this.options_.experimentalBufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
        this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
        this.masterPlaylistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
        this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;
        this.mediaSource = this.masterPlaylistController_.mediaSource;
        Object.defineProperties(this, {
          selectPlaylist: {
            get: function get2() {
              return this.masterPlaylistController_.selectPlaylist;
            },
            set: function set2(selectPlaylist) {
              this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);
            }
          },
          throughput: {
            get: function get2() {
              return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
            },
            set: function set2(throughput) {
              this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput;
              this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
            }
          },
          bandwidth: {
            get: function get2() {
              var playerBandwidthEst = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;
              var networkInformation = window__default["default"].navigator.connection || window__default["default"].navigator.mozConnection || window__default["default"].navigator.webkitConnection;
              var tenMbpsAsBitsPerSecond = 1e7;
              if (this.options_.useNetworkInformationApi && networkInformation) {
                var networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
                if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {
                  playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);
                } else {
                  playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
                }
              }
              return playerBandwidthEst;
            },
            set: function set2(bandwidth) {
              this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth;
              this.masterPlaylistController_.mainSegmentLoader_.throughput = {
                rate: 0,
                count: 0
              };
            }
          },
          systemBandwidth: {
            get: function get2() {
              var invBandwidth = 1 / (this.bandwidth || 1);
              var invThroughput;
              if (this.throughput > 0) {
                invThroughput = 1 / this.throughput;
              } else {
                invThroughput = 0;
              }
              var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
              return systemBitrate;
            },
            set: function set2() {
              videojs3.log.error('The "systemBandwidth" property is read-only');
            }
          }
        });
        if (this.options_.bandwidth) {
          this.bandwidth = this.options_.bandwidth;
        }
        if (this.options_.throughput) {
          this.throughput = this.options_.throughput;
        }
        Object.defineProperties(this.stats, {
          bandwidth: {
            get: function get2() {
              return _this3.bandwidth || 0;
            },
            enumerable: true
          },
          mediaRequests: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaRequests_() || 0;
            },
            enumerable: true
          },
          mediaRequestsAborted: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;
            },
            enumerable: true
          },
          mediaRequestsTimedout: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;
            },
            enumerable: true
          },
          mediaRequestsErrored: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;
            },
            enumerable: true
          },
          mediaTransferDuration: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;
            },
            enumerable: true
          },
          mediaBytesTransferred: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;
            },
            enumerable: true
          },
          mediaSecondsLoaded: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;
            },
            enumerable: true
          },
          mediaAppends: {
            get: function get2() {
              return _this3.masterPlaylistController_.mediaAppends_() || 0;
            },
            enumerable: true
          },
          mainAppendsToLoadedData: {
            get: function get2() {
              return _this3.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
            },
            enumerable: true
          },
          audioAppendsToLoadedData: {
            get: function get2() {
              return _this3.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
            },
            enumerable: true
          },
          appendsToLoadedData: {
            get: function get2() {
              return _this3.masterPlaylistController_.appendsToLoadedData_() || 0;
            },
            enumerable: true
          },
          timeToLoadedData: {
            get: function get2() {
              return _this3.masterPlaylistController_.timeToLoadedData_() || 0;
            },
            enumerable: true
          },
          buffered: {
            get: function get2() {
              return timeRangesToArray(_this3.tech_.buffered());
            },
            enumerable: true
          },
          currentTime: {
            get: function get2() {
              return _this3.tech_.currentTime();
            },
            enumerable: true
          },
          currentSource: {
            get: function get2() {
              return _this3.tech_.currentSource_;
            },
            enumerable: true
          },
          currentTech: {
            get: function get2() {
              return _this3.tech_.name_;
            },
            enumerable: true
          },
          duration: {
            get: function get2() {
              return _this3.tech_.duration();
            },
            enumerable: true
          },
          master: {
            get: function get2() {
              return _this3.playlists.master;
            },
            enumerable: true
          },
          playerDimensions: {
            get: function get2() {
              return _this3.tech_.currentDimensions();
            },
            enumerable: true
          },
          seekable: {
            get: function get2() {
              return timeRangesToArray(_this3.tech_.seekable());
            },
            enumerable: true
          },
          timestamp: {
            get: function get2() {
              return Date.now();
            },
            enumerable: true
          },
          videoPlaybackQuality: {
            get: function get2() {
              return _this3.tech_.getVideoPlaybackQuality();
            },
            enumerable: true
          }
        });
        this.tech_.one("canplay", this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));
        this.tech_.on("bandwidthupdate", function() {
          if (_this3.options_.useBandwidthFromLocalStorage) {
            updateVhsLocalStorage({
              bandwidth: _this3.bandwidth,
              throughput: Math.round(_this3.throughput)
            });
          }
        });
        this.masterPlaylistController_.on("selectedinitialmedia", function() {
          renditionSelectionMixin(_this3);
        });
        this.masterPlaylistController_.sourceUpdater_.on("createdsourcebuffers", function() {
          _this3.setupEme_();
        });
        this.on(this.masterPlaylistController_, "progress", function() {
          this.tech_.trigger("progress");
        });
        this.on(this.masterPlaylistController_, "firstplay", function() {
          this.ignoreNextSeekingEvent_ = true;
        });
        this.setupQualityLevels_();
        if (!this.tech_.el()) {
          return;
        }
        this.mediaSourceUrl_ = window__default["default"].URL.createObjectURL(this.masterPlaylistController_.mediaSource);
        this.tech_.src(this.mediaSourceUrl_);
      };
      _proto.createKeySessions_ = function createKeySessions_() {
        var _this4 = this;
        var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
        this.logger_("waiting for EME key session creation");
        waitForKeySessionCreation({
          player: this.player_,
          sourceKeySystems: this.source_.keySystems,
          audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
          mainPlaylists: this.playlists.master.playlists
        }).then(function() {
          _this4.logger_("created EME key session");
          _this4.masterPlaylistController_.sourceUpdater_.initializedEme();
        })["catch"](function(err) {
          _this4.logger_("error while creating EME key session", err);
          _this4.player_.error({
            message: "Failed to initialize media keys for EME",
            code: 3
          });
        });
      };
      _proto.handleWaitingForKey_ = function handleWaitingForKey_() {
        this.logger_("waitingforkey fired, attempting to create any new key sessions");
        this.createKeySessions_();
      };
      _proto.setupEme_ = function setupEme_() {
        var _this5 = this;
        var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
        var didSetupEmeOptions = setupEmeOptions({
          player: this.player_,
          sourceKeySystems: this.source_.keySystems,
          media: this.playlists.media(),
          audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
        });
        this.player_.tech_.on("keystatuschange", function(e) {
          if (e.status !== "output-restricted") {
            return;
          }
          var masterPlaylist = _this5.masterPlaylistController_.master();
          if (!masterPlaylist || !masterPlaylist.playlists) {
            return;
          }
          var excludedHDPlaylists = [];
          masterPlaylist.playlists.forEach(function(playlist) {
            if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) {
              if (!playlist.excludeUntil || playlist.excludeUntil < Infinity) {
                playlist.excludeUntil = Infinity;
                excludedHDPlaylists.push(playlist);
              }
            }
          });
          if (excludedHDPlaylists.length) {
            var _videojs$log;
            (_videojs$log = videojs3.log).warn.apply(_videojs$log, ['DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.'].concat(excludedHDPlaylists));
            _this5.masterPlaylistController_.fastQualityChange_();
          }
        });
        this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
        this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
        if (videojs3.browser.IE_VERSION === 11 || !didSetupEmeOptions) {
          this.masterPlaylistController_.sourceUpdater_.initializedEme();
          return;
        }
        this.createKeySessions_();
      };
      _proto.setupQualityLevels_ = function setupQualityLevels_() {
        var _this6 = this;
        var player = videojs3.players[this.tech_.options_.playerId];
        if (!player || !player.qualityLevels || this.qualityLevels_) {
          return;
        }
        this.qualityLevels_ = player.qualityLevels();
        this.masterPlaylistController_.on("selectedinitialmedia", function() {
          handleVhsLoadedMetadata(_this6.qualityLevels_, _this6);
        });
        this.playlists.on("mediachange", function() {
          handleVhsMediaChange(_this6.qualityLevels_, _this6.playlists);
        });
      };
      VhsHandler2.version = function version$52() {
        return {
          "@videojs/http-streaming": version$4,
          "mux.js": version$3,
          "mpd-parser": version$2,
          "m3u8-parser": version$1,
          "aes-decrypter": version2
        };
      };
      _proto.version = function version3() {
        return this.constructor.version();
      };
      _proto.canChangeType = function canChangeType() {
        return SourceUpdater.canChangeType();
      };
      _proto.play = function play() {
        this.masterPlaylistController_.play();
      };
      _proto.setCurrentTime = function setCurrentTime(currentTime) {
        this.masterPlaylistController_.setCurrentTime(currentTime);
      };
      _proto.duration = function duration2() {
        return this.masterPlaylistController_.duration();
      };
      _proto.seekable = function seekable2() {
        return this.masterPlaylistController_.seekable();
      };
      _proto.dispose = function dispose() {
        if (this.playbackWatcher_) {
          this.playbackWatcher_.dispose();
        }
        if (this.masterPlaylistController_) {
          this.masterPlaylistController_.dispose();
        }
        if (this.qualityLevels_) {
          this.qualityLevels_.dispose();
        }
        if (this.player_) {
          delete this.player_.vhs;
          delete this.player_.dash;
          delete this.player_.hls;
        }
        if (this.tech_ && this.tech_.vhs) {
          delete this.tech_.vhs;
        }
        if (this.tech_) {
          delete this.tech_.hls;
        }
        if (this.mediaSourceUrl_ && window__default["default"].URL.revokeObjectURL) {
          window__default["default"].URL.revokeObjectURL(this.mediaSourceUrl_);
          this.mediaSourceUrl_ = null;
        }
        if (this.tech_) {
          this.tech_.off("waitingforkey", this.handleWaitingForKey_);
        }
        _Component.prototype.dispose.call(this);
      };
      _proto.convertToProgramTime = function convertToProgramTime(time, callback) {
        return getProgramTime({
          playlist: this.masterPlaylistController_.media(),
          time,
          callback
        });
      };
      _proto.seekToProgramTime = function seekToProgramTime$1(programTime, callback, pauseAfterSeek, retryCount) {
        if (pauseAfterSeek === void 0) {
          pauseAfterSeek = true;
        }
        if (retryCount === void 0) {
          retryCount = 2;
        }
        return seekToProgramTime({
          programTime,
          playlist: this.masterPlaylistController_.media(),
          retryCount,
          pauseAfterSeek,
          seekTo: this.options_.seekTo,
          tech: this.options_.tech,
          callback
        });
      };
      return VhsHandler2;
    }(Component);
    var VhsSourceHandler = {
      name: "videojs-http-streaming",
      VERSION: version$4,
      canHandleSource: function canHandleSource(srcObj, options) {
        if (options === void 0) {
          options = {};
        }
        var localOptions = videojs3.mergeOptions(videojs3.options, options);
        return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
      },
      handleSource: function handleSource(source, tech, options) {
        if (options === void 0) {
          options = {};
        }
        var localOptions = videojs3.mergeOptions(videojs3.options, options);
        tech.vhs = new VhsHandler(source, tech, localOptions);
        if (!videojs3.hasOwnProperty("hls")) {
          Object.defineProperty(tech, "hls", {
            get: function get2() {
              videojs3.log.warn("player.tech().hls is deprecated. Use player.tech().vhs instead.");
              return tech.vhs;
            },
            configurable: true
          });
        }
        tech.vhs.xhr = xhrFactory();
        tech.vhs.src(source.src, source.type);
        return tech.vhs;
      },
      canPlayType: function canPlayType2(type, options) {
        var simpleType = mediaTypes_js.simpleTypeFromSourceType(type);
        if (!simpleType) {
          return "";
        }
        var overrideNative = VhsSourceHandler.getOverrideNative(options);
        var supportsTypeNatively = Vhs.supportsTypeNatively(simpleType);
        var canUseMsePlayback = !supportsTypeNatively || overrideNative;
        return canUseMsePlayback ? "maybe" : "";
      },
      getOverrideNative: function getOverrideNative(options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$vhs = _options.vhs, vhs = _options$vhs === void 0 ? {} : _options$vhs, _options$hls = _options.hls, hls = _options$hls === void 0 ? {} : _options$hls;
        var defaultOverrideNative = !(videojs3.browser.IS_ANY_SAFARI || videojs3.browser.IS_IOS);
        var _vhs$overrideNative = vhs.overrideNative, overrideNative = _vhs$overrideNative === void 0 ? defaultOverrideNative : _vhs$overrideNative;
        var _hls$overrideNative = hls.overrideNative, legacyOverrideNative = _hls$overrideNative === void 0 ? false : _hls$overrideNative;
        return legacyOverrideNative || overrideNative;
      }
    };
    var supportsNativeMediaSources = function supportsNativeMediaSources2() {
      return codecs_js.browserSupportsCodec("avc1.4d400d,mp4a.40.2");
    };
    if (supportsNativeMediaSources()) {
      videojs3.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0);
    }
    videojs3.VhsHandler = VhsHandler;
    Object.defineProperty(videojs3, "HlsHandler", {
      get: function get2() {
        videojs3.log.warn("videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead.");
        return VhsHandler;
      },
      configurable: true
    });
    videojs3.VhsSourceHandler = VhsSourceHandler;
    Object.defineProperty(videojs3, "HlsSourceHandler", {
      get: function get2() {
        videojs3.log.warn("videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead.");
        return VhsSourceHandler;
      },
      configurable: true
    });
    videojs3.Vhs = Vhs;
    Object.defineProperty(videojs3, "Hls", {
      get: function get2() {
        videojs3.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead.");
        return Vhs;
      },
      configurable: true
    });
    if (!videojs3.use) {
      videojs3.registerComponent("Hls", Vhs);
      videojs3.registerComponent("Vhs", Vhs);
    }
    videojs3.options.vhs = videojs3.options.vhs || {};
    videojs3.options.hls = videojs3.options.hls || {};
    if (!videojs3.getPlugin || !videojs3.getPlugin("reloadSourceOnError")) {
      registerPlugin = videojs3.registerPlugin || videojs3.plugin;
      registerPlugin("reloadSourceOnError", reloadSourceOnError);
    }
    var registerPlugin;
    module.exports = videojs3;
  }
});

// public/scripts/videojsx.vast.js
var require_videojsx_vast = __commonJS({
  "public/scripts/videojsx.vast.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_video_cjs(), require_vast_client_min());
      else if (typeof define === "function" && define.amd)
        define(["video.js", "@dailymotion/vast-client"], factory);
      else if (typeof exports === "object")
        exports["videojsxVast"] = factory(require_video_cjs(), require_vast_client_min());
      else
        root["videojsxVast"] = factory(root["videojs"], root["vastClient"]);
    })(exports, (__WEBPACK_EXTERNAL_MODULE__660__, __WEBPACK_EXTERNAL_MODULE__581__) => {
      return (() => {
        var __webpack_modules__ = {
          697: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var topLevel = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : {};
            var minDoc = __webpack_require__2(542);
            var doccy;
            if (typeof document !== "undefined") {
              doccy = document;
            } else {
              doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
              if (!doccy) {
                doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
              }
            }
            module2.exports = doccy;
          },
          840: (module2, __unused_webpack_exports, __webpack_require__2) => {
            var win;
            if (typeof window !== "undefined") {
              win = window;
            } else if (typeof __webpack_require__2.g !== "undefined") {
              win = __webpack_require__2.g;
            } else if (typeof self !== "undefined") {
              win = self;
            } else {
              win = {};
            }
            module2.exports = win;
          },
          940: (module2) => {
            "use strict";
            var METHODS = [
              "handshakeVersion",
              "initAd",
              "startAd",
              "stopAd",
              "skipAd",
              "resizeAd",
              "pauseAd",
              "resumeAd",
              "expandAd",
              "collapseAd",
              "subscribe",
              "unsubscribe"
            ];
            var EVENTS = [
              "AdLoaded",
              "AdStarted",
              "AdStopped",
              "AdSkipped",
              "AdSkippableStateChange",
              "AdSizeChange",
              "AdLinearChange",
              "AdDurationChange",
              "AdExpandedChange",
              "AdRemainingTimeChange",
              "AdVolumeChange",
              "AdImpression",
              "AdVideoStart",
              "AdVideoFirstQuartile",
              "AdVideoMidpoint",
              "AdVideoThirdQuartile",
              "AdVideoComplete",
              "AdClickThru",
              "AdInteraction",
              "AdUserAcceptInvitation",
              "AdUserMinimize",
              "AdUserClose",
              "AdPaused",
              "AdPlaying",
              "AdLog",
              "AdError"
            ];
            var GETTERS = [
              "getAdLinear",
              "getAdWidth",
              "getAdHeight",
              "getAdExpanded",
              "getAdSkippableState",
              "getAdRemainingTime",
              "getAdDuration",
              "getAdVolume",
              "getAdCompanions",
              "getAdIcons"
            ];
            var SETTERS = [
              "setAdVolume"
            ];
            function IVPAIDAdUnit(creative, el, video) {
            }
            IVPAIDAdUnit.prototype.handshakeVersion = function(VPAIDVersion, callback) {
            };
            IVPAIDAdUnit.prototype.initAd = function(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {
            };
            IVPAIDAdUnit.prototype.startAd = function(callback) {
            };
            IVPAIDAdUnit.prototype.stopAd = function(callback) {
            };
            IVPAIDAdUnit.prototype.skipAd = function(callback) {
            };
            IVPAIDAdUnit.prototype.resizeAd = function(width, height, viewMode, callback) {
            };
            IVPAIDAdUnit.prototype.pauseAd = function(callback) {
            };
            IVPAIDAdUnit.prototype.resumeAd = function(callback) {
            };
            IVPAIDAdUnit.prototype.expandAd = function(callback) {
            };
            IVPAIDAdUnit.prototype.collapseAd = function(callback) {
            };
            IVPAIDAdUnit.prototype.subscribe = function(event, handler, context) {
            };
            IVPAIDAdUnit.prototype.unsubscribe = function(event, handler) {
            };
            IVPAIDAdUnit.prototype.getAdLinear = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdWidth = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdHeight = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdExpanded = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdSkippableState = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdRemainingTime = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdDuration = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdVolume = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdCompanions = function(callback) {
            };
            IVPAIDAdUnit.prototype.getAdIcons = function(callback) {
            };
            IVPAIDAdUnit.prototype.setAdVolume = function(volume, callback) {
            };
            addStaticToInterface(IVPAIDAdUnit, "METHODS", METHODS);
            addStaticToInterface(IVPAIDAdUnit, "GETTERS", GETTERS);
            addStaticToInterface(IVPAIDAdUnit, "SETTERS", SETTERS);
            addStaticToInterface(IVPAIDAdUnit, "EVENTS", EVENTS);
            var VPAID1_METHODS = METHODS.filter(function(method) {
              return ["skipAd"].indexOf(method) === -1;
            });
            addStaticToInterface(IVPAIDAdUnit, "checkVPAIDInterface", function checkVPAIDInterface(creative) {
              var result = VPAID1_METHODS.every(function(key) {
                return typeof creative[key] === "function";
              });
              return result;
            });
            module2.exports = IVPAIDAdUnit;
            function addStaticToInterface(Interface, name, value) {
              Object.defineProperty(Interface, name, {
                writable: false,
                configurable: false,
                value
              });
            }
          },
          251: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var IVPAIDAdUnit = __webpack_require__2(940);
            var Subscriber = __webpack_require__2(932);
            var checkVPAIDInterface = IVPAIDAdUnit.checkVPAIDInterface;
            var utils = __webpack_require__2(981);
            var METHODS = IVPAIDAdUnit.METHODS;
            var ERROR = "AdError";
            var AD_CLICK = "AdClickThru";
            var FILTERED_EVENTS = IVPAIDAdUnit.EVENTS.filter(function(event) {
              return event != AD_CLICK;
            });
            function VPAIDAdUnit(VPAIDCreative, el, video, iframe) {
              this._isValid = checkVPAIDInterface(VPAIDCreative);
              if (this._isValid) {
                this._creative = VPAIDCreative;
                this._el = el;
                this._videoEl = video;
                this._iframe = iframe;
                this._subscribers = new Subscriber();
                utils.setFullSizeStyle(el);
                $addEventsSubscribers.call(this);
              }
            }
            VPAIDAdUnit.prototype = Object.create(IVPAIDAdUnit.prototype);
            VPAIDAdUnit.prototype.isValidVPAIDAd = function isValidVPAIDAd() {
              return this._isValid;
            };
            IVPAIDAdUnit.METHODS.forEach(function(method) {
              var ignores = [
                "subscribe",
                "unsubscribe",
                "initAd"
              ];
              if (ignores.indexOf(method) !== -1)
                return;
              VPAIDAdUnit.prototype[method] = function() {
                var ariaty = IVPAIDAdUnit.prototype[method].length;
                var args = Array.prototype.slice.call(arguments);
                var callback = ariaty === args.length ? args.pop() : void 0;
                setTimeout(function() {
                  var result, error = null;
                  try {
                    result = this._creative[method].apply(this._creative, args);
                  } catch (e) {
                    error = e;
                  }
                  callOrTriggerEvent(callback, this._subscribers, error, result);
                }.bind(this), 0);
              };
            });
            VPAIDAdUnit.prototype.initAd = function initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars, callback) {
              creativeData = creativeData || {};
              environmentVars = utils.extend({
                slot: this._el,
                videoSlot: this._videoEl
              }, environmentVars || {});
              setTimeout(function() {
                var error;
                try {
                  this._creative.initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars);
                } catch (e) {
                  error = e;
                }
                callOrTriggerEvent(callback, this._subscribers, error);
              }.bind(this), 0);
            };
            VPAIDAdUnit.prototype.subscribe = function subscribe(event, handler, context) {
              this._subscribers.subscribe(handler, event, context);
            };
            VPAIDAdUnit.prototype.unsubscribe = function unsubscribe(event, handler) {
              this._subscribers.unsubscribe(handler, event);
            };
            VPAIDAdUnit.prototype.on = VPAIDAdUnit.prototype.subscribe;
            VPAIDAdUnit.prototype.off = VPAIDAdUnit.prototype.unsubscribe;
            IVPAIDAdUnit.GETTERS.forEach(function(getter) {
              VPAIDAdUnit.prototype[getter] = function(callback) {
                setTimeout(function() {
                  var result, error = null;
                  try {
                    result = this._creative[getter]();
                  } catch (e) {
                    error = e;
                  }
                  callOrTriggerEvent(callback, this._subscribers, error, result);
                }.bind(this), 0);
              };
            });
            VPAIDAdUnit.prototype.setAdVolume = function setAdVolume(volume, callback) {
              setTimeout(function() {
                var result, error = null;
                try {
                  this._creative.setAdVolume(volume);
                  result = this._creative.getAdVolume();
                } catch (e) {
                  error = e;
                }
                if (!error) {
                  error = utils.validate(result === volume, "failed to apply volume: " + volume);
                }
                callOrTriggerEvent(callback, this._subscribers, error, result);
              }.bind(this), 0);
            };
            VPAIDAdUnit.prototype._destroy = function destroy() {
              this.stopAd();
              this._subscribers.unsubscribeAll();
            };
            function $addEventsSubscribers() {
              FILTERED_EVENTS.forEach(function(event) {
                this._creative.subscribe($trigger.bind(this, event), event);
              }.bind(this));
              this._creative.subscribe($clickThruHook.bind(this), AD_CLICK);
              if (this._videoEl) {
                var documentElement = this._iframe.contentDocument.documentElement;
                var videoEl = this._videoEl;
                documentElement.addEventListener("click", function(e) {
                  if (e.target === documentElement) {
                    videoEl.click();
                  }
                });
              }
            }
            function $clickThruHook(url, id, playerHandles) {
              this._subscribers.triggerSync(AD_CLICK, { url, id, playerHandles });
            }
            function $trigger(event) {
              this._subscribers.trigger.apply(this._subscribers, Array.prototype.slice.call(arguments));
            }
            function callOrTriggerEvent(callback, subscribers, error, result) {
              if (callback) {
                callback(error, result);
              } else if (error) {
                subscribers.trigger(ERROR, error);
              }
            }
            module2.exports = VPAIDAdUnit;
          },
          289: (module2, __unused_webpack_exports, __webpack_require__2) => {
            "use strict";
            var utils = __webpack_require__2(981);
            var unique = utils.unique("vpaidIframe");
            var VPAIDAdUnit = __webpack_require__2(251);
            var defaultTemplate = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"></head><body style="margin:0;padding:0"><div class="ad-element"></div><script type="text/javascript" src="{{iframeURL_JS}}"><\/script><script type="text/javascript">window.parent.postMessage('{"event": "ready", "id": "{{iframeID}}"}', '{{origin}}');<\/script></body></html>`;
            var AD_STOPPED = "AdStopped";
            function VPAIDHTML5Client(el, video, templateConfig, vpaidOptions) {
              templateConfig = templateConfig || {};
              this._id = unique();
              this._destroyed = false;
              this._frameContainer = utils.createElementInEl(el, "div");
              this._videoEl = video;
              this._vpaidOptions = vpaidOptions || { timeout: 1e4 };
              this._templateConfig = {
                template: templateConfig.template || defaultTemplate,
                extraOptions: templateConfig.extraOptions || {}
              };
            }
            VPAIDHTML5Client.prototype.destroy = function destroy() {
              if (this._destroyed) {
                return;
              }
              this._destroyed = true;
              $unloadPreviousAdUnit.call(this);
            };
            VPAIDHTML5Client.prototype.isDestroyed = function isDestroyed() {
              return this._destroyed;
            };
            VPAIDHTML5Client.prototype.loadAdUnit = function loadAdUnit(adURL, callback) {
              if (this._onLoad) {
                return;
              }
              $throwIfDestroyed.call(this);
              $unloadPreviousAdUnit.call(this);
              var that = this;
              var frame = utils.createIframeWithContent(this._frameContainer, this._templateConfig.template, utils.extend({
                iframeURL_JS: adURL,
                iframeID: this.getID(),
                origin: getOrigin()
              }, this._templateConfig.extraOptions));
              this._frame = frame;
              this._onLoad = utils.callbackTimeout(this._vpaidOptions.timeout, onLoad.bind(this), onTimeout.bind(this));
              window.addEventListener("message", this._onLoad);
              function onLoad(e) {
                if (e.origin !== getOrigin())
                  return;
                var result;
                try {
                  result = JSON.parse(e.data);
                } catch (exception) {
                  throw exception;
                }
                if (result.id !== that.getID())
                  return;
                var adUnit, error, createAd;
                if (!that._frame.contentWindow) {
                  error = "the iframe is not anymore in the DOM tree";
                } else {
                  createAd = that._frame.contentWindow.getVPAIDAd;
                  error = utils.validate(typeof createAd === "function", "the ad didn't return a function to create an ad");
                }
                if (!error) {
                  var adEl = that._frame.contentWindow.document.querySelector(".ad-element");
                  adUnit = new VPAIDAdUnit(createAd(), adEl, that._videoEl, that._frame);
                  adUnit.subscribe(AD_STOPPED, $adDestroyed.bind(that));
                  error = utils.validate(adUnit.isValidVPAIDAd(), "the add is not fully complaint with VPAID specification");
                }
                that._adUnit = adUnit;
                $destroyLoadListener.call(that);
                callback(error, error ? null : adUnit);
                return true;
              }
              function onTimeout() {
                callback("timeout", null);
              }
            };
            VPAIDHTML5Client.prototype.unloadAdUnit = function unloadAdUnit() {
              $unloadPreviousAdUnit.call(this);
            };
            VPAIDHTML5Client.prototype.getID = function() {
              return this._id;
            };
            function $removeEl(key) {
              var el = this[key];
              if (el && el.parentNode) {
                el.parentNode.removeChild(el);
                delete this[key];
              }
            }
            function $adDestroyed() {
              $removeAdElements.call(this);
              delete this._adUnit;
            }
            function $unloadPreviousAdUnit() {
              $removeAdElements.call(this);
              $destroyAdUnit.call(this);
            }
            function $removeAdElements() {
              $removeEl.call(this, "_frame");
              $destroyLoadListener.call(this);
            }
            function $destroyLoadListener() {
              if (this._onLoad) {
                window.removeEventListener("message", this._onLoad);
                delete this._onLoad;
              }
            }
            function $destroyAdUnit() {
              if (this._adUnit) {
                this._adUnit.stopAd();
                delete this._adUnit;
              }
            }
            function $throwIfDestroyed() {
              if (this._destroyed) {
                throw new Error("VPAIDHTML5Client already destroyed!");
              }
            }
            function getOrigin() {
              if (window.location.origin) {
                return window.location.origin;
              } else {
                return window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port : "");
              }
            }
            module2.exports = VPAIDHTML5Client;
            window.VPAIDHTML5Client = VPAIDHTML5Client;
          },
          932: (module2) => {
            "use strict";
            function Subscriber() {
              this._subscribers = {};
            }
            Subscriber.prototype.subscribe = function subscribe(handler, eventName, context) {
              if (!this.isHandlerAttached(handler, eventName)) {
                this.get(eventName).push({ handler, context, eventName });
              }
            };
            Subscriber.prototype.unsubscribe = function unsubscribe(handler, eventName) {
              this._subscribers[eventName] = this.get(eventName).filter(function(subscriber) {
                return handler !== subscriber.handler;
              });
            };
            Subscriber.prototype.unsubscribeAll = function unsubscribeAll() {
              this._subscribers = {};
            };
            Subscriber.prototype.trigger = function(eventName, data) {
              var that = this;
              var subscribers = this.get(eventName).concat(this.get("*"));
              subscribers.forEach(function(subscriber) {
                setTimeout(function() {
                  if (that.isHandlerAttached(subscriber.handler, subscriber.eventName)) {
                    subscriber.handler.call(subscriber.context, data);
                  }
                }, 0);
              });
            };
            Subscriber.prototype.triggerSync = function(eventName, data) {
              var subscribers = this.get(eventName).concat(this.get("*"));
              subscribers.forEach(function(subscriber) {
                subscriber.handler.call(subscriber.context, data);
              });
            };
            Subscriber.prototype.get = function get(eventName) {
              if (!this._subscribers[eventName]) {
                this._subscribers[eventName] = [];
              }
              return this._subscribers[eventName];
            };
            Subscriber.prototype.isHandlerAttached = function isHandlerAttached(handler, eventName) {
              return this.get(eventName).some(function(subscriber) {
                return handler === subscriber.handler;
              });
            };
            module2.exports = Subscriber;
          },
          981: (module2) => {
            "use strict";
            function noop() {
            }
            function validate(isValid, message) {
              return isValid ? null : new Error(message);
            }
            function callbackTimeout(timer, onSuccess, onTimeout) {
              var callback, timeout;
              timeout = setTimeout(function() {
                onSuccess = noop;
                onTimeout();
              }, timer);
              callback = function() {
                var args = Array.prototype.slice.call(arguments);
                if (onSuccess.apply(this, args)) {
                  clearTimeout(timeout);
                }
              };
              return callback;
            }
            function createElementInEl(parent, tagName, id) {
              var nEl = document.createElement(tagName);
              if (id)
                nEl.id = id;
              parent.appendChild(nEl);
              return nEl;
            }
            function createIframeWithContent(parent, template, data) {
              var iframe = createIframe(parent, null, data.zIndex);
              if (!setIframeContent(iframe, simpleTemplate(template, data)))
                return;
              return iframe;
            }
            function createIframe(parent, url, zIndex) {
              var nEl = document.createElement("iframe");
              nEl.src = url || "about:blank";
              nEl.marginWidth = "0";
              nEl.marginHeight = "0";
              nEl.frameBorder = "0";
              nEl.width = "100%";
              nEl.height = "100%";
              setFullSizeStyle(nEl);
              if (zIndex) {
                nEl.style.zIndex = zIndex;
              }
              nEl.setAttribute("SCROLLING", "NO");
              parent.innerHTML = "";
              parent.appendChild(nEl);
              return nEl;
            }
            function setFullSizeStyle(element) {
              if (element) {
                element.style.position = "absolute";
                element.style.left = "0";
                element.style.top = "0";
                element.style.margin = "0px";
                element.style.padding = "0px";
                element.style.border = "none";
                element.style.width = "100%";
                element.style.height = "100%";
              }
            }
            function simpleTemplate(template, data) {
              Object.keys(data).forEach(function(key) {
                var value = typeof value === "object" ? JSON.stringify(data[key]) : data[key];
                template = template.replace(new RegExp("{{" + key + "}}", "g"), value);
              });
              return template;
            }
            function setIframeContent(iframeEl, content) {
              var iframeDoc = iframeEl.contentWindow && iframeEl.contentWindow.document;
              if (!iframeDoc)
                return false;
              iframeDoc.write(content);
              return true;
            }
            function extend(toExtend, fromSource) {
              Object.keys(fromSource).forEach(function(key) {
                toExtend[key] = fromSource[key];
              });
              return toExtend;
            }
            function unique(prefix) {
              var count = -1;
              return function() {
                return prefix + "_" + ++count;
              };
            }
            module2.exports = {
              noop,
              validate,
              callbackTimeout,
              createElementInEl,
              createIframeWithContent,
              createIframe,
              setFullSizeStyle,
              simpleTemplate,
              setIframeContent,
              extend,
              unique
            };
          },
          660: (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__660__;
          },
          581: (module2) => {
            "use strict";
            module2.exports = __WEBPACK_EXTERNAL_MODULE__581__;
          },
          542: () => {
          }
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            exports: {}
          };
          __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        (() => {
          __webpack_require__.n = (module2) => {
            var getter = module2 && module2.__esModule ? () => module2["default"] : () => module2;
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        })();
        (() => {
          __webpack_require__.d = (exports2, definition) => {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        })();
        (() => {
          __webpack_require__.g = function() {
            if (typeof globalThis === "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e) {
              if (typeof window === "object")
                return window;
            }
          }();
        })();
        (() => {
          __webpack_require__.o = (obj2, prop) => Object.prototype.hasOwnProperty.call(obj2, prop);
        })();
        var __webpack_exports__ = {};
        (() => {
          var _onAdPlay, _onTimeUpdate, _linearAdTracker, _companionTracker, _skipAfterDuration, _vastClient, _vastParser, _options, _adSelector, _createTrackedAds, _forceStopDone, _cancelled, _started, _player, _options2, _eventTarget;
          "use strict";
          __webpack_require__.d(__webpack_exports__, {
            "default": () => src
          });
          var external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_ = __webpack_require__(660);
          var external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_default = /* @__PURE__ */ __webpack_require__.n(external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_);
          var vast_client_ = __webpack_require__(581);
          var global_document = __webpack_require__(697);
          var global_window = __webpack_require__(840);
          ;
          class UI extends external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_.EventTarget {
            constructor(player, options) {
              super();
              __privateAdd(this, _onAdPlay, () => {
                const skipDelay = this.skipDelay;
                const player = this.player;
                if (skipDelay > 0 && (player.duration() || this.duration) >= skipDelay) {
                  this.skipButtonElement.style.display = "block";
                  if (this.options.displayRemainingTime) {
                    this.remainingTimeElement.style.display = "block";
                  }
                  if (this.options.displayRemainingTimeIcons) {
                    this.remainingTimePlayElement.classList.remove("vjs-hidden");
                    this.remainingTimeMuteElement.classList.remove("vjs-hidden");
                  }
                  player.on("adtimeupdate", __privateGet(this, _onTimeUpdate));
                }
                player.loadingSpinner.el().style.display = "none";
              });
              __privateAdd(this, _onTimeUpdate, () => {
                this.player.loadingSpinner.el().style.display = "none";
                const timeLeft = Math.ceil(this.skipDelay - this.player.currentTime());
                if (this.options.displayRemainingTime) {
                  const remainingTimeLeft = Math.ceil(this.player.remainingTime());
                  this.remainingTimeElement.innerHTML = this.options.messages.remainingTime.replace("{seconds}", remainingTimeLeft);
                }
                if (timeLeft > 0) {
                  disableSkip(this.skipButtonElement);
                  this.skipButtonElement.innerHTML = this.options.messages.skipCountdown.replace("{seconds}", timeLeft);
                } else {
                  enableSkip(this.skipButtonElement);
                  this.skipButtonElement.innerHTML = this.options.messages.skip;
                }
              });
              this.player = player;
              this.options = options;
              this.duration = 0;
              this.skipDelay = 0;
              this.originalState = {
                controlsEnabled: player.controls(),
                seekEnabled: player.controlBar.progressControl.enabled()
              };
            }
            setUp() {
              const player = this.player;
              const options = this.options;
              const setupProgressControl = () => {
                player.controls(options.controlsEnabled);
                if (options.seekEnabled) {
                  player.controlBar.progressControl.enable();
                } else {
                  player.controlBar.progressControl.disable();
                }
              };
              const setupBlocker = () => {
                const blocker = this.blocker = global_window.document.createElement("div");
                blocker.className = "vast-blocker";
                blocker.onclick = () => {
                  if (player.paused()) {
                    player.play();
                    return false;
                  }
                  this.trigger("click");
                };
                player.el().insertBefore(blocker, player.controlBar.el());
              };
              const setupSkipButton = () => {
                const skipButtonElement = this.skipButtonElement = global_window.document.createElement("div");
                skipButtonElement.className = "vast-skip-button";
                skipButtonElement.style.display = "none";
                player.el().appendChild(skipButtonElement);
                player.one("adplay", __privateGet(this, _onAdPlay));
                skipButtonElement.onclick = (e) => {
                  if ((" " + skipButtonElement.className + " ").indexOf(" enabled ") >= 0) {
                    this.trigger("skip");
                  }
                  if (global_window.Event.prototype.stopPropagation !== void 0) {
                    e.stopPropagation();
                  } else {
                    return false;
                  }
                };
              };
              const setupRemainingTime = () => {
                if (!options.displayRemainingTime)
                  return;
                const remainingTimeElement = this.remainingTimeElement = global_window.document.createElement("div");
                remainingTimeElement.className = "vast-remaining-time";
                remainingTimeElement.style.display = "none";
                player.el().appendChild(remainingTimeElement);
              };
              const setupRemainingTimeIcon = (type) => {
                if (!options.displayRemainingTimeIcons)
                  return;
                const config = {
                  play: {
                    className: "vjs-icon-play vast-remaining-time-icon-play",
                    action: (player2) => player2.paused() ? player2.play() : player2.pause(),
                    toggleClasses: ["vjs-icon-pause", "vjs-icon-play"],
                    events: ["adplay", "adpause"],
                    initialState: (player2) => player2.paused() ? "vjs-icon-play" : "vjs-icon-pause"
                  },
                  mute: {
                    className: "vast-remaining-time-icon-mute",
                    action: (player2) => player2.muted(!player2.muted()),
                    toggleClasses: ["vjs-icon-volume-high", "vjs-icon-volume-mute"],
                    events: ["advolumechange"],
                    initialState: (player2) => player2.paused() ? "vjs-icon-play" : "vjs-icon-pause",
                    updateState: (button2, player2) => {
                      button2.removeClass("vjs-icon-play");
                      button2.removeClass("vjs-icon-pause");
                      button2.addClass(player2.paused() ? "vjs-icon-play" : "vjs-icon-pause");
                    }
                  }
                };
                const {
                  className,
                  action,
                  toggleClasses,
                  events,
                  initialState,
                  updateState
                } = config[type];
                const button = player.addChild("button", {
                  className: `vjs-hidden vjs-visible-text vjs-button vast-remaining-time-icon ${className}`,
                  clickHandler: function() {
                    action(this.player);
                  }.bind(this)
                });
                button.removeClass("vjs-control");
                button.addClass(initialState(player));
                const toggleIcon = () => {
                  if (updateState) {
                    updateState(button, player);
                  } else {
                    toggleClasses.forEach((cls) => button.toggleClass(cls));
                  }
                };
                this[`remainingTime${type.charAt(0).toUpperCase() + type.slice(1)}Element`] = button.el();
                events.forEach((event) => player.on(event, toggleIcon));
              };
              setupProgressControl();
              setupBlocker();
              setupSkipButton();
              setupRemainingTime();
              setupRemainingTimeIcon("play");
              setupRemainingTimeIcon("mute");
            }
            tearDown() {
              const player = this.player;
              const originalState = this.originalState;
              this.duration = 0;
              this.skipDelay = 0;
              player.controls(originalState.controlsEnabled);
              if (originalState.seekEnabled) {
                player.controlBar.progressControl.enable();
              } else {
                player.controlBar.progressControl.disable();
              }
              this.blocker.parentElement.removeChild(this.blocker);
              this.skipButtonElement.parentElement.removeChild(this.skipButtonElement);
              if (this.options.displayRemainingTime) {
                this.remainingTimeElement.parentElement.removeChild(this.remainingTimeElement);
              }
              if (this.options.displayRemainingTimeIcons) {
                this.remainingTimePlayElement.parentElement.removeChild(this.remainingTimePlayElement);
                this.remainingTimeMuteElement.parentElement.removeChild(this.remainingTimeMuteElement);
              }
              player.off("adtimeupdate", __privateGet(this, _onTimeUpdate));
              player.off("adplay", __privateGet(this, _onAdPlay));
            }
          }
          _onAdPlay = new WeakMap();
          _onTimeUpdate = new WeakMap();
          function isSkipEnabled(skipButtonElement) {
            return (" " + skipButtonElement.className + " ").indexOf(" enabled ") > -1;
          }
          function disableSkip(skipButtonElement) {
            if (isSkipEnabled(skipButtonElement)) {
              skipButtonElement.className = skipButtonElement.className.replace(" enabled ", "");
            }
          }
          function enableSkip(skipButtonElement) {
            if (!isSkipEnabled(skipButtonElement)) {
              skipButtonElement.className += " enabled ";
            }
          }
          ;
          function once(fn, context = null) {
            let result;
            return function() {
              if (fn) {
                result = fn.apply(context || this, arguments);
                fn = null;
              }
              return result;
            };
          }
          function linearFn(creative) {
            return creative.type === "linear" && creative.mediaFiles.length;
          }
          function companionFn(creative) {
            return creative.type === "companion";
          }
          function cloneJson(obj2) {
            return JSON.parse(JSON.stringify(obj2));
          }
          function convertOffsetToSeconds(offsetCode, duration = null) {
            let result = null;
            if (typeof offsetCode === "string") {
              if (offsetCode.includes("%")) {
                if (duration != null) {
                  const percent = offsetCode.replace("%", "");
                  result = percent / 100 * duration;
                }
              } else if (offsetCode.includes(":")) {
                const [hours, minutes, seconds] = offsetCode.split(":").slice(-3);
                result = parseInt(hours || 0, 10) * 3600 + parseInt(minutes || 0, 10) * 60 + parseInt(seconds || 0, 10);
              } else {
                result = parseInt(offsetCode);
              }
            }
            if (result == null) {
              result = Number(offsetCode);
            }
            return isNaN(result) ? null : result;
          }
          ;
          class TrackedAd {
            constructor(linearAdTracker, companionTracker) {
              __privateAdd(this, _linearAdTracker, void 0);
              __privateAdd(this, _companionTracker, void 0);
              __privateAdd(this, _skipAfterDuration, void 0);
              __privateSet(this, _linearAdTracker, linearAdTracker);
              __privateSet(this, _companionTracker, companionTracker);
              __privateSet(this, _skipAfterDuration, false);
            }
            get linearCreative() {
              return __privateGet(this, _linearAdTracker).creative;
            }
            get linearAdTracker() {
              return __privateGet(this, _linearAdTracker);
            }
            get companionTracker() {
              return __privateGet(this, _companionTracker);
            }
            get skipAfterDuration() {
              return __privateGet(this, _skipAfterDuration);
            }
            set skipAfterDuration(value) {
              __privateSet(this, _skipAfterDuration, value);
            }
            hasVideoMedia() {
              return this.linearCreative.mediaFiles.some((mediaFile) => mediaFile && mediaFile.apiFramework == null);
            }
          }
          _linearAdTracker = new WeakMap();
          _companionTracker = new WeakMap();
          _skipAfterDuration = new WeakMap();
          ;
          class AdLoader {
            constructor(vastClient, vastParser, adSelector, options) {
              __privateAdd(this, _vastClient, void 0);
              __privateAdd(this, _vastParser, void 0);
              __privateAdd(this, _options, void 0);
              __privateAdd(this, _adSelector, void 0);
              __privateAdd(this, _createTrackedAds, (ads) => {
                const createTrackedAd = (ad) => {
                  const linearAdTracker = new vast_client_.VASTTracker(__privateGet(this, _vastClient), ad, ad.creatives.find(linearFn), ad.creatives.find(companionFn));
                  linearAdTracker.on("clickthrough", onClickThrough);
                  let companionAdTracker = null;
                  const companionCreative = ad.creatives.find(companionFn);
                  if (companionCreative) {
                    const options = __privateGet(this, _options);
                    const variation = companionCreative.variations.filter((v) => v.staticResource).filter((v) => v.type.indexOf("image") === 0).find((v) => parseInt(v.width, 10) <= options.companion.maxWidth && parseInt(v.height, 10) <= options.companion.maxHeight);
                    if (variation) {
                      companionAdTracker = new vast_client_.VASTTracker(__privateGet(this, _vastClient), ad, companionCreative, variation);
                      companionAdTracker.on("clickthrough", onClickThrough);
                    }
                  }
                  return new TrackedAd(linearAdTracker, companionAdTracker);
                };
                return ads.map(createTrackedAd);
              });
              __privateSet(this, _vastClient, vastClient);
              __privateSet(this, _vastParser, vastParser);
              __privateSet(this, _adSelector, adSelector);
              __privateSet(this, _options, options);
            }
            loadAds(params = {}) {
              return new Promise((accept, reject) => {
                const {
                  url: urlConfig,
                  xml
                } = params;
                const urls = (Array.isArray(urlConfig) ? urlConfig : [urlConfig]).filter((url) => url != null);
                let promise;
                if (urls.length) {
                  promise = Promise.resolve([]);
                  urls.forEach((url) => {
                    promise = promise.then((ads) => {
                      if (ads == null || ads.length === 0) {
                        return this.loadAdsWithUrl(url);
                      } else {
                        return ads;
                      }
                    }).catch((ignore) => {
                      return [];
                    });
                  });
                } else if (xml != null) {
                  promise = this.loadAdsWithXml(xml);
                } else {
                  throw new Error("xml or url must be set");
                }
                promise.then(accept).catch(reject);
              });
            }
            loadAdsWithXml(xml) {
              return new Promise((accept, reject) => {
                let xmlDocument;
                if (xml.constructor === global_window.XMLDocument) {
                  xmlDocument = xml;
                } else if (xml.constructor === String) {
                  xmlDocument = new global_window.DOMParser().parseFromString(xml, "application/xml");
                } else {
                  throw new Error("xml config option must be a String or XMLDocument");
                }
                __privateGet(this, _vastParser).parseVAST(xmlDocument).then(__privateGet(this, _adSelector).selectAds).then(__privateGet(this, _createTrackedAds)).then(accept).catch(reject);
              });
            }
            loadAdsWithUrl(url) {
              return new Promise((accept, reject) => {
                __privateGet(this, _vastClient).get(url, {
                  withCredentials: __privateGet(this, _options).withCredentials,
                  wrapperLimit: __privateGet(this, _options).wrapperLimit
                }).then(__privateGet(this, _adSelector).selectAds).then(__privateGet(this, _createTrackedAds)).then(accept).catch(reject);
              });
            }
          }
          _vastClient = new WeakMap();
          _vastParser = new WeakMap();
          _options = new WeakMap();
          _adSelector = new WeakMap();
          _createTrackedAds = new WeakMap();
          function onClickThrough(url) {
            global_window.open(url, "_blank");
          }
          ;
          class AdSelector {
            selectAds(vastResponse) {
              if (!vastResponse.ads || vastResponse.ads.length === 0) {
                throw new Error("no ads found in VAST");
              }
              const adsWithLinear = vastResponse.ads.filter((ad) => ad.creatives.some(linearFn));
              if (!adsWithLinear.length) {
                throw new Error("no linear ads found in VAST");
              }
              const adPod = adsWithLinear.filter((ad) => ad.sequence);
              if (adPod.length) {
                return adPod.sort((ad1, ad2) => ad1.sequence - ad2.sequence);
              } else {
                const standaloneAds = adsWithLinear.filter((ad) => !adPod.includes(ad));
                return standaloneAds.slice(0, 1);
              }
            }
          }
          var VPAIDHTML5Client = __webpack_require__(289);
          ;
          function createVASTContext(vastTracker) {
            if (vastTracker) {
              const ad = vastTracker.ad;
              const creative = vastTracker.creative;
              return {
                mediaFiles: creative.mediaFiles.map((mediaFile) => Object.assign({}, mediaFile)),
                adSequenceId: ad.sequence,
                adId: ad.id,
                creativeAdId: creative.id
              };
            }
          }
          ;
          const VALID_TYPES = ["application/x-javascript", "text/javascript", "application/javascript"];
          class VPAIDHandler {
            constructor(player, options) {
              __privateAdd(this, _forceStopDone, void 0);
              __privateAdd(this, _cancelled, void 0);
              __privateAdd(this, _started, void 0);
              __privateAdd(this, _player, void 0);
              __privateAdd(this, _options2, void 0);
              __privateAdd(this, _eventTarget, void 0);
              __privateSet(this, _player, player);
              __privateSet(this, _options2, options);
              __privateSet(this, _eventTarget, new videojs.EventTarget());
            }
            handle(tracker) {
              __privateSet(this, _cancelled, false);
              __privateSet(this, _started, false);
              __privateSet(this, _forceStopDone, false);
              return new Promise((resolve, reject) => {
                const options = __privateGet(this, _options2);
                const player = __privateGet(this, _player);
                let container = null;
                let containerAttributes = {};
                let containerIsFixed = false;
                const adUnitLoad = (err, adUnit) => {
                  let videoElement;
                  if (err) {
                    reject(err);
                    return;
                  }
                  const onAdComplete = () => {
                    cleanUp();
                    resolve();
                    player.trigger("vpaid.AdStopped");
                    player.trigger({
                      type: "vast.adEnd",
                      vast: createVASTContext(tracker)
                    });
                  };
                  adUnit.subscribe("AdStopped", onAdComplete);
                  const forceStopAd = (err2) => {
                    if (adUnit && !__privateGet(this, _forceStopDone)) {
                      adUnit.unsubscribe("AdStopped", onAdComplete);
                      const onAdCancel = () => {
                        __privateSet(this, _forceStopDone, true);
                        cleanUp();
                        reject(err2);
                        player.trigger("vpaid.AdStopped");
                      };
                      subscribeWithTimeout(adUnit, "AdStopped", onAdCancel, onAdCancel);
                      adUnit.stopAd();
                    } else {
                      __privateSet(this, _forceStopDone, true);
                      reject(err2);
                    }
                  };
                  __privateGet(this, _eventTarget).on("forceStopAd", forceStopAd);
                  if (__privateGet(this, _cancelled)) {
                    forceStopAd("Received cancel signal from player");
                    return;
                  }
                  function cleanUp() {
                    player.controlBar.show();
                    player.off("playerresize", resizeAd);
                    if (options.vpaid.videoInstance === "new" && videoElement.parentElement) {
                      videoElement.parentElement.removeChild(videoElement);
                    }
                    vpaidClient.destroy();
                    if (container) {
                      if (containerIsFixed) {
                        container.innerHTML = "";
                        const before = containerAttributes;
                        const after = getAttributes(container);
                        for (const [key, value] of Object.entries(after)) {
                          if (before.hasOwnProperty(key)) {
                            if (before[key] !== value) {
                              container.setAttribute(key, before[key]);
                            }
                          } else {
                            container.removeAttribute(key);
                          }
                        }
                        for (const [key, value] of Object.entries(before)) {
                          if (!after.hasOwnProperty(key)) {
                            container.setAttribute(key, value);
                          }
                        }
                      } else if (container.parentElement) {
                        container.parentElement.removeChild(container);
                      }
                      container = null;
                    }
                  }
                  const onHandShake = (error, version2) => {
                    var _a;
                    if (error) {
                      log.console(error);
                      forceStopAd("Error on VPAID handshake");
                      return;
                    }
                    const creativeData = {
                      AdParameters: creative.adParameters || "",
                      Duration: creative.duration || 30,
                      SkipTime: options.skip,
                      ClickURL: ((_a = creative.videoClickThroughURLTemplate) == null ? void 0 : _a.url) || "about:blank",
                      All: creative,
                      Options: options
                    };
                    const videoInstance = options.vpaid.videoInstance;
                    if (videoInstance === "same") {
                      videoElement = player.tech({
                        kindaKnowWhatImDoing: true
                      }).el();
                    } else if (videoInstance === "new") {
                      videoElement = global_window.document.createElement("video");
                      videoElement.style.cssText = "position:absolute; top:0; left:0; z-index:2 !important;";
                      container.appendChild(videoElement);
                    } else {
                      if (videoInstance !== "none") {
                        console.log(`${videoInstance} is an invalid videoInstance value. Defaulting to 'none'.`);
                      }
                      videoElement = null;
                    }
                    const environmentVars = {
                      slot: container,
                      videoSlot: videoElement
                    };
                    subscribeWithTimeout(adUnit, "AdLoaded", onAdLoaded, forceStopAd);
                    const viewMode = player.isFullscreen() ? "fullscreen" : "normal";
                    adUnit.subscribe("AdError", (message) => {
                      tracker.error({
                        ERRORCODE: 901
                      });
                      __privateSet(this, _forceStopDone, true);
                      cleanUp();
                      reject(`Fatal VPAID Error: ${typeof message === "object" ? JSON.stringify(message) : message}`);
                      player.trigger({
                        type: "vpaid.AdError",
                        error: message
                      });
                    });
                    adUnit.initAd(player.currentWidth(), player.currentHeight(), viewMode, -1, creativeData, environmentVars);
                  };
                  const onAdLoaded = () => {
                    if (__privateGet(this, _cancelled)) {
                      forceStopAd("Received cancel signal");
                      return;
                    }
                    adUnit.subscribe("AdSkipped", () => {
                      tracker.skip();
                      player.trigger("vpaid.AdSkipped");
                      player.trigger({
                        type: "vast.adSkip",
                        vast: createVASTContext(tracker)
                      });
                    });
                    adUnit.subscribe("AdVolumeChange", () => {
                      const lastVolume = player.volume();
                      adUnit.getAdVolume((error, currentVolume) => {
                        if (error)
                          return;
                        if (currentVolume === 0 && lastVolume > 0) {
                          tracker.setMuted(true);
                        } else if (currentVolume > 0 && lastVolume === 0) {
                          tracker.setMuted(false);
                        }
                        player.volume(currentVolume);
                        player.trigger("vpaid.AdVolumeChange");
                      });
                    });
                    adUnit.subscribe("AdImpression", () => {
                      tracker.trackImpression();
                      player.trigger("vpaid.AdImpression");
                    });
                    adUnit.subscribe("AdClickThru", ({
                      url,
                      id,
                      playerHandles
                    }) => {
                      if (!playerHandles) {
                        tracker.once("clickthrough", (resolvedUrl) => {
                          global_window.open(resolvedUrl, "_blank");
                        });
                      }
                      tracker.click(url);
                      player.trigger("vpaid.AdClickThru");
                    });
                    adUnit.subscribe("AdVideoFirstQuartile", () => {
                      tracker.track("firstQuartile");
                      player.trigger("vpaid.AdVideoFirstQuartile");
                    });
                    adUnit.subscribe("AdVideoMidpoint", () => {
                      tracker.track("midpoint");
                      player.trigger("vpaid.AdVideoMidpoint");
                    });
                    adUnit.subscribe("AdVideoThirdQuartile", () => {
                      tracker.track("thirdQuartile");
                      player.trigger("vpaid.AdVideoThirdQuartile");
                    });
                    adUnit.subscribe("AdVideoComplete", () => {
                      tracker.track("complete");
                      player.trigger("vpaid.AdVideoComplete");
                    });
                    adUnit.subscribe("AdUserAcceptInvitation", () => {
                      tracker.acceptInvitation();
                      player.trigger("vpaid.AdUserAcceptInvitation");
                    });
                    adUnit.subscribe("AdUserMinimize", () => {
                      tracker.minimize();
                      player.trigger("vpaid.AdUserMinimize");
                    });
                    adUnit.subscribe("AdUserClose", () => {
                      tracker.close();
                      player.trigger("vpaid.AdUserClose");
                    });
                    adUnit.subscribe("AdPaused", () => {
                      tracker.setPaused(true);
                      player.trigger("vpaid.AdPaused");
                    });
                    adUnit.subscribe("AdPlaying", () => {
                      tracker.setPaused(false);
                      player.trigger("vpaid.AdPlaying");
                    });
                    adUnit.getAdLinear(withTimeout((err2, isLinear) => {
                      if (__privateGet(this, _cancelled)) {
                        forceStopAd("Received cancel signal");
                        return;
                      }
                      if (err2) {
                        forceStopAd(err2);
                      } else if (!isLinear) {
                        forceStopAd("Non-linear not supported");
                      } else {
                        startLinearAd();
                      }
                    }, () => {
                      forceStopAd("Unable to get mode of operation: linear or non-linear");
                    }));
                    const startLinearAd = () => {
                      player.controlBar.hide();
                      const onAdStartedOnce = once(onAdStarted);
                      subscribeWithTimeout(adUnit, "AdStarted", onAdStartedOnce, forceStopAd);
                      adUnit.startAd();
                    };
                  };
                  const onAdStarted = () => {
                    if (!__privateGet(this, _cancelled)) {
                      __privateSet(this, _started, true);
                      tracker.track("start");
                      player.on("playerresize", resizeAd);
                      player.trigger("ads-ad-started");
                      player.trigger({
                        type: "vast.adStart",
                        vast: createVASTContext(tracker)
                      });
                    } else {
                      forceStopAd("Received cancel signal");
                    }
                  };
                  const resizeAd = () => {
                    adUnit.resizeAd(player.currentWidth(), player.currentHeight(), player.isFullscreen() ? "fullscreen" : "normal");
                  };
                  adUnit.handshakeVersion("2.0", onHandShake);
                };
                const creative = tracker.creative;
                const vpaidMediaFile = creative.mediaFiles.find((mediaFile) => mediaFile.apiFramework === "VPAID" && validMime(mediaFile));
                if (!vpaidMediaFile) {
                  throw new Error("Invalid VPAID media file: only JavaScript is supported");
                }
                const techScreen = player.el().querySelector(".vjs-tech");
                container = findHtmlContainer(options);
                if (!container) {
                  container = createHtmlContainer(options);
                  containerIsFixed = false;
                } else {
                  containerIsFixed = true;
                }
                containerAttributes = getAttributes(container);
                player.el().insertBefore(container, player.controlBar.el());
                const vpaidClient = new VPAIDHTML5Client(container, techScreen, {});
                vpaidClient.loadAdUnit(vpaidMediaFile.fileURL, adUnitLoad);
              });
            }
            cancel() {
              __privateSet(this, _cancelled, true);
              if (__privateGet(this, _started)) {
                __privateGet(this, _eventTarget).trigger("forceStopAd");
              }
            }
          }
          _forceStopDone = new WeakMap();
          _cancelled = new WeakMap();
          _started = new WeakMap();
          _player = new WeakMap();
          _options2 = new WeakMap();
          _eventTarget = new WeakMap();
          function validMime(mediaFile) {
            return VALID_TYPES.indexOf(mediaFile.mimeType.trim()) > -1;
          }
          function createHtmlContainer(options) {
            const containerId = options.vpaid.containerId;
            const containerClass = options.vpaid.containerClass;
            const vpaidContainerElement = global_document.createElement("div");
            if (containerId) {
              vpaidContainerElement.setAttribute("id", containerId);
            }
            if (containerClass) {
              vpaidContainerElement.classList.add(containerClass);
            }
            return vpaidContainerElement;
          }
          function findHtmlContainer(options) {
            const containerId = options.vpaid.containerId;
            const containerClass = options.vpaid.containerClass;
            let vpaidContainerElement = global_document.getElementById(containerId);
            if (!vpaidContainerElement) {
              vpaidContainerElement = global_document.getElementsByClassName(containerClass)[0];
            }
            return vpaidContainerElement;
          }
          function getAttributes(element) {
            const obj2 = {};
            for (const attr of element.attributes) {
              obj2[attr.name] = attr.value;
            }
            return obj2;
          }
          function withTimeout(handler, timeoutFn = null) {
            const id = setTimeout(() => {
              handler = () => {
              };
              if (timeoutFn) {
                timeoutFn();
              }
            }, 1e4);
            return function() {
              clearTimeout(id);
              handler.apply(null, arguments);
            };
          }
          function subscribeWithTimeout(adUnit, evtName, handler, timeoutFn) {
            const fn = withTimeout(handler, () => {
              if (timeoutFn) {
                timeoutFn(new Error(`Timeout while waiting for ${evtName} event.`));
              }
            });
            adUnit.subscribe(evtName, fn);
          }
          ;
          const Plugin = external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_.getPlugin("plugin");
          const DEFAULT_OPTIONS = Object.freeze({
            seekEnabled: false,
            controlsEnabled: false,
            wrapperLimit: 10,
            withCredentials: true,
            skip: 0,
            displayRemainingTime: false,
            displayRemainingTimeIcons: false,
            messages: {
              skip: "Skip",
              skipCountdown: "Skip in {seconds}...",
              remainingTime: "This ad will end in {seconds}"
            },
            vpaid: {
              containerId: void 0,
              containerClass: "vjs-vpaid-container",
              videoInstance: "none"
            },
            companion: {
              elementId: null,
              maxWidth: 0,
              maxHeight: 0
            },
            honorSkipOffset: false
          });
          class VastPlugin extends Plugin {
            constructor(player, options) {
              super(player);
              if (typeof player.ads === "function") {
                player.ads({
                  debug: false,
                  liveCuePoints: false
                });
              }
              player.on("play", function() {
                console.log("play event triggered");
              });
              console.log(`videojsx-vast-plugin running`);
              const mergeOptionsFunction = parseInt(external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_.VERSION, 10) >= 8 ? external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_.obj.merge : external_root_videojs_commonjs_video_js_commonjs2_video_js_amd_video_js_.mergeOptions;
              options = mergeOptionsFunction(DEFAULT_OPTIONS, options || {});
              const vastClient = new vast_client_.VASTClient();
              const ads = [];
              let currentAd = null;
              let adCount = 0;
              let adTotal = 0;
              const vpaidHandler = new VPAIDHandler(player, options);
              let timedOut = false;
              let currentAdSrc = null;
              let schedule = options.schedule;
              if (schedule == null || schedule.length === 0) {
                schedule = [{
                  offset: 0,
                  url: options.url || null,
                  xml: options.xml || null
                }];
              } else {
                schedule = cloneJson(schedule);
                schedule.forEach((item) => delete item.offsetInSeconds);
              }
              const preRollScheduleItem = findFirstPreroll(schedule);
              const postRollScheduleItem = findFirstPostroll(schedule);
              const midRollScheduleItems = findAllMidrolls(schedule).sort((a, b) => a.offset - b.offset);
              const autoplay = player.autoplay();
              player.on("adtimeout", () => {
                timedOut = true;
              });
              const ui = new UI(player, options);
              function reset() {
                ads.length = 0;
                if (player.ads.isInAdMode()) {
                  playNextAd();
                }
              }
              function skip() {
                if (currentAd == null ? void 0 : currentAd.hasVideoMedia()) {
                  currentAd.linearAdTracker.skip();
                  player.trigger({
                    type: "vast.skipAd",
                    vast: createVASTContext(currentAd.linearAdTracker)
                  });
                  playNextAd();
                }
              }
              ui.on("skip", skip);
              ui.on("click", () => {
                currentAd.linearAdTracker.click();
              });
              const onTimeUpdate = (() => {
                let lock = false;
                return () => {
                  if (lock)
                    return;
                  let offsetInSeconds = null;
                  while (midRollScheduleItems.length > 0) {
                    offsetInSeconds = midRollScheduleItems[0].offsetInSeconds;
                    if (offsetInSeconds != null) {
                      break;
                    }
                    const {
                      offset
                    } = midRollScheduleItems[0];
                    offsetInSeconds = convertOffsetToSeconds(offset, player.duration());
                    if (offsetInSeconds == null) {
                      midRollScheduleItems.shift();
                    } else {
                      midRollScheduleItems[0].offsetInSeconds = offsetInSeconds;
                    }
                  }
                  if (offsetInSeconds != null) {
                    if (this.player.currentTime() > offsetInSeconds) {
                      lock = true;
                      const scheduleItem = midRollScheduleItems.shift();
                      adLoader.loadAds(scheduleItem).then((trackedAds) => {
                        if (trackedAds.length > 0) {
                          ads.push(...trackedAds);
                          currentAd = null;
                          startAdBreak();
                        }
                      }).catch((err) => {
                        console.log(`An error occurred when loading ads for the midroll ad break: : ${err == null ? void 0 : err.message}`);
                      }).finally(() => {
                        lock = false;
                      });
                    }
                  }
                };
              })();
              if (midRollScheduleItems.length > 0) {
                player.on("timeupdate", onTimeUpdate);
              }
              player.on("readyforpostroll", () => {
                timedOut = false;
                if (!postRollScheduleItem) {
                  player.trigger("nopostroll");
                  return;
                }
                adLoader.loadAds(postRollScheduleItem).then((trackedAds) => {
                  if (timedOut) {
                    trackedAds.forEach((ad) => {
                      ad.linearAdTracker.error({
                        ERRORCODE: 301
                      });
                    });
                  } else if (trackedAds.length > 0) {
                    ads.push(...trackedAds);
                    currentAd = null;
                    startAdBreak();
                  } else {
                    player.trigger("nopostroll");
                  }
                }).catch((err) => {
                  console.log(`An error occurred when loading ads for the postroll ad break: : ${err.message}`);
                  player.trigger("nopostroll");
                });
              });
              player.on("readyforpreroll", () => {
                startAdBreak();
              });
              player.on("contentchanged", () => {
                midRollScheduleItems.forEach((item) => delete item.offsetInSeconds);
                startAds();
              });
              player.on("adloadstart", () => {
                const src2 = player.currentSrc();
                if (src2 !== currentAdSrc) {
                  player.ads.disableNextSnapshotRestore = true;
                  const snapshotObject = player.ads.snapshot;
                  if (snapshotObject) {
                    const tech = player.$(".vjs-tech");
                    if (tech && "style" in snapshotObject) {
                      tech.setAttribute("style", snapshotObject.style || "");
                    }
                  }
                  const oldSource = player.ads.contentSrc;
                  player.ads.contentSrc = src2;
                  reset();
                  player.trigger("contentresumed");
                  player.trigger("contentchanged");
                  player.trigger({
                    type: "contentupdate",
                    oldValue: oldSource,
                    newValue: src2
                  });
                }
              });
              const adLoader = new AdLoader(vastClient, new vast_client_.VASTParser(), new AdSelector(), options);
              function startAds() {
                const signalAdsReady = once(() => {
                  player.trigger("adsready");
                });
                setTimeout(signalAdsReady, 3e3);
                adLoader.loadAds(preRollScheduleItem).then((trackedAds) => {
                  if (timedOut) {
                    trackedAds.forEach((ad) => {
                      ad.linearAdTracker.error({
                        ERRORCODE: 301
                      });
                    });
                  } else if (trackedAds.length > 0) {
                    ads.push(...trackedAds);
                    currentAd = null;
                  } else {
                    player.trigger("nopreroll");
                  }
                }).catch((err) => {
                  console.log(`An error occurred when loading ads for the preroll ad break: ${err.message}`);
                  player.trigger("nopreroll");
                }).finally(() => {
                  signalAdsReady();
                  if (autoplay) {
                    player.play();
                  }
                });
              }
              startAds();
              const createSourceObjects = (mediaFiles) => {
                return mediaFiles.filter((mediaFile) => mediaFile.apiFramework == null).map((mediaFile) => ({
                  type: mediaFile.mimeType,
                  src: mediaFile.fileURL
                }));
              };
              const playNextAd = () => {
                const nextAd = ads.shift();
                if (nextAd == null ? void 0 : nextAd.hasVideoMedia()) {
                  if (!(currentAd == null ? void 0 : currentAd.hasVideoMedia())) {
                    ui.setUp();
                  }
                } else {
                  if (currentAd == null ? void 0 : currentAd.hasVideoMedia()) {
                    ui.tearDown();
                  }
                }
                if (nextAd) {
                  currentAd = nextAd;
                  adCount++;
                  console.log(`Playing ad ${adCount}/${adTotal}`);
                  if (currentAd.hasVideoMedia()) {
                    const allMediaFiles = currentAd.linearCreative.mediaFiles;
                    const streamingMediaFiles = allMediaFiles.filter((mediaFile) => mediaFile.deliveryType === "streaming");
                    const nonStreamingMediaFiles = allMediaFiles.filter((mediaFile) => mediaFile.deliveryType !== "streaming");
                    if (nonStreamingMediaFiles.length > 0) {
                      player.src(createSourceObjects(nonStreamingMediaFiles));
                      currentAdSrc = player.src();
                    } else if (streamingMediaFiles.length > 0) {
                      let assetDuration = currentAd.linearAdTracker.assetDuration;
                      if (assetDuration == null || assetDuration < 1) {
                        console.log("Streaming ads must have a duration");
                        playNextAd();
                        return;
                      }
                      player.src(createSourceObjects(streamingMediaFiles));
                      currentAdSrc = player.src();
                      currentAd.skipAfterDuration = true;
                    }
                    ui.duration = currentAd.linearAdTracker.assetDuration || 0;
                    const skipDelay = currentAd.linearAdTracker.skipDelay;
                    ui.skipDelay = skipDelay != null && options.honorSkipOffset ? skipDelay : options.skip;
                  } else {
                    vpaidHandler.handle(currentAd.linearAdTracker).then(() => {
                      playNextAd();
                    }).catch((err) => {
                      console.log(err);
                      playNextAd();
                    });
                  }
                  showCompanionAd();
                } else {
                  endAdBreak();
                }
              };
              const {
                setUpEvents,
                tearDownEvents
              } = (() => {
                const adPlayFn = () => {
                  if (currentAd.skipAfterDuration) {
                    const ad = currentAd;
                    setTimeout(() => {
                      if (currentAd === ad) {
                        skip();
                      }
                    }, ad.linearAdTracker.assetDuration * 1e3);
                  }
                  if (!currentAd.linearAdTracker.impressed && currentAd.hasVideoMedia()) {
                    currentAd.linearAdTracker.trackImpression();
                    player.trigger({
                      type: "vast.adStart",
                      vast: createVASTContext(currentAd.linearAdTracker)
                    });
                  }
                };
                const timeupdateFn = () => {
                  if (currentAd) {
                    if (isNaN(currentAd.linearAdTracker.assetDuration)) {
                      currentAd.linearAdTracker.assetDuration = player.duration();
                    }
                    currentAd.linearAdTracker.setProgress(player.currentTime());
                  }
                };
                const pauseFn = () => {
                  if (player.remainingTime() > 0) {
                    currentAd.linearAdTracker.setPaused(true);
                    player.one("adplay", () => {
                      currentAd.linearAdTracker.setPaused(false);
                    });
                  }
                };
                const adErrorFn = () => {
                  const MEDIAFILE_PLAYBACK_ERROR = 405;
                  currentAd.linearAdTracker.error({
                    ERRORCODE: MEDIAFILE_PLAYBACK_ERROR
                  });
                  player.error(null);
                  playNextAd();
                };
                const fullScreenFn = () => {
                  currentAd.linearAdTracker.setFullscreen(player.isFullscreen());
                };
                const muteFn = (() => {
                  let previousMuted = player.muted();
                  let previousVolume = player.volume();
                  return () => {
                    const volumeNow = player.volume();
                    const mutedNow = player.muted();
                    if (previousMuted !== mutedNow) {
                      currentAd.linearAdTracker.setMuted(mutedNow);
                      previousMuted = mutedNow;
                    } else if (previousVolume !== volumeNow) {
                      if (previousVolume > 0 && volumeNow === 0) {
                        currentAd.linearAdTracker.setMuted(true);
                      } else if (previousVolume === 0 && volumeNow > 0) {
                        currentAd.linearAdTracker.setMuted(false);
                      }
                      previousVolume = volumeNow;
                    }
                  };
                })();
                const adEndedFn = () => {
                  if (currentAd.hasVideoMedia()) {
                    currentAd.linearAdTracker.complete();
                    player.trigger({
                      type: "vast.adEnd",
                      vast: createVASTContext(currentAd.linearAdTracker)
                    });
                    playNextAd();
                  }
                };
                return {
                  setUpEvents: () => {
                    player.on("adended", adEndedFn);
                    player.on("adplay", adPlayFn);
                    player.on("adtimeupdate", timeupdateFn);
                    player.on("adpause", pauseFn);
                    player.on("aderror", adErrorFn);
                    player.on("advolumechange", muteFn);
                    player.on("fullscreenchange", fullScreenFn);
                  },
                  tearDownEvents: () => {
                    player.off("adended", adEndedFn);
                    player.off("adplay", adPlayFn);
                    player.off("adtimeupdate", timeupdateFn);
                    player.off("adpause", pauseFn);
                    player.off("aderror", adErrorFn);
                    player.off("advolumechange", muteFn);
                    player.off("fullscreenchange", fullScreenFn);
                  }
                };
              })();
              const showCompanionAd = () => {
                const companionTracker = currentAd.companionTracker;
                const dest = global_document.getElementById(options.companion.elementId);
                if (companionTracker && companionTracker.variation && dest) {
                  const variation = companionTracker.variation;
                  const onClick = () => {
                    companionTracker.click();
                  };
                  const hyperLink = global_document.createElement("a");
                  hyperLink.src = "#";
                  hyperLink.addEventListener("click", onClick);
                  const image = global_document.createElement("img");
                  image.src = variation.staticResource;
                  hyperLink.appendChild(image);
                  dest.innerHTML = "";
                  dest.appendChild(hyperLink);
                } else if (dest) {
                  dest.innerHTML = "";
                }
              };
              const startAdBreak = () => {
                adTotal = ads.length;
                console.log(`Playing ${adTotal} ads`);
                player.ads.startLinearAdMode();
                setUpEvents();
                playNextAd();
              };
              function isPreroll(scheduleItem) {
                return scheduleItem.offset === 0 || scheduleItem.offset == null || scheduleItem.offset === "pre";
              }
              function isPostroll(scheduleItem) {
                return scheduleItem.offset === "post";
              }
              function findFirstPreroll(schedule2) {
                return schedule2.find(isPreroll);
              }
              function findFirstPostroll(schedule2) {
                return schedule2.find(isPostroll);
              }
              function findAllMidrolls(schedule2) {
                return schedule2.filter((item) => !isPreroll(item) && !isPostroll(item));
              }
              const endAdBreak = () => {
                currentAdSrc = null;
                currentAd = null;
                adCount = 0;
                player.ads.endLinearAdMode();
                tearDownEvents();
                console.log("Playing content");
              };
            }
          }
          ;
          const videojsxVast2 = {
            VastPlugin,
            VASTClient: vast_client_.VASTClient,
            VASTParser: vast_client_.VASTParser,
            VASTTracker: vast_client_.VASTTracker,
            AdLoader,
            AdSelector,
            TrackedAd,
            VPAIDHandler,
            utils: {
              createVASTContext,
              once,
              linearFn,
              companionFn,
              cloneJson,
              convertOffsetToSeconds
            },
            createClient: () => new vast_client_.VASTClient(),
            createParser: () => new vast_client_.VASTParser(),
            createAdLoader: (options = {}) => {
              const client = new vast_client_.VASTClient();
              const parser = new vast_client_.VASTParser();
              const selector = new AdSelector();
              return new AdLoader(client, parser, selector, options);
            }
          };
          const src = videojsxVast2;
        })();
        __webpack_exports__ = __webpack_exports__["default"];
        return __webpack_exports__;
      })();
    });
  }
});

// client/video-watch-client-plugin.js
var import_vast_client = __toESM(require_vast_client_min());

// node_modules/videojs-contrib-ads/dist/videojs-contrib-ads.es.js
var import_video = __toESM(require_video_cjs());
var import_window = __toESM(require_window());
var import_document = __toESM(require_document());
var version = "6.9.0";
function getAds(player) {
  return {
    disableNextSnapshotRestore: false,
    _contentEnding: false,
    _contentHasEnded: false,
    _hasThereBeenALoadStartDuringPlayerLife: false,
    _hasThereBeenALoadedData: false,
    _hasThereBeenALoadedMetaData: false,
    _inLinearAdMode: false,
    _shouldBlockPlay: false,
    _playBlocked: false,
    _playRequested: false,
    adType: null,
    VERSION: version,
    reset: function reset() {
      player.ads.disableNextSnapshotRestore = false;
      player.ads._contentEnding = false;
      player.ads._contentHasEnded = false;
      player.ads.snapshot = null;
      player.ads.adType = null;
      player.ads._hasThereBeenALoadedData = false;
      player.ads._hasThereBeenALoadedMetaData = false;
      player.ads._cancelledPlay = false;
      player.ads._shouldBlockPlay = false;
      player.ads._playBlocked = false;
      player.ads.nopreroll_ = false;
      player.ads.nopostroll_ = false;
      player.ads._playRequested = false;
    },
    startLinearAdMode: function startLinearAdMode() {
      player.ads._state.startLinearAdMode();
    },
    endLinearAdMode: function endLinearAdMode() {
      player.ads._state.endLinearAdMode();
    },
    skipLinearAdMode: function skipLinearAdMode() {
      player.ads._state.skipLinearAdMode();
    },
    stitchedAds: function stitchedAds(arg) {
      if (arg !== void 0) {
        import_video.default.log.warn("Using player.ads.stitchedAds() as a setter is deprecated, it should be set as an option upon initialization of contrib-ads.");
        this.settings.stitchedAds = !!arg;
      }
      return this.settings.stitchedAds;
    },
    videoElementRecycled: function videoElementRecycled() {
      if (player.ads.shouldPlayContentBehindAd(player)) {
        return false;
      }
      if (!this.snapshot) {
        throw new Error("You cannot use videoElementRecycled while there is no snapshot.");
      }
      var srcChanged = player.tech_.src() !== this.snapshot.src;
      var currentSrcChanged = player.currentSrc() !== this.snapshot.currentSrc;
      return srcChanged || currentSrcChanged;
    },
    isLive: function isLive(somePlayer) {
      if (somePlayer === void 0) {
        somePlayer = player;
      }
      if (typeof somePlayer.ads.settings.contentIsLive === "boolean") {
        return somePlayer.ads.settings.contentIsLive;
      } else if (somePlayer.duration() === Infinity) {
        return true;
      } else if (import_video.default.browser.IOS_VERSION === "8" && somePlayer.duration() === 0) {
        return true;
      }
      return false;
    },
    shouldPlayContentBehindAd: function shouldPlayContentBehindAd(somePlayer) {
      if (somePlayer === void 0) {
        somePlayer = player;
      }
      if (!somePlayer) {
        throw new Error("shouldPlayContentBehindAd requires a player as a param");
      } else if (!somePlayer.ads.settings.liveCuePoints) {
        return false;
      } else {
        return !import_video.default.browser.IS_IOS && !import_video.default.browser.IS_ANDROID && somePlayer.duration() === Infinity;
      }
    },
    shouldTakeSnapshots: function shouldTakeSnapshots(somePlayer) {
      if (somePlayer === void 0) {
        somePlayer = player;
      }
      return !this.shouldPlayContentBehindAd(somePlayer) && !this.stitchedAds();
    },
    isInAdMode: function isInAdMode() {
      return this._state.isAdState();
    },
    isWaitingForAdBreak: function isWaitingForAdBreak() {
      return this._state.isWaitingForAdBreak();
    },
    isContentResuming: function isContentResuming() {
      return this._state.isContentResuming();
    },
    isAdPlaying: function isAdPlaying() {
      return this._state.inAdBreak();
    },
    inAdBreak: function inAdBreak() {
      return this._state.inAdBreak();
    },
    removeNativePoster: function removeNativePoster() {
      var tech = player.$(".vjs-tech");
      if (tech) {
        tech.removeAttribute("poster");
      }
    },
    debug: function debug() {
      if (this.settings.debug) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (args.length === 1 && typeof args[0] === "string") {
          import_video.default.log("ADS: " + args[0]);
        } else {
          import_video.default.log.apply(import_video.default, ["ADS:"].concat(args));
        }
      }
    }
  };
}
var cancelEvent = function cancelEvent2(player, event) {
  event.isImmediatePropagationStopped = function() {
    return true;
  };
  event.cancelBubble = true;
  event.isPropagationStopped = function() {
    return true;
  };
};
var prefixEvent = function prefixEvent2(player, prefix, event) {
  cancelEvent(player, event);
  player.trigger({
    type: prefix + event.type,
    originalEvent: event
  });
};
var handlePlaying = function handlePlaying2(player, event) {
  if (player.ads.isInAdMode()) {
    if (player.ads.isContentResuming()) {
      if (player.ads._contentEnding) {
        prefixEvent(player, "content", event);
      }
    } else {
      prefixEvent(player, "ad", event);
    }
  }
};
var handleEnded = function handleEnded2(player, event) {
  if (player.ads.isInAdMode()) {
    if (player.ads.isContentResuming()) {
      cancelEvent(player, event);
      player.trigger("resumeended");
    } else {
      prefixEvent(player, "ad", event);
    }
  } else if (!player.ads._contentHasEnded && !player.ads.stitchedAds()) {
    prefixEvent(player, "content", event);
    player.trigger("readyforpostroll");
  }
};
var handleLoadEvent = function handleLoadEvent2(player, event) {
  if (event.type === "loadstart" && !player.ads._hasThereBeenALoadStartDuringPlayerLife || event.type === "loadeddata" && !player.ads._hasThereBeenALoadedData || event.type === "loadedmetadata" && !player.ads._hasThereBeenALoadedMetaData) {
    return;
  } else if (player.ads.inAdBreak()) {
    prefixEvent(player, "ad", event);
  } else if (player.currentSrc() !== player.ads.contentSrc) {
    return;
  } else {
    prefixEvent(player, "content", event);
  }
};
var handlePlay = function handlePlay2(player, event) {
  if (player.ads.inAdBreak()) {
    prefixEvent(player, "ad", event);
  } else if (player.ads.isContentResuming()) {
    prefixEvent(player, "content", event);
  }
};
function redispatch(event) {
  if (event.type === "playing") {
    handlePlaying(this, event);
  } else if (event.type === "ended") {
    handleEnded(this, event);
  } else if (event.type === "loadstart" || event.type === "loadeddata" || event.type === "loadedmetadata") {
    handleLoadEvent(this, event);
  } else if (event.type === "play") {
    handlePlay(this, event);
  } else if (this.ads.isInAdMode()) {
    if (this.ads.isContentResuming()) {
      prefixEvent(this, "content", event);
    } else {
      prefixEvent(this, "ad", event);
    }
  }
}
function initializeContentupdate(player) {
  player.ads.contentSrc = player.currentSrc();
  player.ads._seenInitialLoadstart = false;
  var checkSrc = function checkSrc2() {
    if (!player.ads.inAdBreak()) {
      var src = player.currentSrc();
      if (src !== player.ads.contentSrc) {
        if (player.ads._seenInitialLoadstart) {
          player.trigger({
            type: "contentchanged"
          });
        }
        player.trigger({
          type: "contentupdate",
          oldValue: player.ads.contentSrc,
          newValue: src
        });
        player.ads.contentSrc = src;
      }
      player.ads._seenInitialLoadstart = true;
    }
  };
  player.on("loadstart", checkSrc);
}
var tcData = {};
var proxyTcfApi = function proxyTcfApi2(_) {
  if (import_video.default.dom.isInFrame() && typeof import_window.default.__tcfapi !== "function") {
    var frame = import_window.default;
    var cmpFrame;
    var cmpCallbacks = {};
    while (frame) {
      try {
        if (frame.frames.__tcfapiLocator) {
          cmpFrame = frame;
          break;
        }
      } catch (ignore) {
      }
      if (frame === import_window.default.top) {
        break;
      }
      frame = frame.parent;
    }
    if (!cmpFrame) {
      return;
    }
    import_window.default.__tcfapi = function(cmd, version2, callback, arg) {
      var callId = Math.random() + "";
      var msg = {
        __tcfapiCall: {
          command: cmd,
          parameter: arg,
          version: version2,
          callId
        }
      };
      cmpCallbacks[callId] = callback;
      cmpFrame.postMessage(msg, "*");
    };
    import_window.default.addEventListener("message", function(event) {
      var json = {};
      try {
        json = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
      } catch (ignore) {
      }
      var payload = json.__tcfapiReturn;
      if (payload) {
        if (typeof cmpCallbacks[payload.callId] === "function") {
          cmpCallbacks[payload.callId](payload.returnValue, payload.success);
          cmpCallbacks[payload.callId] = null;
        }
      }
    }, false);
  }
};
var listenToTcf = function listenToTcf2() {
  proxyTcfApi();
  if (typeof import_window.default.__tcfapi === "function") {
    import_window.default.__tcfapi("addEventListener", 2, function(data, success) {
      if (success) {
        tcData = data;
      }
    });
  }
};
var uriEncodeIfNeeded = function uriEncodeIfNeeded2(value, uriEncode) {
  if (uriEncode) {
    return encodeURIComponent(value);
  }
  return value;
};
var customFields = function customFields2(mediainfo, macros, customFieldsName) {
  if (mediainfo && mediainfo[customFieldsName]) {
    var fields = mediainfo[customFieldsName];
    var fieldNames = Object.keys(fields);
    for (var i = 0; i < fieldNames.length; i++) {
      var tag = "{mediainfo." + customFieldsName + "." + fieldNames[i] + "}";
      macros[tag] = fields[fieldNames[i]];
    }
  }
};
function adMacroReplacement(string, uriEncode, customMacros) {
  var _this = this;
  var defaults2 = {};
  string = string.replace(/{([^}=]+)=([^}]+)}/g, function(match, name, defaultVal2) {
    defaults2["{" + name + "}"] = defaultVal2;
    return "{" + name + "}";
  });
  if (uriEncode === void 0) {
    uriEncode = false;
  }
  var macros = {};
  if (customMacros !== void 0) {
    macros = customMacros;
  }
  macros["{player.id}"] = this.options_["data-player"] || this.id_;
  macros["{player.height}"] = this.currentHeight();
  macros["{player.width}"] = this.currentWidth();
  macros["{mediainfo.id}"] = this.mediainfo ? this.mediainfo.id : "";
  macros["{mediainfo.name}"] = this.mediainfo ? this.mediainfo.name : "";
  macros["{mediainfo.duration}"] = this.mediainfo ? this.mediainfo.duration : "";
  macros["{player.duration}"] = this.duration();
  macros["{player.pageUrl}"] = import_video.default.dom.isInFrame() ? import_document.default.referrer : import_window.default.location.href;
  macros["{playlistinfo.id}"] = this.playlistinfo ? this.playlistinfo.id : "";
  macros["{playlistinfo.name}"] = this.playlistinfo ? this.playlistinfo.name : "";
  macros["{timestamp}"] = new Date().getTime();
  macros["{document.referrer}"] = import_document.default.referrer;
  macros["{window.location.href}"] = import_window.default.location.href;
  macros["{random}"] = Math.floor(Math.random() * 1e12);
  ["description", "tags", "reference_id", "ad_keys"].forEach(function(prop) {
    if (_this.mediainfo && _this.mediainfo[prop]) {
      macros["{mediainfo." + prop + "}"] = _this.mediainfo[prop];
    } else if (defaults2["{mediainfo." + prop + "}"]) {
      macros["{mediainfo." + prop + "}"] = defaults2["{mediainfo." + prop + "}"];
    } else {
      macros["{mediainfo." + prop + "}"] = "";
    }
  });
  customFields(this.mediainfo, macros, "custom_fields");
  customFields(this.mediainfo, macros, "customFields");
  Object.keys(tcData).forEach(function(key) {
    macros["{tcf." + key + "}"] = tcData[key];
  });
  macros["{tcf.gdprAppliesInt}"] = tcData.gdprApplies ? 1 : 0;
  for (var i in macros) {
    string = string.split(i).join(uriEncodeIfNeeded(macros[i], uriEncode));
  }
  string = string.replace(/{pageVariable\.([^}]+)}/g, function(match, name) {
    var value;
    var context = import_window.default;
    var names = name.split(".");
    for (var _i = 0; _i < names.length; _i++) {
      if (_i === names.length - 1) {
        value = context[names[_i]];
      } else {
        context = context[names[_i]];
      }
    }
    var type = typeof value;
    if (value === null) {
      return "null";
    } else if (value === void 0) {
      if (defaults2["{pageVariable." + name + "}"]) {
        return defaults2["{pageVariable." + name + "}"];
      }
      import_video.default.log.warn('Page variable "' + name + '" not found');
      return "";
    } else if (type !== "string" && type !== "number" && type !== "boolean") {
      import_video.default.log.warn('Page variable "' + name + '" is not a supported type');
      return "";
    }
    return uriEncodeIfNeeded(String(value), uriEncode);
  });
  for (var defaultVal in defaults2) {
    string = string.replace(defaultVal, defaults2[defaultVal]);
  }
  return string;
}
var cueTextTracks = {};
cueTextTracks.processMetadataTracks = function(player, processMetadataTrack) {
  var tracks = player.textTracks();
  var setModeAndProcess = function setModeAndProcess2(track) {
    if (track.kind === "metadata") {
      player.ads.cueTextTracks.setMetadataTrackMode(track);
      processMetadataTrack(player, track);
    }
  };
  for (var i = 0; i < tracks.length; i++) {
    setModeAndProcess(tracks[i]);
  }
  tracks.addEventListener("addtrack", function(event) {
    setModeAndProcess(event.track);
  });
};
cueTextTracks.setMetadataTrackMode = function(track) {
  return;
};
cueTextTracks.getSupportedAdCue = function(player, cue) {
  return cue;
};
cueTextTracks.isSupportedAdCue = function(player, cue) {
  return true;
};
cueTextTracks.getCueId = function(player, cue) {
  return cue.id;
};
var cueAlreadySeen = function cueAlreadySeen2(player, cueId) {
  return cueId !== void 0 && player.ads.includedCues[cueId];
};
var setCueAlreadySeen = function setCueAlreadySeen2(player, cueId) {
  if (cueId !== void 0 && cueId !== "") {
    player.ads.includedCues[cueId] = true;
  }
};
cueTextTracks.processAdTrack = function(player, cues, processCue, cancelAdsHandler) {
  player.ads.includedCues = {};
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    var cueData = this.getSupportedAdCue(player, cue);
    if (!this.isSupportedAdCue(player, cue)) {
      import_video.default.log.warn("Skipping as this is not a supported ad cue.", cue);
      return;
    }
    var cueId = this.getCueId(player, cue);
    var startTime = cue.startTime;
    if (cueAlreadySeen(player, cueId)) {
      import_video.default.log("Skipping ad already seen with ID " + cueId);
      return;
    }
    if (cancelAdsHandler) {
      cancelAdsHandler(player, cueData, cueId, startTime);
    }
    processCue(player, cueData, cueId, startTime);
    setCueAlreadySeen(player, cueId);
  }
};
function initCancelContentPlay(player, debug) {
  if (debug) {
    import_video.default.log("Using cancelContentPlay to block content playback");
  }
  player.on("play", cancelContentPlay);
}
function cancelContentPlay() {
  if (this.ads._shouldBlockPlay === false) {
    return;
  }
  if (!this.paused()) {
    this.ads.debug("Playback was canceled by cancelContentPlay");
    this.pause();
  }
  this.ads._cancelledPlay = true;
}
var obj = {};
var videojsReference = import_video.default;
obj.isMiddlewareMediatorSupported = function() {
  if (videojsReference.browser.IS_IOS || videojsReference.browser.IS_ANDROID) {
    return false;
  } else if (videojsReference.use && videojsReference.middleware && videojsReference.middleware.TERMINATOR) {
    return true;
  }
  return false;
};
obj.playMiddleware = function(player) {
  return {
    setSource: function setSource(srcObj, next) {
      next(null, srcObj);
    },
    callPlay: function callPlay() {
      if (player.ads && player.ads._shouldBlockPlay === true) {
        player.ads.debug("Using playMiddleware to block content playback");
        player.ads._playBlocked = true;
        return videojsReference.middleware.TERMINATOR;
      }
    },
    play: function play(terminated, playPromise) {
      if (player.ads && player.ads._playBlocked && terminated) {
        player.ads.debug("Play call to Tech was terminated.");
        player.trigger("play");
        player.addClass("vjs-has-started");
        player.ads._playBlocked = false;
      } else if (playPromise && playPromise.catch) {
        playPromise.catch(function(e) {
          if (e.name === "NotAllowedError" && !import_video.default.browser.IS_SAFARI) {
            player.trigger("pause");
          }
        });
      }
    }
  };
};
obj.testHook = function(testVjs) {
  videojsReference = testVjs;
};
var playMiddleware = obj.playMiddleware;
var isMiddlewareMediatorSupported = obj.isMiddlewareMediatorSupported;
var hasAdsPlugin = function hasAdsPlugin2() {
  if (import_video.default.getPlugin) {
    return Boolean(import_video.default.getPlugin("ads"));
  }
  var Player = import_video.default.getComponent("Player");
  return Boolean(Player && Player.prototype.ads);
};
function register(contribAdsPlugin3) {
  if (hasAdsPlugin(import_video.default)) {
    return false;
  }
  var registerPlugin = import_video.default.registerPlugin || import_video.default.plugin;
  registerPlugin("ads", contribAdsPlugin3);
  if (isMiddlewareMediatorSupported() && !import_video.default.usingContribAdsMiddleware_) {
    import_video.default.use("*", playMiddleware);
    import_video.default.usingContribAdsMiddleware_ = true;
    import_video.default.log.debug("Play middleware has been registered with videojs");
  }
  return true;
}
var States = /* @__PURE__ */ function() {
  function States2() {
  }
  States2.getState = function getState(name) {
    if (!name) {
      return;
    }
    if (States2.states_ && States2.states_[name]) {
      return States2.states_[name];
    }
  };
  States2.registerState = function registerState(name, StateToRegister) {
    if (typeof name !== "string" || !name) {
      throw new Error('Illegal state name, "' + name + '"; must be a non-empty string.');
    }
    if (!States2.states_) {
      States2.states_ = {};
    }
    States2.states_[name] = StateToRegister;
    return StateToRegister;
  };
  return States2;
}();
var State = /* @__PURE__ */ function() {
  State2._getName = function _getName() {
    return "Anonymous State";
  };
  function State2(player) {
    this.player = player;
  }
  var _proto = State2.prototype;
  _proto.transitionTo = function transitionTo(NewState) {
    var player = this.player;
    this.cleanup(player);
    var newState = new NewState(player);
    player.ads._state = newState;
    player.ads.debug(this.constructor._getName() + " -> " + newState.constructor._getName());
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    newState.init.apply(newState, [player].concat(args));
  };
  _proto.init = function init() {
  };
  _proto.cleanup = function cleanup() {
  };
  _proto.onPlay = function onPlay() {
  };
  _proto.onPlaying = function onPlaying() {
  };
  _proto.onEnded = function onEnded() {
  };
  _proto.onAdEnded = function onAdEnded() {
  };
  _proto.onAdsReady = function onAdsReady() {
    import_video.default.log.warn("Unexpected adsready event");
  };
  _proto.onAdsError = function onAdsError() {
  };
  _proto.onAdsCanceled = function onAdsCanceled() {
  };
  _proto.onAdTimeout = function onAdTimeout() {
  };
  _proto.onAdStarted = function onAdStarted() {
  };
  _proto.onContentChanged = function onContentChanged() {
  };
  _proto.onContentResumed = function onContentResumed() {
  };
  _proto.onReadyForPostroll = function onReadyForPostroll() {
    import_video.default.log.warn("Unexpected readyforpostroll event");
  };
  _proto.onNoPreroll = function onNoPreroll() {
  };
  _proto.onNoPostroll = function onNoPostroll() {
  };
  _proto.startLinearAdMode = function startLinearAdMode() {
    import_video.default.log.warn("Unexpected startLinearAdMode invocation (State via " + this.constructor._getName() + ")");
  };
  _proto.endLinearAdMode = function endLinearAdMode() {
    import_video.default.log.warn("Unexpected endLinearAdMode invocation (State via " + this.constructor._getName() + ")");
  };
  _proto.skipLinearAdMode = function skipLinearAdMode() {
    import_video.default.log.warn("Unexpected skipLinearAdMode invocation (State via " + this.constructor._getName() + ")");
  };
  _proto.isAdState = function isAdState() {
    throw new Error("isAdState unimplemented for " + this.constructor._getName());
  };
  _proto.isWaitingForAdBreak = function isWaitingForAdBreak() {
    return false;
  };
  _proto.isContentResuming = function isContentResuming() {
    return false;
  };
  _proto.inAdBreak = function inAdBreak() {
    return false;
  };
  _proto.handleEvent = function handleEvent(type) {
    var player = this.player;
    if (type === "play") {
      this.onPlay(player);
    } else if (type === "adsready") {
      this.onAdsReady(player);
    } else if (type === "adserror") {
      this.onAdsError(player);
    } else if (type === "adscanceled") {
      this.onAdsCanceled(player);
    } else if (type === "adtimeout") {
      this.onAdTimeout(player);
    } else if (type === "ads-ad-started") {
      this.onAdStarted(player);
    } else if (type === "contentchanged") {
      this.onContentChanged(player);
    } else if (type === "contentresumed") {
      this.onContentResumed(player);
    } else if (type === "readyforpostroll") {
      this.onReadyForPostroll(player);
    } else if (type === "playing") {
      this.onPlaying(player);
    } else if (type === "ended") {
      this.onEnded(player);
    } else if (type === "nopreroll") {
      this.onNoPreroll(player);
    } else if (type === "nopostroll") {
      this.onNoPostroll(player);
    } else if (type === "adended") {
      this.onAdEnded(player);
    }
  };
  return State2;
}();
States.registerState("State", State);
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var AdState = /* @__PURE__ */ function(_State) {
  _inheritsLoose(AdState2, _State);
  function AdState2(player) {
    var _this;
    _this = _State.call(this, player) || this;
    _this.contentResuming = false;
    _this.waitingForAdBreak = false;
    return _this;
  }
  var _proto = AdState2.prototype;
  _proto.isAdState = function isAdState() {
    return true;
  };
  _proto.onPlaying = function onPlaying() {
    var ContentPlayback2 = States.getState("ContentPlayback");
    if (this.contentResuming) {
      this.transitionTo(ContentPlayback2);
    }
  };
  _proto.onContentResumed = function onContentResumed() {
    var ContentPlayback2 = States.getState("ContentPlayback");
    if (this.contentResuming) {
      this.transitionTo(ContentPlayback2);
    }
  };
  _proto.isWaitingForAdBreak = function isWaitingForAdBreak() {
    return this.waitingForAdBreak;
  };
  _proto.isContentResuming = function isContentResuming() {
    return this.contentResuming;
  };
  _proto.inAdBreak = function inAdBreak() {
    return this.player.ads._inLinearAdMode === true;
  };
  return AdState2;
}(State);
States.registerState("AdState", AdState);
var ContentState = /* @__PURE__ */ function(_State) {
  _inheritsLoose(ContentState2, _State);
  function ContentState2() {
    return _State.apply(this, arguments) || this;
  }
  var _proto = ContentState2.prototype;
  _proto.isAdState = function isAdState() {
    return false;
  };
  _proto.onContentChanged = function onContentChanged(player) {
    var BeforePreroll2 = States.getState("BeforePreroll");
    var Preroll2 = States.getState("Preroll");
    player.ads.debug("Received contentchanged event (ContentState)");
    if (player.paused()) {
      this.transitionTo(BeforePreroll2);
    } else {
      this.transitionTo(Preroll2, false);
      player.pause();
      player.ads._pausedOnContentupdate = true;
    }
  };
  return ContentState2;
}(State);
States.registerState("ContentState", ContentState);
var ContentState$1 = States.getState("ContentState");
var AdsDone = /* @__PURE__ */ function(_ContentState) {
  _inheritsLoose(AdsDone2, _ContentState);
  function AdsDone2() {
    return _ContentState.apply(this, arguments) || this;
  }
  AdsDone2._getName = function _getName() {
    return "AdsDone";
  };
  var _proto = AdsDone2.prototype;
  _proto.init = function init(player) {
    player.ads._contentHasEnded = true;
    player.trigger("ended");
  };
  _proto.startLinearAdMode = function startLinearAdMode() {
    import_video.default.log.warn("Unexpected startLinearAdMode invocation (AdsDone)");
  };
  return AdsDone2;
}(ContentState$1);
States.registerState("AdsDone", AdsDone);
var tryToResumeTimeout_;
function getPlayerSnapshot(player) {
  var currentTime;
  if (import_video.default.browser.IS_IOS && player.ads.isLive(player)) {
    if (player.seekable().length > 0) {
      currentTime = player.currentTime() - player.seekable().end(0);
    } else {
      currentTime = player.currentTime();
    }
  } else {
    currentTime = player.currentTime();
  }
  var tech = player.$(".vjs-tech");
  var tracks = player.textTracks ? player.textTracks() : [];
  var suppressedTracks = [];
  var snapshotObject = {
    ended: player.ended(),
    currentSrc: player.currentSrc(),
    sources: player.currentSources(),
    src: player.tech_.src(),
    currentTime,
    type: player.currentType()
  };
  if (tech) {
    snapshotObject.style = tech.getAttribute("style");
  }
  for (var i = 0; i < tracks.length; i++) {
    var track = tracks[i];
    suppressedTracks.push({
      track,
      mode: track.mode
    });
    track.mode = "disabled";
  }
  snapshotObject.suppressedTracks = suppressedTracks;
  return snapshotObject;
}
function restorePlayerSnapshot(player, callback) {
  var snapshotObject = player.ads.snapshot;
  if (callback === void 0) {
    callback = function callback2() {
    };
  }
  if (player.ads.disableNextSnapshotRestore === true) {
    player.ads.disableNextSnapshotRestore = false;
    delete player.ads.snapshot;
    callback();
    return;
  }
  var tech = player.$(".vjs-tech");
  var attempts = 20;
  var suppressedTracks = snapshotObject.suppressedTracks;
  var trackSnapshot;
  var restoreTracks = function restoreTracks2() {
    for (var i = 0; i < suppressedTracks.length; i++) {
      trackSnapshot = suppressedTracks[i];
      trackSnapshot.track.mode = trackSnapshot.mode;
    }
  };
  var resume = function resume2() {
    var currentTime;
    if (import_video.default.browser.IS_IOS && player.ads.isLive(player)) {
      if (snapshotObject.currentTime < 0) {
        if (player.seekable().length > 0) {
          currentTime = player.seekable().end(0) + snapshotObject.currentTime;
        } else {
          currentTime = player.currentTime();
        }
        player.currentTime(currentTime);
      }
      if (player.paused()) {
        var playPromise2 = player.play();
        if (playPromise2 && playPromise2.catch) {
          playPromise2.catch(function(error) {
            import_video.default.log.warn("Play promise rejected in IOS snapshot resume", error);
          });
        }
      }
    } else if (snapshotObject.ended) {
      player.currentTime(player.duration());
    } else {
      player.currentTime(snapshotObject.currentTime);
      var _playPromise = player.play();
      if (_playPromise && _playPromise.catch) {
        _playPromise.catch(function(error) {
          import_video.default.log.warn("Play promise rejected in snapshot resume", error);
        });
      }
    }
    if (player.ads.shouldRemoveAutoplay_) {
      player.autoplay(false);
      player.ads.shouldRemoveAutoplay_ = false;
    }
  };
  var tryToResume = function tryToResume2() {
    player.off("contentcanplay", tryToResume2);
    if (tryToResumeTimeout_) {
      player.clearTimeout(tryToResumeTimeout_);
    }
    tech = player.el().querySelector(".vjs-tech");
    if (tech.readyState > 1) {
      return resume();
    }
    if (tech.seekable === void 0) {
      return resume();
    }
    if (tech.seekable.length > 0) {
      return resume();
    }
    if (attempts--) {
      player.setTimeout(tryToResume2, 50);
    } else {
      try {
        resume();
      } catch (e) {
        import_video.default.log.warn("Failed to resume the content after an advertisement", e);
      }
    }
  };
  if ("style" in snapshotObject) {
    tech.setAttribute("style", snapshotObject.style || "");
  }
  if (player.ads.videoElementRecycled()) {
    player.one("resumeended", function() {
      delete player.ads.snapshot;
      callback();
    });
    player.one("contentloadedmetadata", restoreTracks);
    if (import_video.default.browser.IS_IOS && !player.autoplay()) {
      player.autoplay(true);
      player.ads.shouldRemoveAutoplay_ = true;
    }
    player.src(snapshotObject.sources);
    player.one("contentcanplay", tryToResume);
    tryToResumeTimeout_ = player.setTimeout(tryToResume, 2e3);
  } else {
    restoreTracks();
    if (!player.ended()) {
      var playPromise = player.play();
      if (playPromise && playPromise.catch) {
        playPromise.catch(function(error) {
          import_video.default.log.warn("Play promise rejected in snapshot restore", error);
        });
      }
    }
    delete player.ads.snapshot;
    callback();
  }
}
function start(player) {
  player.ads.debug("Starting ad break");
  player.ads._inLinearAdMode = true;
  player.trigger("adstart");
  if (player.ads.shouldTakeSnapshots()) {
    player.ads.snapshot = getPlayerSnapshot(player);
  }
  if (player.ads.shouldPlayContentBehindAd(player)) {
    player.ads.preAdVolume_ = player.volume();
    player.volume(0);
  }
  player.addClass("vjs-ad-playing");
  if (player.hasClass("vjs-live")) {
    player.removeClass("vjs-live");
  }
  player.ads.removeNativePoster();
}
function end(player, callback) {
  player.ads.debug("Ending ad break");
  if (callback === void 0) {
    callback = function callback2() {
    };
  }
  player.ads.adType = null;
  player.ads._inLinearAdMode = false;
  player.trigger("adend");
  player.removeClass("vjs-ad-playing");
  if (player.ads.isLive(player)) {
    player.addClass("vjs-live");
  }
  if (player.ads.shouldTakeSnapshots()) {
    restorePlayerSnapshot(player, callback);
  } else {
    player.volume(player.ads.preAdVolume_);
    callback();
  }
}
var obj$1 = {
  start,
  end
};
var AdState$1 = States.getState("AdState");
var Preroll = /* @__PURE__ */ function(_AdState) {
  _inheritsLoose(Preroll2, _AdState);
  function Preroll2() {
    return _AdState.apply(this, arguments) || this;
  }
  Preroll2._getName = function _getName() {
    return "Preroll";
  };
  var _proto = Preroll2.prototype;
  _proto.init = function init(player, adsReady, shouldResumeToContent) {
    this.waitingForAdBreak = true;
    player.addClass("vjs-ad-loading");
    if (shouldResumeToContent || player.ads.nopreroll_) {
      return this.resumeAfterNoPreroll(player);
    }
    var timeout = player.ads.settings.timeout;
    if (typeof player.ads.settings.prerollTimeout === "number") {
      timeout = player.ads.settings.prerollTimeout;
    }
    this._timeout = player.setTimeout(function() {
      player.trigger("adtimeout");
    }, timeout);
    if (adsReady) {
      this.handleAdsReady();
    } else {
      this.adsReady = false;
    }
  };
  _proto.onAdsReady = function onAdsReady(player) {
    if (!player.ads.inAdBreak()) {
      player.ads.debug("Received adsready event (Preroll)");
      this.handleAdsReady();
    } else {
      import_video.default.log.warn("Unexpected adsready event (Preroll)");
    }
  };
  _proto.handleAdsReady = function handleAdsReady() {
    this.adsReady = true;
    this.readyForPreroll();
  };
  _proto.afterLoadStart = function afterLoadStart(callback) {
    var player = this.player;
    if (player.ads._hasThereBeenALoadStartDuringPlayerLife) {
      callback();
    } else {
      player.ads.debug("Waiting for loadstart...");
      player.one("loadstart", function() {
        player.ads.debug("Received loadstart event");
        callback();
      });
    }
  };
  _proto.noPreroll = function noPreroll() {
    var _this = this;
    this.afterLoadStart(function() {
      _this.player.ads.debug("Skipping prerolls due to nopreroll event (Preroll)");
      _this.resumeAfterNoPreroll(_this.player);
    });
  };
  _proto.readyForPreroll = function readyForPreroll() {
    var player = this.player;
    this.afterLoadStart(function() {
      player.ads.debug("Triggered readyforpreroll event (Preroll)");
      player.trigger("readyforpreroll");
    });
  };
  _proto.onAdsCanceled = function onAdsCanceled(player) {
    var _this2 = this;
    player.ads.debug("adscanceled (Preroll)");
    this.afterLoadStart(function() {
      _this2.resumeAfterNoPreroll(player);
    });
  };
  _proto.onAdsError = function onAdsError(player) {
    var _this3 = this;
    import_video.default.log("adserror (Preroll)");
    if (this.inAdBreak()) {
      player.ads.endLinearAdMode();
    } else {
      this.afterLoadStart(function() {
        _this3.resumeAfterNoPreroll(player);
      });
    }
  };
  _proto.startLinearAdMode = function startLinearAdMode() {
    var player = this.player;
    if (this.adsReady && !player.ads.inAdBreak() && !this.isContentResuming()) {
      this.clearTimeout(player);
      player.ads.adType = "preroll";
      this.waitingForAdBreak = false;
      obj$1.start(player);
      player.ads._shouldBlockPlay = false;
    } else {
      import_video.default.log.warn("Unexpected startLinearAdMode invocation (Preroll)");
    }
  };
  _proto.onAdStarted = function onAdStarted(player) {
    player.removeClass("vjs-ad-loading");
  };
  _proto.endLinearAdMode = function endLinearAdMode() {
    var player = this.player;
    if (this.inAdBreak()) {
      player.removeClass("vjs-ad-loading");
      player.addClass("vjs-ad-content-resuming");
      this.contentResuming = true;
      obj$1.end(player);
    }
  };
  _proto.skipLinearAdMode = function skipLinearAdMode() {
    var _this4 = this;
    var player = this.player;
    if (player.ads.inAdBreak() || this.isContentResuming()) {
      import_video.default.log.warn("Unexpected skipLinearAdMode invocation");
    } else {
      this.afterLoadStart(function() {
        player.trigger("adskip");
        player.ads.debug("skipLinearAdMode (Preroll)");
        _this4.resumeAfterNoPreroll(player);
      });
    }
  };
  _proto.onAdTimeout = function onAdTimeout(player) {
    var _this5 = this;
    this.afterLoadStart(function() {
      player.ads.debug("adtimeout (Preroll)");
      _this5.resumeAfterNoPreroll(player);
    });
  };
  _proto.onNoPreroll = function onNoPreroll(player) {
    if (player.ads.inAdBreak() || this.isContentResuming()) {
      import_video.default.log.warn("Unexpected nopreroll event (Preroll)");
    } else {
      this.noPreroll();
    }
  };
  _proto.resumeAfterNoPreroll = function resumeAfterNoPreroll(player) {
    this.contentResuming = true;
    player.ads._shouldBlockPlay = false;
    this.cleanupPartial(player);
    if (player.ads._playRequested || player.ads._pausedOnContentupdate) {
      if (player.paused()) {
        player.ads.debug("resumeAfterNoPreroll: attempting to resume playback (Preroll)");
        var playPromise = player.play();
        if (playPromise && playPromise.then) {
          playPromise.then(null, function(e) {
          });
        }
      } else {
        player.ads.debug("resumeAfterNoPreroll: already playing (Preroll)");
        player.trigger("play");
        player.trigger("playing");
      }
    }
  };
  _proto.cleanup = function cleanup(player) {
    if (!player.ads._hasThereBeenALoadStartDuringPlayerLife) {
      import_video.default.log.warn("Leaving Preroll state before loadstart event can cause issues.");
    }
    this.cleanupPartial(player);
  };
  _proto.cleanupPartial = function cleanupPartial(player) {
    player.removeClass("vjs-ad-loading");
    player.removeClass("vjs-ad-content-resuming");
    this.clearTimeout(player);
  };
  _proto.clearTimeout = function clearTimeout2(player) {
    player.clearTimeout(this._timeout);
    this._timeout = null;
  };
  return Preroll2;
}(AdState$1);
States.registerState("Preroll", Preroll);
var ContentState$2 = States.getState("ContentState");
var BeforePreroll = /* @__PURE__ */ function(_ContentState) {
  _inheritsLoose(BeforePreroll2, _ContentState);
  function BeforePreroll2() {
    return _ContentState.apply(this, arguments) || this;
  }
  BeforePreroll2._getName = function _getName() {
    return "BeforePreroll";
  };
  var _proto = BeforePreroll2.prototype;
  _proto.init = function init(player) {
    this.adsReady = false;
    this.shouldResumeToContent = false;
    player.ads._shouldBlockPlay = player.ads.settings.allowVjsAutoplay ? !player.autoplay() : true;
  };
  _proto.onAdsReady = function onAdsReady(player) {
    player.ads.debug("Received adsready event (BeforePreroll)");
    this.adsReady = true;
  };
  _proto.onPlay = function onPlay(player) {
    var Preroll2 = States.getState("Preroll");
    player.ads.debug("Received play event (BeforePreroll)");
    this.transitionTo(Preroll2, this.adsReady, this.shouldResumeToContent);
  };
  _proto.onAdsCanceled = function onAdsCanceled(player) {
    player.ads.debug("adscanceled (BeforePreroll)");
    this.shouldResumeToContent = true;
  };
  _proto.onAdsError = function onAdsError() {
    this.player.ads.debug("adserror (BeforePreroll)");
    this.shouldResumeToContent = true;
  };
  _proto.onNoPreroll = function onNoPreroll() {
    this.player.ads.debug("Skipping prerolls due to nopreroll event (BeforePreroll)");
    this.shouldResumeToContent = true;
  };
  _proto.skipLinearAdMode = function skipLinearAdMode() {
    var player = this.player;
    player.trigger("adskip");
    player.ads.debug("skipLinearAdMode (BeforePreroll)");
    this.shouldResumeToContent = true;
  };
  _proto.onContentChanged = function onContentChanged() {
    this.init(this.player);
  };
  return BeforePreroll2;
}(ContentState$2);
States.registerState("BeforePreroll", BeforePreroll);
var AdState$2 = States.getState("AdState");
var Midroll = /* @__PURE__ */ function(_AdState) {
  _inheritsLoose(Midroll2, _AdState);
  function Midroll2() {
    return _AdState.apply(this, arguments) || this;
  }
  Midroll2._getName = function _getName() {
    return "Midroll";
  };
  var _proto = Midroll2.prototype;
  _proto.init = function init(player) {
    player.ads.adType = "midroll";
    obj$1.start(player);
    player.addClass("vjs-ad-loading");
  };
  _proto.onAdStarted = function onAdStarted(player) {
    player.removeClass("vjs-ad-loading");
  };
  _proto.endLinearAdMode = function endLinearAdMode() {
    var player = this.player;
    if (this.inAdBreak()) {
      this.contentResuming = true;
      player.addClass("vjs-ad-content-resuming");
      player.removeClass("vjs-ad-loading");
      obj$1.end(player);
    }
  };
  _proto.onAdsError = function onAdsError(player) {
    if (this.inAdBreak()) {
      player.ads.endLinearAdMode();
    }
  };
  _proto.cleanup = function cleanup(player) {
    player.removeClass("vjs-ad-loading");
    player.removeClass("vjs-ad-content-resuming");
  };
  return Midroll2;
}(AdState$2);
States.registerState("Midroll", Midroll);
var AdState$3 = States.getState("AdState");
var Postroll = /* @__PURE__ */ function(_AdState) {
  _inheritsLoose(Postroll2, _AdState);
  function Postroll2() {
    return _AdState.apply(this, arguments) || this;
  }
  Postroll2._getName = function _getName() {
    return "Postroll";
  };
  var _proto = Postroll2.prototype;
  _proto.init = function init(player) {
    this.waitingForAdBreak = true;
    player.ads._contentEnding = true;
    if (!player.ads.nopostroll_) {
      player.addClass("vjs-ad-loading");
      var timeout = player.ads.settings.timeout;
      if (typeof player.ads.settings.postrollTimeout === "number") {
        timeout = player.ads.settings.postrollTimeout;
      }
      this._postrollTimeout = player.setTimeout(function() {
        player.trigger("adtimeout");
      }, timeout);
    } else {
      this.resumeContent(player);
      var AdsDone2 = States.getState("AdsDone");
      this.transitionTo(AdsDone2);
    }
  };
  _proto.startLinearAdMode = function startLinearAdMode() {
    var player = this.player;
    if (!player.ads.inAdBreak() && !this.isContentResuming()) {
      player.ads.adType = "postroll";
      player.clearTimeout(this._postrollTimeout);
      this.waitingForAdBreak = false;
      obj$1.start(player);
    } else {
      import_video.default.log.warn("Unexpected startLinearAdMode invocation (Postroll)");
    }
  };
  _proto.onAdStarted = function onAdStarted(player) {
    player.removeClass("vjs-ad-loading");
  };
  _proto.endLinearAdMode = function endLinearAdMode() {
    var _this = this;
    var player = this.player;
    var AdsDone2 = States.getState("AdsDone");
    if (this.inAdBreak()) {
      player.removeClass("vjs-ad-loading");
      this.resumeContent(player);
      obj$1.end(player, function() {
        _this.transitionTo(AdsDone2);
      });
    }
  };
  _proto.skipLinearAdMode = function skipLinearAdMode() {
    var player = this.player;
    if (player.ads.inAdBreak() || this.isContentResuming()) {
      import_video.default.log.warn("Unexpected skipLinearAdMode invocation");
    } else {
      player.ads.debug("Postroll abort (skipLinearAdMode)");
      player.trigger("adskip");
      this.abort(player);
    }
  };
  _proto.onAdTimeout = function onAdTimeout(player) {
    player.ads.debug("Postroll abort (adtimeout)");
    this.abort(player);
  };
  _proto.onAdsError = function onAdsError(player) {
    player.ads.debug("Postroll abort (adserror)");
    if (player.ads.inAdBreak()) {
      player.ads.endLinearAdMode();
    } else {
      this.abort(player);
    }
  };
  _proto.onContentChanged = function onContentChanged(player) {
    if (this.isContentResuming()) {
      var BeforePreroll2 = States.getState("BeforePreroll");
      this.transitionTo(BeforePreroll2);
    } else if (!this.inAdBreak()) {
      var Preroll2 = States.getState("Preroll");
      this.transitionTo(Preroll2);
    }
  };
  _proto.onNoPostroll = function onNoPostroll(player) {
    if (!this.isContentResuming() && !this.inAdBreak()) {
      this.abort(player);
    } else {
      import_video.default.log.warn("Unexpected nopostroll event (Postroll)");
    }
  };
  _proto.resumeContent = function resumeContent(player) {
    this.contentResuming = true;
    player.addClass("vjs-ad-content-resuming");
  };
  _proto.abort = function abort(player) {
    var AdsDone2 = States.getState("AdsDone");
    this.resumeContent(player);
    player.removeClass("vjs-ad-loading");
    this.transitionTo(AdsDone2);
  };
  _proto.cleanup = function cleanup(player) {
    player.removeClass("vjs-ad-content-resuming");
    player.clearTimeout(this._postrollTimeout);
    player.ads._contentEnding = false;
  };
  return Postroll2;
}(AdState$3);
States.registerState("Postroll", Postroll);
var ContentState$3 = States.getState("ContentState");
var ContentPlayback = /* @__PURE__ */ function(_ContentState) {
  _inheritsLoose(ContentPlayback2, _ContentState);
  function ContentPlayback2() {
    return _ContentState.apply(this, arguments) || this;
  }
  ContentPlayback2._getName = function _getName() {
    return "ContentPlayback";
  };
  var _proto = ContentPlayback2.prototype;
  _proto.init = function init(player) {
    player.ads._shouldBlockPlay = false;
  };
  _proto.onAdsReady = function onAdsReady(player) {
    player.ads.debug("Received adsready event (ContentPlayback)");
    if (!player.ads.nopreroll_) {
      player.ads.debug("Triggered readyforpreroll event (ContentPlayback)");
      player.trigger("readyforpreroll");
    }
  };
  _proto.onReadyForPostroll = function onReadyForPostroll(player) {
    var Postroll2 = States.getState("Postroll");
    player.ads.debug("Received readyforpostroll event");
    this.transitionTo(Postroll2);
  };
  _proto.startLinearAdMode = function startLinearAdMode() {
    var Midroll2 = States.getState("Midroll");
    this.transitionTo(Midroll2);
  };
  return ContentPlayback2;
}(ContentState$3);
States.registerState("ContentPlayback", ContentPlayback);
var ContentState$4 = States.getState("ContentState");
var StitchedContentPlayback = /* @__PURE__ */ function(_ContentState) {
  _inheritsLoose(StitchedContentPlayback2, _ContentState);
  function StitchedContentPlayback2() {
    return _ContentState.apply(this, arguments) || this;
  }
  StitchedContentPlayback2._getName = function _getName() {
    return "StitchedContentPlayback";
  };
  var _proto = StitchedContentPlayback2.prototype;
  _proto.init = function init() {
    this.player.ads._shouldBlockPlay = false;
  };
  _proto.onContentChanged = function onContentChanged() {
    this.player.ads.debug("Received contentchanged event (" + this.constructor._getName() + ")");
  };
  _proto.startLinearAdMode = function startLinearAdMode() {
    var StitchedAdRoll2 = States.getState("StitchedAdRoll");
    this.transitionTo(StitchedAdRoll2);
  };
  return StitchedContentPlayback2;
}(ContentState$4);
States.registerState("StitchedContentPlayback", StitchedContentPlayback);
var AdState$4 = States.getState("AdState");
var StitchedAdRoll = /* @__PURE__ */ function(_AdState) {
  _inheritsLoose(StitchedAdRoll2, _AdState);
  function StitchedAdRoll2() {
    return _AdState.apply(this, arguments) || this;
  }
  StitchedAdRoll2._getName = function _getName() {
    return "StitchedAdRoll";
  };
  var _proto = StitchedAdRoll2.prototype;
  _proto.init = function init() {
    this.waitingForAdBreak = false;
    this.contentResuming = false;
    this.player.ads.adType = "stitched";
    obj$1.start(this.player);
  };
  _proto.onPlaying = function onPlaying() {
  };
  _proto.onContentResumed = function onContentResumed() {
  };
  _proto.onAdEnded = function onAdEnded() {
    this.endLinearAdMode();
    this.player.trigger("ended");
  };
  _proto.endLinearAdMode = function endLinearAdMode() {
    var StitchedContentPlayback2 = States.getState("StitchedContentPlayback");
    obj$1.end(this.player);
    this.transitionTo(StitchedContentPlayback2);
  };
  return StitchedAdRoll2;
}(AdState$4);
States.registerState("StitchedAdRoll", StitchedAdRoll);
var isMiddlewareMediatorSupported$1 = obj.isMiddlewareMediatorSupported;
var VIDEO_EVENTS = import_video.default.getTech("Html5").Events;
var defaults = {
  timeout: 5e3,
  prerollTimeout: void 0,
  postrollTimeout: void 0,
  debug: false,
  stitchedAds: false,
  contentIsLive: void 0,
  liveCuePoints: true,
  allowVjsAutoplay: import_video.default.options.normalizeAutoplay || false
};
var contribAdsPlugin = function contribAdsPlugin2(options) {
  var player = this;
  var settings2 = import_video.default.mergeOptions(defaults, options);
  var videoEvents = [];
  VIDEO_EVENTS.concat(["firstplay", "loadedalldata"]).forEach(function(eventName) {
    if (videoEvents.indexOf(eventName) === -1) {
      videoEvents.push(eventName);
    }
  });
  player.on(videoEvents, redispatch);
  if (!isMiddlewareMediatorSupported$1()) {
    initCancelContentPlay(player, settings2.debug);
  }
  player.setTimeout(function() {
    if (!player.ads._hasThereBeenALoadStartDuringPlayerLife && player.src() !== "") {
      import_video.default.log.error("videojs-contrib-ads has not seen a loadstart event 5 seconds after being initialized, but a source is present. This indicates that videojs-contrib-ads was initialized too late. It must be initialized immediately after video.js in the same tick. As a result, some ads will not play and some media events will be incorrect. For more information, see http://videojs.github.io/videojs-contrib-ads/integrator/getting-started.html");
    }
  }, 5e3);
  player.on("ended", function() {
    if (!player.hasClass("vjs-has-started")) {
      player.addClass("vjs-has-started");
    }
  });
  player.on("contenttimeupdate", function() {
    player.removeClass("vjs-waiting");
  });
  player.on(["addurationchange", "adcanplay"], function() {
    if (player.ads.settings.stitchedAds) {
      return;
    }
    if (player.hasStarted()) {
      return;
    }
    if (player.ads.snapshot && player.currentSrc() === player.ads.snapshot.currentSrc) {
      return;
    }
    if (!player.ads.inAdBreak()) {
      return;
    }
    var playPromise = player.play();
    if (playPromise && playPromise.catch) {
      playPromise.catch(function(error) {
        import_video.default.log.warn("Play promise rejected when playing ad", error);
      });
    }
  });
  player.on("nopreroll", function() {
    player.ads.debug("Received nopreroll event");
    player.ads.nopreroll_ = true;
  });
  player.on("nopostroll", function() {
    player.ads.debug("Received nopostroll event");
    player.ads.nopostroll_ = true;
  });
  player.on("playing", function() {
    player.ads._cancelledPlay = false;
    player.ads._pausedOnContentupdate = false;
  });
  player.on("play", function() {
    player.ads._playRequested = true;
  });
  player.one("loadstart", function() {
    player.ads._hasThereBeenALoadStartDuringPlayerLife = true;
  });
  player.on("loadeddata", function() {
    player.ads._hasThereBeenALoadedData = true;
  });
  player.on("loadedmetadata", function() {
    player.ads._hasThereBeenALoadedMetaData = true;
  });
  player.ads = getAds(player);
  player.ads.settings = settings2;
  settings2.stitchedAds = !!settings2.stitchedAds;
  if (settings2.stitchedAds) {
    player.ads._state = new (States.getState("StitchedContentPlayback"))(player);
  } else {
    player.ads._state = new (States.getState("BeforePreroll"))(player);
  }
  player.ads._state.init(player);
  player.ads.cueTextTracks = cueTextTracks;
  player.ads.adMacroReplacement = adMacroReplacement.bind(player);
  initializeContentupdate(player);
  player.on("contentchanged", player.ads.reset);
  var shouldDisableTracks = function shouldDisableTracks2() {
    return !player.ads.shouldPlayContentBehindAd(player) && player.ads.inAdBreak() && player.tech_.featuresNativeTextTracks && import_video.default.browser.IS_IOS && !Array.isArray(player.textTracks());
  };
  var textTrackChangeHandler = function textTrackChangeHandler2() {
    var textTrackList = player.textTracks();
    if (shouldDisableTracks()) {
      for (var i = 0; i < textTrackList.length; i++) {
        var track = textTrackList[i];
        if (track.mode === "showing") {
          track.mode = "disabled";
        }
      }
    }
  };
  player.ready(function() {
    player.textTracks().addEventListener("change", textTrackChangeHandler);
  });
  player.on(["play", "playing", "ended", "adsready", "adscanceled", "adskip", "adserror", "adtimeout", "adended", "ads-ad-started", "contentchanged", "dispose", "contentresumed", "readyforpostroll", "nopreroll", "nopostroll"], function(e) {
    player.ads._state.handleEvent(e.type);
  });
  player.on("dispose", function() {
    player.ads.reset();
    player.textTracks().removeEventListener("change", textTrackChangeHandler);
  });
  listenToTcf();
  player.ads.listenToTcf = listenToTcf;
};
contribAdsPlugin.VERSION = version;
register(contribAdsPlugin);
var videojs_contrib_ads_es_default = contribAdsPlugin;

// client/video-watch-client-plugin.js
var import_videojsx_vast = __toESM(require_videojsx_vast());

// lib/shared.js
var DEFAULT_SKIP_TIME = 8;
var DEFAULT_SKIP_COUNTDOWN_MESSAGE = "Skip in {seconds}...";
var DEFAULT_SKIP_MESSAGE = "Skip";
var ARMANET_JS_URL = "https://assets.armanet.us/armanet-pxl.js";
var COMPANION_CONFIGS = {
  video: {
    selector: ".video-info-first-row-bottom",
    className: "companion-video-holder px-3",
    insertAfter: true
  },
  sidebar: {
    selector: ".other-videos",
    className: "companion-sidebar-holder mb-3",
    insertAfter: false
  }
};
var ARMANET_RESOURCES = {
  domains: {
    image: "i.armanet.us",
    service: "srv.armanet.us"
  }
};
var scriptLoadPromise = null;
var settings = (s) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  return {
    preroll: {
      enabled: (_a = s["armanet-preroll-enabled"]) != null ? _a : false,
      adUnit: s["armanet-preroll-adunit"]
    },
    midroll: {
      enabled: (_b = s["armanet-midroll-enabled"]) != null ? _b : false,
      adUnit: s["armanet-midroll-adunit"],
      minTime: (_c = s["armanet-midroll-min-minutes"]) != null ? _c : 0,
      offset: (_d = s["armanet-midroll-offset"]) != null ? _d : "25%"
    },
    postroll: {
      enabled: (_e = s["armanet-postroll-enabled"]) != null ? _e : false,
      adUnit: s["armanet-postroll-adunit"],
      minTime: (_f = s["armanet-postroll-min-minutes"]) != null ? _f : 0
    },
    companion: {
      video: {
        enabled: (_g = s["armanet-companion-video-enabled"]) != null ? _g : false,
        adUnit: s["armanet-companion-video-adunit"]
      },
      sidebar: {
        enabled: (_h = s["armanet-companion-sidebar-enabled"]) != null ? _h : false,
        adUnit: s["armanet-companion-sidebar-adunit"]
      }
    },
    embededEnabled: (_i = s["armanet-embeded-enabled"]) != null ? _i : true,
    controlsEnabled: (_j = s["armanet-player-controls-enabled"]) != null ? _j : true,
    skipTime: (_k = s["armanet-skip-time"]) != null ? _k : DEFAULT_SKIP_TIME,
    messageSkipCountdown: (_l = s["armanet-message-skip-countdown"]) != null ? _l : DEFAULT_SKIP_COUNTDOWN_MESSAGE,
    messageSkip: (_m = s["armanet-message-skip"]) != null ? _m : DEFAULT_SKIP_MESSAGE,
    messageRemainingTime: s["armanet-message-remainingTime"],
    clientDebugEnabled: (_n = s["armanet-client-debug-enabled"]) != null ? _n : false
  };
};
var isArmanetPxlLoaded = () => {
  return !!document.querySelector(`script[src="${ARMANET_JS_URL}"]`);
};
var loadArmanetPxl = () => {
  if (scriptLoadPromise)
    return scriptLoadPromise;
  scriptLoadPromise = new Promise((resolve, reject) => {
    if (isArmanetPxlLoaded()) {
      resolve();
      return;
    }
    const script = document.createElement("script");
    script.src = ARMANET_JS_URL;
    script.defer = true;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
  return scriptLoadPromise;
};
var setupResourceHints = () => {
  const hints = [
    {
      rel: "dns-prefetch",
      urls: Object.values(ARMANET_RESOURCES.domains).map((domain) => `//${domain}`)
    },
    {
      rel: "preconnect",
      urls: Object.values(ARMANET_RESOURCES.domains).map((domain) => `https://${domain}`)
    }
  ];
  const existingHints = new Set(Array.from(document.querySelectorAll('link[rel="dns-prefetch"], link[rel="preconnect"]')).map((link) => `${link.rel}:${link.href}`));
  const fragment = document.createDocumentFragment();
  hints.forEach(({ rel, urls }) => {
    urls.forEach((url) => {
      const hintKey = `${rel}:${url}`;
      if (!existingHints.has(hintKey)) {
        const link = document.createElement("link");
        link.rel = rel;
        link.href = url;
        fragment.appendChild(link);
      }
    });
  });
  if (fragment.hasChildNodes()) {
    document.head.appendChild(fragment);
  }
};
var cleanupCompanions = () => {
  const companionHolders = document.querySelectorAll(".companion-video-holder, .companion-sidebar-holder");
  companionHolders.forEach((holder) => holder.remove());
};
var cleanupVastElements = () => {
  document.querySelectorAll(".vast-blocker, .vast-skip-button, .vast-remaining-time, .vast-remaining-time-icon").forEach((element) => element.remove());
};
var getRollsStatus = (pluginSettings) => {
  const isRollEnabled = (roll) => roll.adUnit && roll.enabled;
  const rolls = {
    preroll: isRollEnabled(pluginSettings.preroll),
    midroll: isRollEnabled(pluginSettings.midroll),
    postroll: isRollEnabled(pluginSettings.postroll)
  };
  return __spreadProps(__spreadValues({}, rolls), {
    hasAtLeastOneRollEnabled: Object.values(rolls).some(Boolean)
  });
};
var getCompanionsStatus = (pluginSettings) => {
  const isCompanionEnabled = (companion) => companion.adUnit && companion.enabled;
  const companions = {
    video: isCompanionEnabled(pluginSettings.companion.video),
    sidebar: isCompanionEnabled(pluginSettings.companion.sidebar)
  };
  return __spreadProps(__spreadValues({}, companions), {
    hasAtLeastOneCompanionEnabled: Object.values(companions).some(Boolean)
  });
};
var handleCompanions = async (settings2, clientDebug) => {
  const enabledCompanions = Object.entries(settings2.companion).filter(([_, config]) => config.enabled && config.adUnit);
  const insertCompanion = async ([type, config]) => {
    const companionConfig = COMPANION_CONFIGS[type];
    if (!companionConfig) {
      clientDebug("COMPANION", `Invalid companion type: ${type}`);
      return;
    }
    const reference = document.querySelector(companionConfig.selector);
    if (!reference) {
      clientDebug("COMPANION", `Reference element not found for ${type}`);
      return;
    }
    try {
      const holder = document.createElement("div");
      holder.className = companionConfig.className;
      holder.innerHTML = `<div data-armanet="${config.adUnit}"></div>`;
      if (companionConfig.insertAfter) {
        reference.parentNode.insertBefore(holder, reference.nextSibling);
      } else {
        reference.insertBefore(holder, reference.firstChild);
      }
      clientDebug("COMPANION", `Successfully inserted ${type} companion with AdUnit ${config.adUnit}`);
    } catch (error) {
      console.error(`[ARMANET INTEGRATION PLUGIN] Error inserting ${type} companion:`, error);
    }
  };
  await Promise.all(enabledCompanions.map(insertCompanion));
};
var createVastSettings = async (pluginSettings, Armanet2, channelName, channelAdUnit, userData, videoTags, video) => {
  const {
    skipTime,
    controlsEnabled,
    messageSkip,
    messageSkipCountdown,
    messageRemainingTime,
    clientDebugEnabled
  } = pluginSettings;
  const vastSettings = {
    skip: skipTime,
    controlsEnabled,
    seekEnabled: controlsEnabled,
    withCredentials: false,
    messages: {
      skip: messageSkip,
      skipCountdown: messageSkipCountdown
    },
    schedule: [],
    vastData: []
  };
  if (messageRemainingTime == null ? void 0 : messageRemainingTime.includes("{seconds}")) {
    Object.assign(vastSettings, {
      displayRemainingTime: true,
      displayRemainingTimeIcons: true,
      messages: __spreadProps(__spreadValues({}, vastSettings.messages), {
        remainingTime: messageRemainingTime
      })
    });
  }
  const getArmanetVastUrl = (adUnit, roll) => {
    const armanetParams = __spreadValues(__spreadValues({
      roll,
      channel: channelName,
      skippable: skipTime > 0
    }, (userData == null ? void 0 : userData.username) && (userData == null ? void 0 : userData.email) && { viewer: [userData.username, userData.email] }), videoTags.length > 0 && { tags: videoTags });
    if (clientDebugEnabled) {
      console.log("[ARMANET INTEGRATION PLUGIN] [debug] [createVastSettings] [getArmanetVastUrl]", { adUnit, armanetParams });
    }
    return Armanet2.getVastTag(adUnit, armanetParams) || "";
  };
  const rollsStatus = getRollsStatus(pluginSettings);
  const rollConfigs = {
    preroll: { offset: "pre", roll: "pre", minTime: 0 },
    midroll: {
      offset: pluginSettings.midroll.offset,
      roll: "mid",
      minTime: pluginSettings.midroll.minTime
    },
    postroll: {
      offset: "post",
      roll: "post",
      minTime: pluginSettings.postroll.minTime
    }
  };
  Object.entries(rollConfigs).forEach(([rollType, { offset, roll, minTime }]) => {
    if (rollsStatus[rollType]) {
      const rollAdUnit = channelAdUnit || pluginSettings[rollType].adUnit;
      if (rollAdUnit && offset) {
        if (video.duration != 0) {
          const videoDurationInMins = parseInt(video.duration / 60);
          if (videoDurationInMins < minTime)
            return;
        }
        const vastUrl = getArmanetVastUrl(rollAdUnit, roll);
        if (clientDebugEnabled) {
          console.log("[ARMANET INTEGRATION PLUGIN] [debug] [createVastSettings] adding roll schedule", { rollAdUnit, offset, vastUrl });
        }
        vastSettings.schedule.push({
          offset,
          url: vastUrl
        });
      }
    }
  });
  return vastSettings;
};
var createClientDebug = (clientDebugEnabled) => {
  return (section, message, data) => {
    if (!clientDebugEnabled)
      return;
    const prefix = "[ARMANET INTEGRATION PLUGIN] [debug]";
    const sectionTag = section ? ` [${section}]` : "";
    if (data) {
      console.log(`${prefix}${sectionTag}`, message, data);
    } else {
      console.log(`${prefix}${sectionTag}`, message);
    }
  };
};

// client/video-watch-client-plugin.js
function register2({ registerHook, peertubeHelpers }) {
  initArmanetIntegration(registerHook, peertubeHelpers).catch((err) => console.error("[ARMANET INTEGRATION PLUGIN] Cannot initialize plugin", err));
}
async function initArmanetIntegration(registerHook, peertubeHelpers) {
  var _a, _b;
  const s = await peertubeHelpers.getSettings();
  if (!s) {
    console.error("Could not find settings.");
    return;
  }
  const pluginSettings = settings(s);
  const clientDebug = createClientDebug(pluginSettings.clientDebugEnabled);
  const rollsStatus = getRollsStatus(pluginSettings);
  const companionsStatus = getCompanionsStatus(pluginSettings);
  const authUser = await peertubeHelpers.getUser();
  const userData = {
    username: (_a = authUser == null ? void 0 : authUser.username) != null ? _a : "",
    email: (_b = authUser == null ? void 0 : authUser.email) != null ? _b : ""
  };
  let resourceHintsConfigured = false;
  registerHook({
    target: "action:router.navigation-end",
    handler: async ({ path }) => {
      if (!path.startsWith("/w/"))
        return;
      console.log("router.navigation-end", path);
      if (window.player) {
        console.log("Cleaning up player before loading new video");
        cleanupVastElements();
      }
      if (companionsStatus.hasAtLeastOneCompanionEnabled) {
        cleanupCompanions();
      }
    }
  });
  registerHook({
    target: "action:video-watch.video.loaded",
    handler: async ({ video }) => {
      var _a2, _b2;
      if (!companionsStatus.hasAtLeastOneCompanionEnabled)
        return;
      const channelIsExcluded = (_b2 = (_a2 = video == null ? void 0 : video.pluginData) == null ? void 0 : _a2.armanet) == null ? void 0 : _b2.is_excluded;
      if (channelIsExcluded)
        return;
      try {
        if (!resourceHintsConfigured) {
          setupResourceHints();
          resourceHintsConfigured = true;
        }
        await loadArmanetPxl();
        await handleCompanions(pluginSettings, clientDebug);
      } catch (error) {
        clientDebug("Companions", "Error handling companions:", error);
      }
    }
  });
  registerHook({
    target: "action:video-watch.player.loaded",
    handler: async ({ videojs: videojs3, player, video }) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (!rollsStatus.hasAtLeastOneRollEnabled)
        return;
      console.log("Initializing ads for new video", video.name);
      window.videojs = videojs3;
      window.player = player;
      const channelIsExcluded = (_b2 = (_a2 = video == null ? void 0 : video.pluginData) == null ? void 0 : _a2.armanet) == null ? void 0 : _b2.is_excluded;
      try {
        if (!videojs3.getPlugin("ads")) {
          videojs3.registerPlugin("ads", videojs_contrib_ads_es_default);
          console.log("ads plugin not registred....xxxx-- registrering22222", (_c = player.activePlugins_) == null ? void 0 : _c.ads, player.activePlugins_);
        } else {
          console.log("ads plugin alreadysiiiii registred....xxxx", (_d = player.activePlugins_) == null ? void 0 : _d.ads);
        }
        player.ads({
          debug: true,
          liveCuePoints: true,
          stitchedAds: true,
          allowVjsAutoplay: false
        });
        await loadArmanetPxl();
        if (typeof Armanet !== "undefined" && (Armanet == null ? void 0 : Armanet.getVastTag)) {
          let setupPlayerListeners = function(player2) {
            player2.off("contentchanged");
            player2.off("readyforpreroll");
            player2.off("adended");
            player2.off("ended");
            player2.on("contentchanged", () => {
              console.log("Content changed, resetting ads");
              player2.ads.reset();
            });
            player2.on("readyforpreroll", () => {
              console.log("Player ready for preroll");
            });
            player2.on("adended", () => {
              console.log("Ad ended, resuming content");
            });
            player2.on("ended", () => {
              console.log("Video ended");
            });
          };
          const channelName = (_f = (_e = video == null ? void 0 : video.channel) == null ? void 0 : _e.name) != null ? _f : "unknown";
          const channelAdUnit = (_j = (_i = (_h = (_g = video == null ? void 0 : video.pluginData) == null ? void 0 : _g.armanet) == null ? void 0 : _h.channel_adUnit) == null ? void 0 : _i.uuid) != null ? _j : null;
          const videoTags = (_k = video == null ? void 0 : video.tags) != null ? _k : [];
          clientDebug("PLAYER", "Player loaded", {
            video,
            videoTags,
            channel: { channelName, channelAdUnit },
            user: userData
          });
          const vastSettings = await createVastSettings(pluginSettings, Armanet, channelName, channelAdUnit, userData, videoTags, video);
          console.log("VAST settings:", vastSettings);
          const vastPlugin = new import_videojsx_vast.default.VastPlugin(player, vastSettings);
          console.log("Vast plugin loadedxxxx", vastPlugin);
          if (!videojs3.getPlugin("vast")) {
            videojs3.registerPlugin("vast", function(options) {
              const player2 = this;
              return new vastPlugin(player2, options);
            });
          }
          console.log("Vast plugin loadedxxxx", import_videojsx_vast.default);
        } else {
          clientDebug("PLAYER", "Armanet or Armanet.getVastTag is not available");
        }
      } catch (error) {
        clientDebug("PLAYER", "Error in Armanet integration:", error);
      }
    }
  });
}
export {
  register2 as register
};
/*!
 * Programatically add the following
 */
/*! @name @videojs/http-streaming @version 2.16.3 @license Apache-2.0 */
/*! @name aes-decrypter @version 3.1.3 @license Apache-2.0 */
/*! @name m3u8-parser @version 4.8.0 @license Apache-2.0 */
/*! @name mpd-parser @version 0.22.1 @license Apache-2.0 */
/*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
/*! @name videojs-contrib-ads @version 6.9.0 @license Apache-2.0 */
/**
 * @license
 * Video.js 7.21.6 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
/**
 * @license
 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
 * Copyright (c) 2014 David Bjrklund
 * Available under the MIT license
 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
 */
